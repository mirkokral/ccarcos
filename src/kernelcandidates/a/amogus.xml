<!-- This file can be parsed by haxe.rtti.XmlParser -->
<haxe>
	<abstract path="Any" params="" file="/usr/share/haxe/std/Any.hx">
		<from><icast><d/></icast></from>
		<this><d/></this>
		<to><icast field="__promote"><c path="__promote.T"/></icast></to>
		<haxe_doc>`Any` is a type that is compatible with any other in both ways.

	This means that a value of any type can be assigned to `Any`, and
	vice-versa, a value of `Any` type can be assigned to any other type.

	It's a more type-safe alternative to `Dynamic`, because it doesn't
	support field access or operators and it's bound to monomorphs. So,
	to work with the actual value, it needs to be explicitly promoted
	to another type.</haxe_doc>
		<meta><m n=":forward.variance"/></meta>
		<impl><class path="_Any.Any_Impl_" params="" file="/usr/share/haxe/std/Any.hx" private="1" module="Any" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="Array" params="T" file="/usr/share/haxe/std/lua/_std/Array.hx">
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The length of `this` Array.</haxe_doc>
		</length>
		<concat public="1" set="method" line="33">
			<f a="a">
				<c path="Array"><c path="Array.T"/></c>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns a new Array by appending the elements of `a` to the elements of
		`this` Array.

		This operation does not modify `this` Array.

		If `a` is the empty Array `[]`, a copy of `this` Array is returned.

		The length of the returned Array is equal to the sum of `this.length`
		and `a.length`.

		If `a` is `null`, the result is unspecified.</haxe_doc>
		</concat>
		<join public="1" set="method" line="40">
			<f a="sep">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string representation of `this` Array, with `sep` separating
		each element.

		The result of this operation is equal to `Std.string(this[0]) + sep +
		Std.string(this[1]) + sep + ... + sep + Std.string(this[this.length-1])`

		If `this` is the empty Array `[]`, the result is the empty String `""`.
		If `this` has exactly one element, the result is equal to a call to
		`Std.string(this[0])`.

		If `sep` is null, the result is unspecified.</haxe_doc>
		</join>
		<pop public="1" set="method" line="48">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<haxe_doc>Removes the last element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this.length` will decrease by 1.

		If `this` is the empty Array `[]`, null is returned and the length
		remains 0.</haxe_doc>
		</pop>
		<push public="1" set="method" line="57">
			<f a="x">
				<c path="Array.T"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Adds the element `x` at the end of `this` Array and returns the new
		length of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` increases by 1.</haxe_doc>
		</push>
		<reverse public="1" set="method" line="62">
			<f a=""><x path="Void"/></f>
			<haxe_doc><![CDATA[Reverse the order of elements of `this` Array.

		This operation modifies `this` Array in place.

		If `this.length < 2`, `this` remains unchanged.]]></haxe_doc>
		</reverse>
		<shift public="1" set="method" line="73">
			<f a=""><x path="Null"><c path="Array.T"/></x></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Removes the first element of `this` Array and returns it.

		This operation modifies `this` Array in place.

		If `this` has at least one element, `this`.length and the index of each
		remaining element is decreased by 1.

		If `this` is the empty Array `[]`, `null` is returned and the length
		remains 0.</haxe_doc>
		</shift>
		<slice public="1" set="method" line="87">
			<f a="pos:?end">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Creates a shallow copy of the range of `this` Array, starting at and
		including `pos`, up to but not including `end`.

		This operation does not modify `this` Array.

		The elements are not copied and retain their identity.

		If `end` is omitted or exceeds `this.length`, it defaults to the end of
		`this` Array.

		If `pos` or `end` are negative, their offsets are calculated from the
		end of `this` Array by `this.length + pos` and `this.length + end`
		respectively. If this yields a negative value, 0 is used instead.

		If `pos` exceeds `this.length` or if `end` is less than or equals
		`pos`, the result is `[]`.</haxe_doc>
		</slice>
		<sort public="1" set="method" line="105">
			<f a="f">
				<f a=":">
					<c path="Array.T"/>
					<c path="Array.T"/>
					<x path="Int"/>
				</f>
				<x path="Void"/>
			</f>
			<haxe_doc><![CDATA[Sorts `this` Array according to the comparison function `f`, where
		`f(x,y)` returns 0 if x == y, a positive Int if x > y and a
		negative Int if x < y.

		This operation modifies `this` Array in place.

		The sort operation is not guaranteed to be stable, which means that the
		order of equal elements may not be retained. For a stable Array sorting
		algorithm, `haxe.ds.ArraySort.sort()` can be used instead.

		If `f` is null, the result is unspecified.]]></haxe_doc>
		</sort>
		<splice public="1" set="method" line="127">
			<f a="pos:len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc><![CDATA[Removes `len` elements from `this` Array, starting at and including
		`pos`, an returns them.

		This operation modifies `this` Array in place.

		If `len` is < 0 or `pos` exceeds `this`.length, an empty Array [] is
		returned and `this` Array is unchanged.

		If `pos` is negative, its value is calculated from the end	of `this`
		Array by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the sum of the resulting values for `len` and `pos` exceed
		`this.length`, this operation will affect the elements from `pos` to the
		end of `this` Array.

		The length of the returned Array is equal to the new length of `this`
		Array subtracted from the original length of `this` Array. In other
		words, each element of the original `this` Array either remains in
		`this` Array or becomes an element of the returned Array.]]></haxe_doc>
		</splice>
		<toString public="1" set="method" line="145">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string representation of `this` Array.

		The result will include the individual elements' String representations
		separated by comma. The enclosing [ ] may be missing on some platforms,
		use `Std.string()` to get a String representation that is consistent
		across platforms.</haxe_doc>
		</toString>
		<unshift public="1" set="method" line="153">
			<f a="x">
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Adds the element `x` at the start of `this` Array.

		This operation modifies `this` Array in place.

		`this.length` and the index of each Array element increases by 1.</haxe_doc>
		</unshift>
		<insert public="1" get="inline" set="null" line="160">
			<f a="pos:x">
				<x path="Int"/>
				<c path="Array.T"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Inserts the element `x` at the position `pos`.

		This operation modifies `this` Array in place.

		The offset is calculated like so:

		- If `pos` exceeds `this.length`, the offset is `this.length`.
		- If `pos` is negative, the offset is calculated from the end of `this`
		  Array, i.e. `this.length + pos`. If this yields a negative value, the
		  offset is 0.
		- Otherwise, the offset is `pos`.

		If the resulting offset does not exceed `this.length`, all elements from
		and including that offset to the end of `this` Array are moved one index
		ahead.</haxe_doc>
		</insert>
		<remove public="1" set="method" line="176">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Removes the first occurrence of `x` in `this` Array.

		This operation modifies `this` Array in place.

		If `x` is found by checking standard equality, it is removed from `this`
		Array and all following elements are reindexed accordingly. The function
		then returns true.

		If `x` is not found, `this` Array is not changed and the function
		returns false.</haxe_doc>
		</remove>
		<contains public="1" set="method" line="195">
			<f a="x">
				<c path="Array.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns whether `this` Array contains `x`.

		If `x` is found by checking standard equality, the function returns `true`, otherwise
		the function returns `false`.</haxe_doc>
		</contains>
		<indexOf public="1" set="method" line="203">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the first occurrence of `x` in `this` Array, searching front to back.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with zero index. If it is negative, it will be taken as the
		offset from the end of `this` Array to compute the starting index. If given or computed
		starting index is less than 0, the whole array will be searched, if it is greater than
		or equal to the length of `this` Array, the function returns -1.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method" line="219">
			<f a="x:?fromIndex">
				<c path="Array.T"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns position of the last occurrence of `x` in `this` Array, searching back to front.

		If `x` is found by checking standard equality, the function returns its index.

		If `x` is not found, the function returns -1.

		If `fromIndex` is specified, it will be used as the starting index to search from,
		otherwise search starts with the last element index. If it is negative, it will be
		taken as the offset from the end of `this` Array to compute the starting index. If
		given or computed starting index is greater than or equal to the length of `this` Array,
		the whole array will be searched, if it is less than 0, the function returns -1.</haxe_doc>
		</lastIndexOf>
		<copy public="1" get="inline" set="null" line="237">
			<f a=""><c path="Array"><c path="Array.T"/></c></f>
			<haxe_doc>Returns a shallow copy of `this` Array.

		The elements are not copied and retain their identity, so
		`a[i] == a.copy()[i]` is true for any valid `i`. However,
		`a == a.copy()` is always false.</haxe_doc>
		</copy>
		<map public="1" params="S" get="inline" set="null" line="241">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<c path="map.S"/>
				</f>
				<c path="Array"><c path="map.S"/></c>
			</f>
			<haxe_doc>Creates a new Array by applying function `f` to all elements of `this`.

		The order of elements is preserved.

		If `f` is null, the result is unspecified.</haxe_doc>
		</map>
		<filter public="1" get="inline" set="null" line="245">
			<f a="f">
				<f a="">
					<c path="Array.T"/>
					<x path="Bool"/>
				</f>
				<c path="Array"><c path="Array.T"/></c>
			</f>
			<haxe_doc>Returns an Array containing those elements of `this` for which `f`
		returned true.

		The individual elements are not duplicated and retain their identity.

		If `f` is null, the result is unspecified.</haxe_doc>
		</filter>
		<iterator public="1" get="inline" set="null" line="249">
			<f a=""><c path="haxe.iterators.ArrayIterator"><c path="Array.T"/></c></f>
			<haxe_doc>Returns an iterator of the Array values.</haxe_doc>
		</iterator>
		<keyValueIterator public="1" get="inline" set="null" line="253">
			<f a=""><c path="haxe.iterators.ArrayKeyValueIterator"><c path="Array.T"/></c></f>
			<haxe_doc>Returns an iterator of the Array indices and values.</haxe_doc>
		</keyValueIterator>
		<resize public="1" set="method" line="257">
			<f a="len">
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Set the length of the Array.

		If `len` is shorter than the array's current size, the last
		`length - len` elements will be removed. If `len` is longer, the Array
		will be extended, with new elements set to a target-specific default
		value:

		- always null on dynamic targets
		- 0, 0.0 or false for Int, Float and Bool respectively on static targets
		- null for other types on static targets</haxe_doc>
		</resize>
		<new public="1" set="method" line="29">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a new Array.</haxe_doc>
		</new>
		<haxe_doc>An Array is a storage for values. You can access it using indexes or
	with its API.

	@see https://haxe.org/manual/std-Array.html
	@see https://haxe.org/manual/lf-array-comprehension.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Class" params="T" file="/usr/share/haxe/std/Class.hx">
		<this><x path="Class"><c path="Class.T"/></x></this>
		<haxe_doc>An abstract type that represents a Class.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-class-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<class path="lua.lib.lrexlib.Rex" params="" file="/usr/share/haxe/std/lua/lib/lrexlib/Rex.hx" extern="1">
		<create public="1" get="inline" set="null" line="29" static="1">
			<f a="expr:flag">
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<x path="Int"/>
					<c path="String"/>
				</x>
				<c path="lua.lib.lrexlib.Rex"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</create>
		<match public="1" set="method" static="1">
			<f a="patt:subj:?init:?ef">
				<x path="haxe.extern.EitherType">
					<c path="lua.lib.lrexlib.Rex"/>
					<c path="String"/>
				</x>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>The function searches for the first match of the regexp `patt` in the
		string `subj`, starting from offset `init`, subject to flags `cf` and `ef`.

		@return matched string, or array of strings.</haxe_doc>
		</match>
		<find public="1" set="method" static="1">
			<f a="patt:subj:?init:?ef">
				<x path="haxe.extern.EitherType">
					<c path="lua.lib.lrexlib.Rex"/>
					<c path="String"/>
				</x>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>The function searches for the first match of the regexp patt in the string
		`subj`, starting from offset `init`, subject to flags `cf` and `ef`.</haxe_doc>
		</find>
		<split public="1" set="method" static="1">
			<f a="subj:sep:?cf:?ef">
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="lua.lib.lrexlib.Rex"/>
					<c path="String"/>
				</x>
				<x path="Int"/>
				<x path="Int"/>
				<f a=""><c path="String"/></f>
			</f>
			<haxe_doc>The function is intended for use in the generic for Lua construct. It is
		used for splitting a subject string `subj` into parts (sections). The `sep`
		parameter is a regular expression pattern representing separators between
		the sections.</haxe_doc>
		</split>
		<count public="1" set="method" static="1">
			<f a="subj:patt:cf:ef">
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="lua.lib.lrexlib.Rex"/>
					<c path="String"/>
				</x>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>This function counts matches of the pattern `patt` in the string `subj`.</haxe_doc>
		</count>
		<flags public="1" set="method" static="1"><f a="?tb">
	<d/>
	<d/>
</f></flags>
		<gmatch public="1" set="method" static="1">
			<f a="subj:patt:?cf:?ef">
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="lua.lib.lrexlib.Rex"/>
					<c path="String"/>
				</x>
				<x path="Int"/>
				<x path="Int"/>
				<f a=""><c path="String"/></f>
			</f>
			<haxe_doc>The function is intended for use in the generic for Lua construct. It
		returns an iterator for repeated matching of the pattern patt in the
		string `subj`, subject to flags `cf` and `ef`.</haxe_doc>
		</gmatch>
		<gsub public="1" set="method" static="1">
			<f a="subj:patt:repl:?n:?cf:?ef">
				<c path="String"/>
				<x path="haxe.extern.EitherType">
					<c path="lua.lib.lrexlib.Rex"/>
					<c path="String"/>
				</x>
				<d/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>This function searches for all matches of the pattern `patt` in the string
		`subj` and replaces them according to the parameters `repl` and `n`.</haxe_doc>
		</gsub>
		<tfind public="1" set="method">
			<f a="subj:?init:?ef">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>The function searches for the first match of the regexp in the string
		`subj`, starting from offset `init`, subject to execution flags `ef`.</haxe_doc>
		</tfind>
		<exec public="1" set="method">
			<f a="subj:?init:?ef">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>This function searches for the first match of the regexp in the string
		`subj`, starting from offset `init`, subject to execution flags `ef`.</haxe_doc>
		</exec>
		<meta><m n=":luaRequire"><e>"rex_pcre2"</e></m></meta>
	</class>
	<class path="lua.NativeStringTools" params="" file="/usr/share/haxe/std/lua/NativeStringTools.hx" extern="1">
		<len public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Receives a string and returns its length. The empty string `""` has
		length `0`. Embedded zeros are counted, so `"a\000bc\000"` has length `5`.</haxe_doc>
		</len>
		<char public="1" set="method" static="1">
			<f a="codes">
				<t path="haxe.extern.Rest"><x path="Int"/></t>
				<c path="String"/>
			</f>
			<haxe_doc>Receives zero or more integers. Returns a string with length equal to the
		number of arguments, in which each character has the internal numerical
		code equal to its corresponding argument.
		Note that numerical codes are not necessarily portable across platforms.</haxe_doc>
		</char>
		<sub public="1" set="method" static="1">
			<f a="str:start:?end">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="lua.StringSub"/>
			</f>
			<haxe_doc>Returns the substring of `str` that starts at `start` and continues until `end`;
		`start` and `end` can be negative. If `end` is absent, then it is assumed to be
		equal to `-1` (which is the same as the string length).
		In particular, the call `sub(str,1,end)` returns a prefix of `str`
		with length `end`, and `sub(str, -end)` returns a suffix of `str` with
		length `start`.</haxe_doc>
		</sub>
		<find public="1" set="method" static="1">
			<f a="str:target:?start:?plain">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="lua.StringFind"/>
			</f>
			<haxe_doc>Looks for the first match of pattern in the string `str`.
		If it finds a match, then `find` returns the indices of `str` where this
		occurrence starts and ends.

		@param target If the target has captures, then in a successful match the
			   captured values are also returned, after the two indices.
		@param start specifies where to start the search; its default value is `1`
			   and can be negative.
		@param plain turns off the pattern matching facilities, so the function does
			   a plain "find substring" operation, with no characters in pattern
			   being considered "magic". Note that if plain is given, then `start` must be given as well.</haxe_doc>
		</find>
		<byte public="1" set="method" static="1">
			<f a="str:?index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the internal numerical codes of the characters `str[index]`.
		Note that numerical codes are not necessarily portable across platforms.</haxe_doc>
		</byte>
		<format public="1" set="method" static="1">
			<f a="str:?e1:?e2:?e3:?e4">
				<c path="String"/>
				<d/>
				<d/>
				<d/>
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a formatted version of its variable number of arguments following
		the description given in its first argument (which must be a string).
		The format string follows the same rules as the printf family of standard C
		functions. The only differences are that the options/modifiers
		`*`, `l`, `L`, `n`, `p`, and `h` are not supported and that there is an
		extra option, `q`. The `q` option formats a string in a form suitable to be
		safely read back by the Lua interpreter: the string is written between
		double quotes, and all double quotes, newlines, embedded zeros,
		and backslashes in the string are correctly escaped when written.
		For instance, the call
		   `string.format('%q', 'a string with "quotes" and \n new line')`
		will produce the string:
		`"a string with \"quotes\" and \
			  new line"`

		The options `c`, `d` `E`, `e`, `f`, `g`, `G`, `i`, `o`, `u, `X-, and `x` all
		expect a number as argument, whereas `q` and `s` expect a string.

		This function does not accept string values containing embedded zeros,
		except as arguments to the `q` option.</haxe_doc>
		</format>
		<gsub public="1" set="method" static="1">
			<f a="str:pattern:replace:?n">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
			<overloads>
				<gsub public="1" set="method">
					<f a="str:pattern:replace:?n">
						<c path="String"/>
						<c path="String"/>
						<f a="">
							<c path="String"/>
							<x path="Void"/>
						</f>
						<x path="Int"/>
						<c path="String"/>
					</f>
					<haxe_doc></haxe_doc>
				</gsub>
				<gsub public="1" set="method">
					<f a="str:pattern:replace:?n">
						<c path="String"/>
						<c path="String"/>
						<f a="">
							<c path="String"/>
							<c path="String"/>
						</f>
						<x path="Int"/>
						<c path="String"/>
					</f>
					<haxe_doc></haxe_doc>
				</gsub>
			</overloads>
		</gsub>
		<gmatch public="1" set="method" static="1">
			<f a="str:pattern">
				<c path="String"/>
				<c path="String"/>
				<f a=""><c path="String"/></f>
			</f>
			<haxe_doc>Returns an iterator function that, each time it is called, returns the next
		captures from pattern over string `str`. If `pattern` specifies no captures,
		then the whole match is produced in each call.</haxe_doc>
			<overloads><gmatch public="1" set="method">
	<f a="str:pattern:match:?n">
		<c path="String"/>
		<c path="String"/>
		<f a=""><c path="String"/></f>
		<x path="Int"/>
		<f a="">
			<c path="String"/>
			<x path="Void"/>
		</f>
	</f>
	<haxe_doc>Returns an iterator function that, each time it is called, returns the next
		captures from pattern over string `str`. If `pattern` specifies no captures,
		then the whole match is produced in each call.</haxe_doc>
</gmatch></overloads>
		</gmatch>
		<match public="1" set="method" static="1">
			<f a="str:pattern:?n">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Looks for the first match of pattern in the string s. If it finds one,
		then match returns the captures from the pattern; otherwise it returns `null`.
		If pattern specifies no captures, then the whole match is returned.
		The optional argument `n` specifies where to start the search;
		its default value is `1` and can be negative.</haxe_doc>
		</match>
		<upper public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Receives a string and returns a copy of this string with all lowercase
		letters changed to uppercase. All other characters are left unchanged.
		The definition of what a lowercase letter is depends on the current locale.</haxe_doc>
		</upper>
		<lower public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Receives a string and returns a copy of this string with all uppercase
		letters changed to lowercase. All other characters are left unchanged.
		The definition of what an uppercase letter is depends on the current locale.</haxe_doc>
		</lower>
		<dump public="1" set="method" static="1">
			<f a="d">
				<d/>
				<d/>
			</f>
			<haxe_doc>Returns a string containing a binary representation of the given function,
		so that a later loadstring on this string returns a copy of the function.
		function must be a Lua function without upvalues.</haxe_doc>
		</dump>
		<rep public="1" set="method" static="1">
			<f a="s:n:?sep">
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string that is the concatenation of n copies of
        the string s separated by the string sep. The default value
        for sep is the empty string (that is, no separator).
        Returns the empty string if n is not positive.  (Note that
        it is very easy to exhaust the memory of your machine with
        a single call to this function.)</haxe_doc>
		</rep>
		<haxe_doc>These are all externs for the base Lua "string" class, which functions
	as an additional set of string tools.

	Note that all relevant indexes are "1" based.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"_G.string"</e></m>
		</meta>
	</class>
	<abstract path="Enum" params="T" file="/usr/share/haxe/std/Enum.hx">
		<this><x path="Enum"><c path="Enum.T"/></x></this>
		<haxe_doc>An abstract type that represents an Enum type.

	The corresponding enum instance type is `EnumValue`.

	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="EnumValue" params="" file="/usr/share/haxe/std/EnumValue.hx">
		<this><x path="EnumValue"/></this>
		<haxe_doc>An abstract type that represents any enum value.
	See `Type` for the Haxe Reflection API.

	@see https://haxe.org/manual/types-enum-instance.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
		<impl><class path="_EnumValue.EnumValue_Impl_" params="" file="/usr/share/haxe/std/EnumValue.hx" private="1" module="EnumValue" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="CPos" params="" file="Externs.hx" module="Externs" extern="1">
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="A" params="" file="Externs.hx" module="Externs" extern="1">
		<t1 public="1"><c path="String"/></t1>
		<t2 public="1"><x path="Float"/></t2>
		<t3 public="1"><x path="Bool"/></t3>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="Term" params="" file="Externs.hx" module="Externs" extern="1">
		<write public="1" set="method" static="1"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></write>
		<clear public="1" set="method" static="1"><f a=""><x path="Void"/></f></clear>
		<setTextColor public="1" set="method" static="1"><f a="newColor">
	<x path="Int"/>
	<x path="Void"/>
</f></setTextColor>
		<setBackgroundColor public="1" set="method" static="1"><f a="newColor">
	<x path="Int"/>
	<x path="Void"/>
</f></setBackgroundColor>
		<setCursorPos public="1" set="method" static="1"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setCursorPos>
		<getCursorPos public="1" set="method" static="1"><f a=""><c path="CPos"/></f></getCursorPos>
		<getSize public="1" set="method" static="1"><f a=""><c path="CPos"/></f></getSize>
		<setPaletteColor public="1" set="method" static="1"><f a="paln:r:g:b">
	<x path="Int"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></setPaletteColor>
		<scroll public="1" set="method" static="1"><f a="amount">
	<x path="Int"/>
	<x path="Void"/>
</f></scroll>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"term"</e></m>
		</meta>
	</class>
	<class path="OS" params="" file="Externs.hx" module="Externs" extern="1">
		<startTimer public="1" set="method" static="1"><f a="timeout">
	<x path="Float"/>
	<x path="Int"/>
</f></startTimer>
		<pullEvent public="1" set="method" static="1"><f a=""><c path="A"/></f></pullEvent>
		<queueEvent public="1" set="method" static="1"><f a=""><c path="A"/></f></queueEvent>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"os"</e></m>
		</meta>
	</class>
	<class path="KeyEventReturn" params="" file="Externs.hx" module="Externs" extern="1">
		<name public="1"><c path="String"/></name>
		<key public="1"><x path="Int"/></key>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="Peripherals" params="" file="Externs.hx" module="Externs" extern="1">
		<getNames public="1" set="method" static="1"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></f></getNames>
		<getType public="1" set="method" static="1"><f a="peripheral">
	<c path="String"/>
	<c path="String"/>
</f></getType>
		<wrap public="1" set="method" static="1"><f a="name">
	<c path="String"/>
	<d/>
</f></wrap>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"peripheral"</e></m>
		</meta>
	</class>
	<class path="MRWithError" params="" file="Externs.hx" module="Externs" extern="1">
		<out public="1"><d/></out>
		<error public="1"><c path="String"/></error>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="CCFileSystem" params="" file="Externs.hx" module="Externs" extern="1">
		<open public="1" set="method" static="1"><f a="path:mode">
	<c path="String"/>
	<c path="String"/>
	<c path="MRWithError"/>
</f></open>
		<getDrive public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></getDrive>
		<exists public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<isDir public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></isDir>
		<isReadOnly public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></isReadOnly>
		<list public="1" set="method" static="1"><f a="dir">
	<c path="String"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="String"/>
	</c>
</f></list>
		<isDriveRoot public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></isDriveRoot>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"fs"</e></m>
		</meta>
	</class>
	<class path="_Externs.Externs_Fields_" params="" file="Externs.hx" private="1" module="Externs" final="1"/>
	<typedef path="Map" params="K:V" file="/usr/share/haxe/std/Map.hx"><x path="haxe.ds.Map">
	<c path="Map.K"/>
	<c path="Map.V"/>
</x></typedef>
	<typedef path="IMap" params="K:V" file="/usr/share/haxe/std/Map.hx" module="Map">
		<c path="haxe.IMap">
			<c path="IMap.K"/>
			<c path="IMap.V"/>
		</c>
		<meta>
			<m n=":dox"><e>hide</e></m>
			<m n=":deprecated"/>
		</meta>
	</typedef>
	<class path="Math" params="" file="/usr/share/haxe/std/lua/_std/Math.hx">
		<isNaN public="1" set="method" line="49" static="1"><f a="f">
	<x path="Float"/>
	<x path="Bool"/>
</f></isNaN>
		<isFinite public="1" set="method" line="51" static="1"><f a="f">
	<x path="Float"/>
	<x path="Bool"/>
</f></isFinite>
		<max public="1" set="method" line="97" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></max>
		<min public="1" set="method" line="101" static="1"><f a="a:b">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Float"/>
</f></min>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="String" params="" file="/usr/share/haxe/std/lua/_std/String.hx">
		<__oldindex static="1"><f a=":">
	<c path="String"/>
	<c path="String"/>
	<d/>
</f></__oldindex>
		<__index set="method" line="43" static="1">
			<f a="s:k">
				<d/>
				<d/>
				<d/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
		</__index>
		<indexOfEmpty set="method" line="80" static="1"><f a="s:startIndex">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
</f></indexOfEmpty>
		<fromCharCode public="1" get="inline" set="null" line="166" static="1">
			<f a="code">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the String corresponding to the character code `code`.

		If `code` is negative or has another invalid value, the result is
		unspecified.</haxe_doc>
		</fromCharCode>
		<length public="1" set="null">
			<x path="Int"/>
			<haxe_doc>The number of characters in `this` String.</haxe_doc>
		</length>
		<toUpperCase public="1" get="inline" set="null" line="60">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are upper case.</haxe_doc>
		</toUpperCase>
		<toLowerCase public="1" get="inline" set="null" line="63">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a String where all characters of `this` String are lower case.</haxe_doc>
		</toLowerCase>
		<indexOf public="1" set="method" line="65">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the leftmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String starting from `startIndex`.

		If `startIndex` exceeds `this.length`, -1 is returned.

		If `startIndex` is negative, the result is unspecifed.

		Otherwise the search is performed within `this` String. In either case,
		the returned position is relative to the beginning of `this` String.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</indexOf>
		<lastIndexOf public="1" set="method" line="89">
			<f a="str:?startIndex">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the position of the rightmost occurrence of `str` within `this`
		String.

		If `startIndex` is given, the search is performed within the substring
		of `this` String from 0 to `startIndex + str.length`. Otherwise the search
		is performed within `this` String. In either case, the returned position
		is relative to the beginning of `this` String.

		If `startIndex` is negative, the result is unspecifed.

		If `str` cannot be found, -1 is returned.</haxe_doc>
		</lastIndexOf>
		<split public="1" set="method" line="102">
			<f a="delimiter">
				<c path="String"/>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Splits `this` String at each occurrence of `delimiter`.

		If `this` String is the empty String `""`, the result is not consistent
		across targets and may either be `[]` (on Js, Cpp) or `[""]`.

		If `delimiter` is the empty String `""`, `this` String is split into an
		Array of `this.length` elements, where the elements correspond to the
		characters of `this` String.

		If `delimiter` is not found within `this` String, the result is an Array
		with one element, which equals `this` String.

		If `delimiter` is null, the result is unspecified.

		Otherwise, `this` String is split into parts at each occurrence of
		`delimiter`. If `this` String starts (or ends) with `delimiter`, the
		result `Array` contains a leading (or trailing) empty String `""` element.
		Two subsequent delimiters also result in an empty String `""` element.</haxe_doc>
		</split>
		<toString public="1" get="inline" set="null" line="127">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns the String itself.</haxe_doc>
		</toString>
		<substring public="1" set="method" line="131">
			<f a="startIndex:?endIndex">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the part of `this` String from `startIndex` to but not including `endIndex`.

		If `startIndex` or `endIndex` are negative, 0 is used instead.

		If `startIndex` exceeds `endIndex`, they are swapped.

		If the (possibly swapped) `endIndex` is omitted or exceeds
		`this.length`, `this.length` is used instead.

		If the (possibly swapped) `startIndex` exceeds `this.length`, the empty
		String `""` is returned.</haxe_doc>
		</substring>
		<charAt public="1" get="inline" set="null" line="146">
			<f a="index">
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the character at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, the empty String `""`
		is returned.</haxe_doc>
		</charAt>
		<charCodeAt public="1" get="inline" set="null" line="150">
			<f a="index">
				<x path="Int"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<haxe_doc>Returns the character code at position `index` of `this` String.

		If `index` is negative or exceeds `this.length`, `null` is returned.

		To obtain the character code of a single character, `"x".code` can be
		used instead to inline the character code at compile time. Note that
		this only works on String literals of length 1.</haxe_doc>
		</charCodeAt>
		<substr public="1" set="method" line="154">
			<f a="pos:?len">
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns `len` characters of `this` String, starting at position `pos`.

		If `len` is omitted, all characters from position `pos` to the end of
		`this` String are included.

		If `pos` is negative, its value is calculated from the end of `this`
		String by `this.length + pos`. If this yields a negative value, 0 is
		used instead.

		If the calculated position + `len` exceeds `this.length`, the characters
		from that position to the end of `this` String are returned.

		If `len` is negative, the result is unspecified.</haxe_doc>
		</substr>
		<new public="1" get="inline" set="null" line="40">
			<f a="string">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Creates a copy from a given String.</haxe_doc>
		</new>
		<haxe_doc>The basic String class.

	A Haxe String is immutable, it is not possible to modify individual
	characters. No method of this class changes the state of `this` String.

	Strings can be constructed using the String literal syntax `"string value"`.

	String can be concatenated by using the `+` operator. If an operand is not a
	String, it is passed through `Std.string()` first.

	@see https://haxe.org/manual/std-String.html</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Std" params="" file="/usr/share/haxe/std/lua/_std/Std.hx">
		<string public="1" set="method" line="47" static="1">
			<f a="s">
				<d/>
				<c path="String"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":keep"/>
			</meta>
			<haxe_doc>Converts any value to a String.

		If `s` is of `String`, `Int`, `Float` or `Bool`, its value is returned.

		If `s` is an instance of a class and that class or one of its parent classes has
		a `toString` method, that method is called. If no such method is present, the result
		is unspecified.

		If `s` is an enum constructor without argument, the constructor's name is returned. If
		arguments exists, the constructor's name followed by the String representations of
		the arguments is returned.

		If `s` is a structure, the field names along with their values are returned. The field order
		and the operator separating field names and values are unspecified.

		If s is null, "null" is returned.</haxe_doc>
		</string>
		<int public="1" set="method" line="51" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts a `Float` to an `Int`, rounded towards 0.

		If `x` is outside of the signed Int32 range, or is `NaN`, `NEGATIVE_INFINITY` or `POSITIVE_INFINITY`, the result is unspecified.</haxe_doc>
		</int>
		<parseInt public="1" set="method" line="58" static="1">
			<f a="x">
				<c path="String"/>
				<x path="Null"><x path="Int"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Converts a `String` to an `Int`.

		Leading whitespaces are ignored.

		`x` may optionally start with a + or - to denote a postive or negative value respectively.

		If the optional sign is followed 0x or 0X, hexadecimal notation is recognized where the following
		digits may contain 0-9 and A-F. Both the prefix and digits are case insensitive.

		Otherwise `x` is read as decimal number with 0-9 being allowed characters. Octal and binary
		notations are not supported.

		Parsing continues until an invalid character is detected, in which case the result up to
		that point is returned. Scientific notation is not supported. That is `Std.parseInt('10e2')` produces `10`.

		If `x` is `null`, the result is `null`.
		If `x` cannot be parsed as integer or is empty, the result is `null`.

		If `x` starts with a hexadecimal prefix which is not followed by at least one valid hexadecimal
		digit, the result is unspecified.</haxe_doc>
		</parseInt>
		<haxe_doc>The Std class provides standard methods for manipulating basic types.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":keepInit"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="Void" params="" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Void"/></this>
		<haxe_doc>The standard `Void` type. Only `null` values can be of the type `Void`.

	@see https://haxe.org/manual/types-void.html</haxe_doc>
		<meta><m n=":coreType"/></meta>
	</abstract>
	<abstract path="Float" params="" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Float"/></this>
		<haxe_doc><![CDATA[The standard `Float` type, this is a double-precision IEEE 64bit float.

	On static targets, `null` cannot be assigned to Float. If this is necessary,
	`Null<Float>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseFloat` converts a `String` to a `Float`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Int" params="" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Int"/></this>
		<to><icast><x path="Float"/></icast></to>
		<haxe_doc><![CDATA[The standard `Int` type. Its precision depends on the platform.

	On static targets, `null` cannot be assigned to `Int`. If this is necessary,
	`Null<Int>` can be used instead.

	`Std.int` converts a `Float` to an `Int`, rounded towards 0.
	`Std.parseInt` converts a `String` to an `Int`.

	@see https://haxe.org/manual/types-basic-types.html
	@see https://haxe.org/manual/std-math-integer-math.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Null" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<from><icast><c path="Null.T"/></icast></from>
		<this><x path="Null"><c path="Null.T"/></x></this>
		<to><icast><c path="Null.T"/></icast></to>
		<haxe_doc><![CDATA[`Null<T>` is a wrapper that can be used to make the basic types `Int`,
	`Float` and `Bool` nullable on static targets.

	If null safety is enabled, only types wrapped in `Null<T>` are nullable.

	Otherwise, it has no effect on non-basic-types, but it can be useful as a way to document
	that `null` is an acceptable value for a method argument, return value or variable.

	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":forward"/>
			<m n=":coreType"/>
		</meta>
	</abstract>
	<abstract path="Bool" params="" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Bool"/></this>
		<haxe_doc><![CDATA[The standard Boolean type, which can either be `true` or `false`.

	On static targets, `null` cannot be assigned to `Bool`. If this is necessary,
	`Null<Bool>` can be used instead.

	@see https://haxe.org/manual/types-bool.html
	@see https://haxe.org/manual/types-nullability.html]]></haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":notNull"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<abstract path="Dynamic" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<this><x path="Dynamic"><c path="Dynamic.T"/></x></this>
		<haxe_doc>`Dynamic` is a special type which is compatible with all other types.

	Use of `Dynamic` should be minimized as it prevents several compiler
	checks and optimizations. See `Any` type for a safer alternative for
	representing values of any type.

	@see https://haxe.org/manual/types-dynamic.html</haxe_doc>
		<meta>
			<m n=":valueUsed"/>
			<m n=":coreType"/>
			<m n=":runtimeValue"/>
		</meta>
	</abstract>
	<typedef path="Iterator" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<a>
			<next set="method">
				<f a=""><c path="Iterator.T"/></f>
				<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
			</next>
			<hasNext set="method">
				<f a=""><x path="Bool"/></f>
				<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
			</hasNext>
		</a>
		<haxe_doc>An `Iterator` is a structure that permits iteration over elements of type `T`.

	Any class with matching `hasNext()` and `next()` fields is considered an `Iterator`
	and can then be used e.g. in `for`-loops. This makes it easy to implement
	custom iterators.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="Iterable" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<a><iterator set="method"><f a=""><t path="Iterator"><c path="Iterable.T"/></t></f></iterator></a>
		<haxe_doc>An `Iterable` is a data structure which has an `iterator()` method.
	See `Lambda` for generic functions on iterable structures.

	@see https://haxe.org/manual/lf-iterators.html</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterator" params="K:V" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<t path="Iterator"><a>
	<value><c path="KeyValueIterator.V"/></value>
	<key><c path="KeyValueIterator.K"/></key>
</a></t>
		<haxe_doc>A `KeyValueIterator` is an `Iterator` that has a key and a value.</haxe_doc>
	</typedef>
	<typedef path="KeyValueIterable" params="K:V" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes">
		<a><keyValueIterator set="method"><f a=""><t path="KeyValueIterator">
	<c path="KeyValueIterable.K"/>
	<c path="KeyValueIterable.V"/>
</t></f></keyValueIterator></a>
		<haxe_doc>A `KeyValueIterable` is a data structure which has a `keyValueIterator()`
	method to iterate over key-value-pairs.</haxe_doc>
	</typedef>
	<class path="ArrayAccess" params="T" file="/usr/share/haxe/std/StdTypes.hx" module="StdTypes" extern="1" interface="1"><haxe_doc>`ArrayAccess` is used to indicate a class that can be accessed using brackets.
	The type parameter represents the type of the elements stored.

	This interface should be used for externs only. Haxe does not support custom
	array access on classes. However, array access can be implemented for
	abstract types.

	@see https://haxe.org/manual/types-abstract-array-access.html</haxe_doc></class>
	<typedef path="_String.BaseString" params="" file="/usr/share/haxe/std/lua/_std/String.hx" private="1" module="String"><c path="lua.NativeStringTools"/></typedef>
	<class path="StringBuf" params="" file="/usr/share/haxe/std/lua/_std/StringBuf.hx">
		<b><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></b>
		<length public="1" get="null" set="null"><x path="Int"/></length>
		<new public="1" get="inline" set="null" line="30"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="StringTools" params="" file="/usr/share/haxe/std/StringTools.hx">
		<rpad public="1" set="method" line="394" static="1">
			<f a="s:c:l">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Appends `c` to `s` until `s.length` is at least `l`.

		If `c` is the empty String `""` or if `l` does not exceed `s.length`,
		`s` is returned unchanged.

		If `c.length` is 1, the resulting String length is exactly `l`.

		Otherwise the length may exceed `l`.

		If `c` is null, the result is unspecified.</haxe_doc>
		</rpad>
		<replace public="1" set="method" line="416" static="1">
			<f a="s:sub:by">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Replace all occurrences of the String `sub` in the String `s` by the
		String `by`.

		If `sub` is the empty String `""`, `by` is inserted after each character
		of `s` except the last one. If `by` is also the empty String `""`, `s`
		remains unchanged.

		If `sub` or `by` are null, the result is unspecified.</haxe_doc>
		</replace>
		<haxe_doc>This class provides advanced methods on Strings. It is ideally used with
	`using StringTools` and then acts as an [extension](https://haxe.org/manual/lf-static-extension.html)
	to the `String` class.

	If the first argument to any of the methods is null, the result is
	unspecified.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="Sys" params="" file="/usr/share/haxe/std/lua/_std/Sys.hx">
		<sleep public="1" set="method" line="113" static="1">
			<f a="seconds">
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Suspends execution for the given length of time (in seconds).</haxe_doc>
		</sleep>
		<haxe_doc>This class provides access to various base functions of system platforms.
	Look in the `sys` package for more system APIs.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<class path="Type" params="" file="/usr/share/haxe/std/lua/_std/Type.hx">
		<getClass public="1" params="T" set="method" line="40" static="1">
			<f a="o">
				<c path="getClass.T"/>
				<x path="Class"><c path="getClass.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Returns the class of `o`, if `o` is a class instance.

		If `o` is null or of a different type, null is returned.

		In general, type parameter information cannot be obtained at runtime.</haxe_doc>
		</getClass>
		<haxe_doc>The Haxe Reflection API allows retrieval of type information at runtime.

	This class complements the more lightweight Reflect class, with a focus on
	class and enum instances.

	@see https://haxe.org/manual/types.html
	@see https://haxe.org/manual/std-reflection.html</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="XmlType" params="" file="/usr/share/haxe/std/Xml.hx" module="Xml">
		<this><x path="Int"/></this>
		<haxe_doc>Xml node types.

	@see https://haxe.org/manual/std-Xml.html</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="_Xml.XmlType_Impl_" params="" file="/usr/share/haxe/std/Xml.hx" private="1" module="Xml" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="globals.Output" params="" file="src/globals/Globals.hx" module="globals.Globals" abstract="1">
		<write abstract="1" public="1" set="method"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></write>
		<print public="1" set="method" line="76"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></print>
		<clear abstract="1" public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<setFGColor abstract="1" public="1" set="method"><f a="col">
	<c path="globals.Color"/>
	<x path="Void"/>
</f></setFGColor>
		<setBGColor abstract="1" public="1" set="method"><f a="col">
	<c path="globals.Color"/>
	<x path="Void"/>
</f></setBGColor>
		<apalette expr="[new RGBColor(236, 239, 244), new RGBColor(0, 0, 0), new RGBColor(180, 142, 173), new RGBColor(0, 0, 0), new RGBColor(235, 203, 139), new RGBColor(163, 190, 140), new RGBColor(0, 0, 0), new RGBColor(173, 179, 187), new RGBColor(216, 222, 187), new RGBColor(136, 192, 208), new RGBColor(0, 0, 0), new RGBColor(129, 161, 193), new RGBColor(0, 0, 0), new RGBColor(163, 190, 140), new RGBColor(191, 97, 106), new RGBColor(59, 66, 82)]">
			<c path="Array"><c path="globals.RGBColor"/></c>
			<meta><m n=":value"><e>[new RGBColor(236, 239, 244), new RGBColor(0, 0, 0), new RGBColor(180, 142, 173), new RGBColor(0, 0, 0), new RGBColor(235, 203, 139), new RGBColor(163, 190, 140), new RGBColor(0, 0, 0), new RGBColor(173, 179, 187), new RGBColor(216, 222, 187), new RGBColor(136, 192, 208), new RGBColor(0, 0, 0), new RGBColor(129, 161, 193), new RGBColor(0, 0, 0), new RGBColor(163, 190, 140), new RGBColor(191, 97, 106), new RGBColor(59, 66, 82)]</e></m></meta>
		</apalette>
		<palette public="1" get="accessor" set="accessor"><c path="Array"><c path="globals.RGBColor"/></c></palette>
		<size public="1" get="accessor" set="accessor"><c path="globals.Vector2i"/></size>
		<set_palette abstract="1" public="1" set="method"><f a="newc">
	<c path="Array"><c path="globals.RGBColor"/></c>
	<c path="Array"><c path="globals.RGBColor"/></c>
</f></set_palette>
		<get_palette public="1" set="method" line="109"><f a=""><c path="Array"><c path="globals.RGBColor"/></c></f></get_palette>
		<getCursorPos abstract="1" public="1" set="method"><f a=""><c path="globals.Vector2i"/></f></getCursorPos>
		<setCursorPos abstract="1" public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setCursorPos>
		<setCursorPosRelative abstract="1" public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setCursorPosRelative>
		<get_size abstract="1" public="1" set="method"><f a=""><c path="globals.Vector2i"/></f></get_size>
		<set_size public="1" set="method" line="116"><f a="s">
	<c path="globals.Vector2i"/>
	<c path="globals.Vector2i"/>
</f></set_size>
		<new public="1" set="method" line="74">
			<f a=""><x path="Void"/></f>
			<meta><m n=":compilerGenerated"/></meta>
		</new>
	</class>
	<class path="drivers.terminal.TerminalBackend" params="" file="src/drivers/terminal/CraftOS.hx" module="drivers.terminal.CraftOS">
		<extends path="globals.Output"/>
		<write public="1" set="method" line="5" override="1"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></write>
		<clear public="1" set="method" line="16" override="1"><f a=""><x path="Void"/></f></clear>
		<setFGColor public="1" set="method" line="19" override="1"><f a="col">
	<c path="globals.Color"/>
	<x path="Void"/>
</f></setFGColor>
		<setBGColor public="1" set="method" line="22" override="1"><f a="col">
	<c path="globals.Color"/>
	<x path="Void"/>
</f></setBGColor>
		<setCursorPos public="1" set="method" line="25" override="1"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setCursorPos>
		<getCursorPos public="1" set="method" line="28" override="1"><f a=""><c path="globals.Vector2i"/></f></getCursorPos>
		<setCursorPosRelative public="1" set="method" line="31" override="1"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setCursorPosRelative>
		<get_size public="1" set="method" line="41" override="1"><f a=""><c path="globals.Vector2i"/></f></get_size>
		<set_palette public="1" set="method" line="44" override="1"><f a="newc">
	<c path="Array"><c path="globals.RGBColor"/></c>
	<c path="Array"><c path="globals.RGBColor"/></c>
</f></set_palette>
		<new public="1" set="method" line="55"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="drivers.terminal.Terminal" params="" file="src/drivers/terminal/Auto.hx" module="drivers.terminal.Auto">
		<extends path="drivers.terminal.TerminalBackend"/>
		<new public="1" set="method" line="9"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="globals.FilePath" params="" file="src/globals/FilePath.hx">
		<path public="1" expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</path>
		<add public="1" set="method" line="21">
			<f a="s">
				<c path="String"/>
				<c path="globals.FilePath"/>
			</f>
			<meta><m n=":op"><e>A / B</e></m></meta>
		</add>
		<new public="1" set="method" line="5"><f a="sPath">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="globals.Vector2i" params="" file="src/globals/Globals.hx" module="globals.Globals">
		<fromCPos public="1" set="method" line="13" static="1"><f a="a">
	<c path="CPos"/>
	<c path="globals.Vector2i"/>
</f></fromCPos>
		<x public="1"><x path="Int"/></x>
		<y public="1"><x path="Int"/></y>
		<new public="1" set="method" line="8"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="globals.Vector2f" params="" file="src/globals/Globals.hx" module="globals.Globals">
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<new public="1" set="method" line="23"><f a="x:y">
	<x path="Float"/>
	<x path="Float"/>
	<x path="Void"/>
</f></new>
	</class>
	<class path="globals.Globals" params="" file="src/globals/Globals.hx"><version public="1" expr="&quot;0.01x&quot;" line="30" static="1">
	<c path="String"/>
	<meta><m n=":value"><e>"0.01x"</e></m></meta>
</version></class>
	<class path="globals.Color" params="" file="src/globals/Globals.hx" module="globals.Globals">
		<palNumber public="1"><x path="Int"/></palNumber>
		<bitASC public="1"><x path="Int"/></bitASC>
		<new public="1" set="method" line="38"><f a="palNumber:bitASC">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="globals.RGBColor" params="" file="src/globals/Globals.hx" module="globals.Globals">
		<red public="1"><x path="Int"/></red>
		<green public="1"><x path="Int"/></green>
		<blue public="1"><x path="Int"/></blue>
		<new public="1" set="method" line="48"><f a="r:g:b">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="globals.Colors" params="" file="src/globals/Globals.hx" module="globals.Globals">
		<white public="1" expr="new Color(0, 0x1)" line="56" static="1">
			<c path="globals.Color"/>
			<meta><m n=":value"><e>new Color(0, 0x1)</e></m></meta>
		</white>
		<orange public="1" expr="new Color(1, 0x2)" line="57" static="1">
			<c path="globals.Color"/>
			<meta><m n=":value"><e>new Color(1, 0x2)</e></m></meta>
		</orange>
		<magenta public="1" expr="new Color(2, 0x4)" line="58" static="1">
			<c path="globals.Color"/>
			<meta><m n=":value"><e>new Color(2, 0x4)</e></m></meta>
		</magenta>
		<lightBlue public="1" expr="new Color(3, 0x8)" line="59" static="1">
			<c path="globals.Color"/>
			<meta><m n=":value"><e>new Color(3, 0x8)</e></m></meta>
		</lightBlue>
		<yellow public="1" expr="new Color(4, 0x10)" line="60" static="1">
			<c path="globals.Color"/>
			<meta><m n=":value"><e>new Color(4, 0x10)</e></m></meta>
		</yellow>
		<lime public="1" expr="new Color(5, 0x20)" line="61" static="1">
			<c path="globals.Color"/>
			<meta><m n=":value"><e>new Color(5, 0x20)</e></m></meta>
		</lime>
		<pink public="1" expr="new Color(6, 0x40)" line="62" static="1">
			<c path="globals.Color"/>
			<meta><m n=":value"><e>new Color(6, 0x40)</e></m></meta>
		</pink>
		<gray public="1" expr="new Color(7, 0x80)" line="63" static="1">
			<c path="globals.Color"/>
			<meta><m n=":value"><e>new Color(7, 0x80)</e></m></meta>
		</gray>
		<lightGray public="1" expr="new Color(8, 0x100)" line="64" static="1">
			<c path="globals.Color"/>
			<meta><m n=":value"><e>new Color(8, 0x100)</e></m></meta>
		</lightGray>
		<cyan public="1" expr="new Color(9, 0x200)" line="65" static="1">
			<c path="globals.Color"/>
			<meta><m n=":value"><e>new Color(9, 0x200)</e></m></meta>
		</cyan>
		<purple public="1" expr="new Color(10, 0x400)" line="66" static="1">
			<c path="globals.Color"/>
			<meta><m n=":value"><e>new Color(10, 0x400)</e></m></meta>
		</purple>
		<blue public="1" expr="new Color(11, 0x800)" line="67" static="1">
			<c path="globals.Color"/>
			<meta><m n=":value"><e>new Color(11, 0x800)</e></m></meta>
		</blue>
		<brown public="1" expr="new Color(12, 0x1000)" line="68" static="1">
			<c path="globals.Color"/>
			<meta><m n=":value"><e>new Color(12, 0x1000)</e></m></meta>
		</brown>
		<green public="1" expr="new Color(13, 0x2000)" line="69" static="1">
			<c path="globals.Color"/>
			<meta><m n=":value"><e>new Color(13, 0x2000)</e></m></meta>
		</green>
		<red public="1" expr="new Color(14, 0x4000)" line="70" static="1">
			<c path="globals.Color"/>
			<meta><m n=":value"><e>new Color(14, 0x4000)</e></m></meta>
		</red>
		<black public="1" expr="new Color(15, 0x8000)" line="71" static="1">
			<c path="globals.Color"/>
			<meta><m n=":value"><e>new Color(15, 0x8000)</e></m></meta>
		</black>
	</class>
	<class path="globals.Input" params="" file="src/globals/Globals.hx" module="globals.Globals" abstract="1">
		<readInt abstract="1" public="1" set="method">
			<f a="?timeout" v="-1">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ timeout : -1 }</e></m></meta>
		</readInt>
		<readChar abstract="1" public="1" set="method">
			<f a="?timeout" v="-1">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ timeout : -1 }</e></m></meta>
		</readChar>
		<readChars abstract="1" public="1" set="method">
			<f a="num:?timeout:?echo:?echoOutput:?showCursor" v=":-1:&quot;/&quot;::false">
				<x path="Int"/>
				<x path="Float"/>
				<c path="String"/>
				<c path="globals.Output"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ showCursor : false, echo : "/", timeout : -1 }</e></m></meta>
		</readChars>
		<readLine abstract="1" public="1" set="method">
			<f a="?timeout:?echo:?echoOutput:?showCursor" v="-1:&quot;/&quot;::false">
				<x path="Float"/>
				<c path="String"/>
				<c path="globals.Output"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ showCursor : false, echo : "/", timeout : -1 }</e></m></meta>
		</readLine>
	</class>
	<enum path="haxe.StackItem" params="" file="/usr/share/haxe/std/haxe/CallStack.hx" module="haxe.CallStack">
		<CFunction/>
		<Module a="m"><c path="String"/></Module>
		<FilePos a="s:file:line:?column">
			<x path="Null"><e path="haxe.StackItem"/></x>
			<c path="String"/>
			<x path="Int"/>
			<x path="Int"/>
		</FilePos>
		<Method a="classname:method">
			<x path="Null"><c path="String"/></x>
			<c path="String"/>
		</Method>
		<LocalFunction a="?v"><x path="Int"/></LocalFunction>
		<haxe_doc>Elements return by `CallStack` methods.</haxe_doc>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<abstract path="haxe.CallStack" params="" file="/usr/share/haxe/std/haxe/CallStack.hx">
		<from><icast><c path="Array"><e path="haxe.StackItem"/></c></icast></from>
		<this><c path="Array"><e path="haxe.StackItem"/></c></this>
		<haxe_doc>Get information about the call stack.</haxe_doc>
		<meta>
			<m n=":allow"><e>haxe.Exception</e></m>
			<m n=":using"><e>haxe.CallStack</e></m>
		</meta>
		<impl><class path="haxe._CallStack.CallStack_Impl_" params="" file="/usr/share/haxe/std/haxe/CallStack.hx" private="1" module="haxe.CallStack" final="1">
	<toString public="1" set="method" line="71" static="1">
		<f a="stack">
			<x path="haxe.CallStack"/>
			<c path="String"/>
		</f>
		<haxe_doc>Returns a representation of the stack as a printable string.</haxe_doc>
	</toString>
	<subtract public="1" set="method" line="84" static="1">
		<f a="this:stack">
			<c path="Array"><e path="haxe.StackItem"/></c>
			<x path="haxe.CallStack"/>
			<x path="haxe.CallStack"/>
		</f>
		<haxe_doc>Returns a range of entries of current stack from the beginning to the the
		common part of this and `stack`.</haxe_doc>
	</subtract>
	<equalItems set="method" line="119" static="1"><f a="item1:item2">
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Bool"/>
</f></equalItems>
	<itemToString set="method" line="155" static="1"><f a="b:s">
	<c path="StringBuf"/>
	<e path="haxe.StackItem"/>
	<x path="Void"/>
</f></itemToString>
	<meta>
		<m n=":keep"/>
		<m n=":directlyUsed"/>
		<m n=":using"><e>haxe.CallStack</e></m>
		<m n=":allow"><e>haxe.Exception</e></m>
	</meta>
</class></impl>
	</abstract>
	<class path="haxe._CallStack.CallStack_Impl_" params="" file="/usr/share/haxe/std/haxe/CallStack.hx" private="1" module="haxe.CallStack" final="1">
		<toString public="1" set="method" line="71" static="1">
			<f a="stack">
				<x path="haxe.CallStack"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a representation of the stack as a printable string.</haxe_doc>
		</toString>
		<subtract public="1" set="method" line="84" static="1">
			<f a="this:stack">
				<c path="Array"><e path="haxe.StackItem"/></c>
				<x path="haxe.CallStack"/>
				<x path="haxe.CallStack"/>
			</f>
			<haxe_doc>Returns a range of entries of current stack from the beginning to the the
		common part of this and `stack`.</haxe_doc>
		</subtract>
		<equalItems set="method" line="119" static="1"><f a="item1:item2">
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Null"><e path="haxe.StackItem"/></x>
	<x path="Bool"/>
</f></equalItems>
		<itemToString set="method" line="155" static="1"><f a="b:s">
	<c path="StringBuf"/>
	<e path="haxe.StackItem"/>
	<x path="Void"/>
</f></itemToString>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":using"><e>haxe.CallStack</e></m>
			<m n=":allow"><e>haxe.Exception</e></m>
		</meta>
	</class>
	<abstract path="haxe.Function" params="" file="/usr/share/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with any function type.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="haxe._Constraints.Function_Impl_" params="" file="/usr/share/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.FlatEnum" params="" file="/usr/share/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with an enum instance if all constructors of the enum
	require no arguments.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.FlatEnum_Impl_" params="" file="/usr/share/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.NotVoid" params="" file="/usr/share/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc>This type unifies with anything but `Void`.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.</haxe_doc>
		<impl><class path="haxe._Constraints.NotVoid_Impl_" params="" file="/usr/share/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Constructible" params="T" file="/usr/share/haxe/std/haxe/Constraints.hx" module="haxe.Constraints">
		<this><d/></this>
		<haxe_doc><![CDATA[This type unifies with any instance of classes that have a constructor
	which

	  * is `public` and
	  * unifies with the type used for type parameter `T`.

	If a type parameter `A` is assigned to a type parameter `B` which is constrained
	to `Constructible<T>`, A must be explicitly constrained to
	`Constructible<T>` as well.

	It is intended to be used as a type parameter constraint. If used as a real
	type, the underlying type will be `Dynamic`.]]></haxe_doc>
		<impl><class path="haxe._Constraints.Constructible_Impl_" params="" file="/usr/share/haxe/std/haxe/Constraints.hx" private="1" module="haxe.Constraints" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.IMap" params="K:V" file="/usr/share/haxe/std/haxe/Constraints.hx" module="haxe.Constraints" interface="1">
		<get public="1" set="method"><f a="k">
	<c path="haxe.IMap.K"/>
	<x path="Null"><c path="haxe.IMap.V"/></x>
</f></get>
		<keys public="1" set="method"><f a=""><t path="Iterator"><c path="haxe.IMap.K"/></t></f></keys>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.EnumTools" params="" file="/usr/share/haxe/std/haxe/EnumTools.hx" extern="1">
		<getName public="1" params="T" get="inline" set="null" line="52" static="1">
			<f a="e">
				<x path="Enum"><c path="getName.T"/></x>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the name of enum `e`, including its path.

		If `e` is inside a package, the package structure is returned dot-
		separated, with another dot separating the enum name:

			pack1.pack2.(...).packN.EnumName

		If `e` is a sub-type of a Haxe module, that module is not part of the
		package structure.

		If `e` has no package, the enum name is returned.

		If `e` is `null`, the result is unspecified.

		The enum name does not include any type parameters.</haxe_doc>
		</getName>
		<createByName public="1" params="T" get="inline" set="null" line="65" static="1">
			<f a="e:constr:?params">
				<x path="Enum"><c path="createByName.T"/></x>
				<c path="String"/>
				<c path="Array"><d/></c>
				<c path="createByName.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor `constr` with
		arguments `params`.

		If `e` or `constr` is `null`, or if enum `e` has no constructor named
		`constr`, or if the number of elements in `params` does not match the
		expected number of constructor arguments, or if any argument has an
		invalid type, the result is unspecified.</haxe_doc>
		</createByName>
		<createByIndex public="1" params="T" get="inline" set="null" line="81" static="1">
			<f a="e:index:?params">
				<x path="Enum"><c path="createByIndex.T"/></x>
				<x path="Int"/>
				<c path="Array"><d/></c>
				<c path="createByIndex.T"/>
			</f>
			<haxe_doc>Creates an instance of enum `e` by calling its constructor number
		`index` with arguments `params`.

		The constructor indices are preserved from Haxe syntax, so the first
		declared is index 0, the next index 1 etc.

		If `e` or `index` is `null`, or if enum `e` has no constructor
		corresponding to index `index`, or if the number of elements in `params`
		does not match the expected number of constructor arguments, or if any
		argument has an invalid type, the result is unspecified.</haxe_doc>
		</createByIndex>
		<createAll public="1" params="T" get="inline" set="null" line="98" static="1">
			<f a="e">
				<x path="Enum"><c path="createAll.T"/></x>
				<c path="Array"><c path="createAll.T"/></c>
			</f>
			<haxe_doc>Returns a list of all constructors of enum `e` that require no
		arguments.

		This may return the empty Array `[]` if all constructors of `e` require
		arguments.

		Otherwise an instance of `e` constructed through each of its non-
		argument constructors is returned, in the order of the constructor
		declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</createAll>
		<getConstructors public="1" params="T" get="inline" set="null" line="110" static="1">
			<f a="e">
				<x path="Enum"><c path="getConstructors.T"/></x>
				<c path="Array"><c path="String"/></c>
			</f>
			<haxe_doc>Returns a list of the names of all constructors of enum `e`.

		The order of the constructor names in the returned Array is preserved
		from the original syntax.

		If `c` is `null`, the result is unspecified.</haxe_doc>
		</getConstructors>
		<haxe_doc>This class provides advanced methods on enums. It is ideally used with
	`using EnumTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `enum` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.EnumValueTools" params="" file="/usr/share/haxe/std/haxe/EnumTools.hx" module="haxe.EnumTools" extern="1">
		<equals public="1" params="T" get="inline" set="null" line="138" static="1">
			<f a="a:b">
				<c path="equals.T"/>
				<c path="equals.T"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Recursively compares two enum instances `a` and `b` by value.

		Unlike `a == b`, this function performs a deep equality check on the
		arguments of the constructors (if there are any).

		If `a` or `b` are `null`, the result is unspecified.</haxe_doc>
		</equals>
		<getName public="1" get="inline" set="null" line="149" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the constructor name of enum instance `e`.

		The result String does not contain any constructor arguments.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getName>
		<getParameters public="1" get="inline" set="null" line="163" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<c path="Array"><d/></c>
			</f>
			<haxe_doc>Returns a list of the constructor arguments of enum instance `e`.

		If `e` has no arguments, the result is `[]`.

		Otherwise the result are the values that were used as arguments to `e`,
		in the order of their declaration.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getParameters>
		<getIndex public="1" get="inline" set="null" line="175" static="1">
			<f a="e">
				<x path="EnumValue"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the index of enum instance `e`.

		This corresponds to the original syntactic position of `e`. The index of
		the first declared constructor is 0, the next one is 1 etc.

		If `e` is `null`, the result is unspecified.</haxe_doc>
		</getIndex>
		<haxe_doc>This class provides advanced methods on enum values. It is ideally used with
	`using EnumValueTools` and then acts as an
	  [extension](https://haxe.org/manual/lf-static-extension.html) to the
	  `EnumValue` types.

	If the first argument to any of the methods is `null`, the result is
	unspecified.</haxe_doc>
	</class>
	<class path="haxe.Exception" params="" file="/usr/share/haxe/std/lua/_std/haxe/Exception.hx">
		<caught set="method" line="17" static="1"><f a="value">
	<x path="Any"/>
	<c path="haxe.Exception"/>
</f></caught>
		<thrown set="method" line="25" static="1"><f a="value">
	<x path="Any"/>
	<x path="Any"/>
</f></thrown>
		<message public="1" get="accessor" set="null">
			<c path="String"/>
			<haxe_doc>Exception message.</haxe_doc>
		</message>
		<stack public="1" get="accessor" set="null">
			<x path="haxe.CallStack"/>
			<haxe_doc>The call stack at the moment of the exception creation.</haxe_doc>
		</stack>
		<previous public="1" get="accessor" set="null">
			<x path="Null"><c path="haxe.Exception"/></x>
			<haxe_doc>Contains an exception, which was passed to `previous` constructor argument.</haxe_doc>
		</previous>
		<native public="1" get="accessor" set="null">
			<x path="Any"/>
			<haxe_doc>Native exception, which caused this exception.</haxe_doc>
		</native>
		<__exceptionMessage>
			<c path="String"/>
			<meta><m n=":noCompletion"/></meta>
		</__exceptionMessage>
		<__exceptionStack>
			<x path="Null"><x path="haxe.CallStack"/></x>
			<meta><m n=":noCompletion"/></meta>
		</__exceptionStack>
		<__nativeStack>
			<c path="Array"><c path="String"/></c>
			<meta><m n=":noCompletion"/></meta>
		</__nativeStack>
		<__skipStack expr="0">
			<x path="Int"/>
			<meta>
				<m n=":value"><e>0</e></m>
				<m n=":noCompletion"/>
				<m n=":ifFeature"><e>"haxe.Exception.get_stack"</e></m>
			</meta>
		</__skipStack>
		<__nativeException>
			<x path="Any"/>
			<meta><m n=":noCompletion"/></meta>
		</__nativeException>
		<__previousException>
			<x path="Null"><c path="haxe.Exception"/></x>
			<meta><m n=":noCompletion"/></meta>
		</__previousException>
		<unwrap set="method" line="48"><f a=""><x path="Any"/></f></unwrap>
		<toString public="1" set="method" line="53">
			<f a=""><c path="String"/></f>
			<meta><m n=":keep"/></meta>
			<haxe_doc>Returns exception message.</haxe_doc>
		</toString>
		<details public="1" set="method" line="57">
			<f a=""><c path="String"/></f>
			<haxe_doc>Detailed exception description.

		Includes message, stack and the chain of previous exceptions (if set).</haxe_doc>
		</details>
		<__shiftStack get="inline" set="null" line="63">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":noCompletion"/>
				<m n=":ifFeature"><e>"haxe.Exception.get_stack"</e></m>
			</meta>
		</__shiftStack>
		<get_message set="method" line="67"><f a=""><c path="String"/></f></get_message>
		<get_previous set="method" line="71"><f a=""><x path="Null"><c path="haxe.Exception"/></x></f></get_previous>
		<get_native final="1" set="method" line="75"><f a=""><x path="Any"/></f></get_native>
		<get_stack set="method" line="79"><f a=""><x path="haxe.CallStack"/></f></get_stack>
		<new public="1" set="method" line="35">
			<f a="message:?previous:?native">
				<c path="String"/>
				<c path="haxe.Exception"/>
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new Exception instance.

		The `previous` argument could be used for exception chaining.

		The `native` argument is for internal usage only.
		There is no need to provide `native` argument manually and no need to keep it
		upon extending `haxe.Exception` unless you know what you're doing.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[Base class for exceptions.

	If this class (or derivatives) is used to catch an exception, then
	`haxe.CallStack.exceptionStack()` will not return a stack for the exception
	caught. Use `haxe.Exception.stack` property instead:
	```haxe
	try {
		throwSomething();
	} catch(e:Exception) {
		trace(e.stack);
	}
	```

	Custom exceptions should extend this class:
	```haxe
	class MyException extends haxe.Exception {}
	//...
	throw new MyException('terrible exception');
	```

	`haxe.Exception` is also a wildcard type to catch any exception:
	```haxe
	try {
		throw 'Catch me!';
	} catch(e:haxe.Exception) {
		trace(e.message); // Output: Catch me!
	}
	```

	To rethrow an exception just throw it again.
	Haxe will try to rethrow an original native exception whenever possible.
	```haxe
	try {
		var a:Array<Int> = null;
		a.push(1); // generates target-specific null-pointer exception
	} catch(e:haxe.Exception) {
		throw e; // rethrows native exception instead of haxe.Exception
	}
	```]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":coreApi"/>
		</meta>
	</class>
	<abstract path="haxe.Int32" params="" file="/usr/share/haxe/std/haxe/Int32.hx">
		<from><icast><x path="Int"/></icast></from>
		<this><x path="Int"/></this>
		<to>
			<icast><x path="Int"/></icast>
			<icast field="toFloat"><x path="Float"/></icast>
		</to>
		<haxe_doc>Int32 provides a 32-bit integer with consistent overflow behavior across
	all platforms.</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe._Int32.Int32_Impl_" params="" file="/usr/share/haxe/std/haxe/Int32.hx" private="1" module="haxe.Int32" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.Int64" params="" file="/usr/share/haxe/std/haxe/Int64.hx">
		<from>
			<icast><t path="haxe._Int64.__Int64"/></icast>
			<icast field="ofInt"><x path="Int"/></icast>
		</from>
		<this><t path="haxe._Int64.__Int64"/></this>
		<to><icast><t path="haxe._Int64.__Int64"/></icast></to>
		<haxe_doc>A cross-platform signed 64-bit integer.
	Int64 instances can be created from two 32-bit words using `Int64.make()`.</haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe._Int64.Int64_Impl_" params="" file="/usr/share/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="haxe._Int64.__Int64" params="" file="/usr/share/haxe/std/haxe/Int64.hx" private="1" module="haxe.Int64">
		<c path="haxe._Int64.___Int64"/>
		<haxe_doc>This typedef will fool `@:coreApi` into thinking that we are using
	the same underlying type, even though it might be different on
	specific platforms.</haxe_doc>
	</typedef>
	<class path="haxe.NativeStackTrace" params="" file="/usr/share/haxe/std/lua/_std/haxe/NativeStackTrace.hx">
		<saveStack public="1" get="inline" set="null" line="12" static="1">
			<f a="exception">
				<x path="Any"/>
				<x path="Void"/>
			</f>
			<meta><m n=":ifFeature"><e>"haxe.NativeStackTrace.exceptionStack"</e></m></meta>
		</saveStack>
		<callStack public="1" set="method" line="15" static="1"><f a=""><c path="Array"><c path="String"/></c></f></callStack>
		<exceptionStack public="1" set="method" line="22" static="1"><f a=""><c path="Array"><c path="String"/></c></f></exceptionStack>
		<toHaxe public="1" set="method" line="26" static="1">
			<f a="native:?skip" v=":0">
				<c path="Array"><c path="String"/></c>
				<x path="Int"/>
				<c path="Array"><e path="haxe.StackItem"/></c>
			</f>
			<meta><m n=":value"><e>{ skip : 0 }</e></m></meta>
		</toHaxe>
		<haxe_doc>Do not use manually.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
			<m n=":noCompletion"/>
		</meta>
	</class>
	<typedef path="haxe.PosInfos" params="" file="/usr/share/haxe/std/haxe/PosInfos.hx">
		<a>
			<methodName><c path="String"/></methodName>
			<lineNumber><x path="Int"/></lineNumber>
			<fileName><c path="String"/></fileName>
			<customParams>
				<x path="Null"><c path="Array"><d/></c></x>
				<meta><m n=":optional"/></meta>
			</customParams>
			<className><c path="String"/></className>
		</a>
		<haxe_doc>`PosInfos` is a magic type which can be used to generate position information
	into the output for debugging use.

	If a function has a final optional argument of this type, i.e.
	`(..., ?pos:haxe.PosInfos)`, each call to that function which does not assign
	a value to that argument has its position added as call argument.

	This can be used to track positions of calls in e.g. a unit testing
	framework.</haxe_doc>
	</typedef>
	<typedef path="haxe._Rest.NativeRest" params="T" file="/usr/share/haxe/std/lua/_std/haxe/Rest.hx" private="1" module="haxe.Rest"><c path="lua.Table">
	<x path="Int"/>
	<c path="haxe._Rest.NativeRest.T"/>
</c></typedef>
	<abstract path="haxe.Rest" params="T" file="/usr/share/haxe/std/lua/_std/haxe/Rest.hx">
		<from><icast field="of"><c path="Array"><c path="of.T"/></c></icast></from>
		<this><t path="haxe._Rest.NativeRest"><c path="haxe.Rest.T"/></t></this>
		<to><icast field="toArray"><c path="Array"><c path="haxe.Rest.T"/></c></icast></to>
		<meta><m n=":coreApi"/></meta>
		<impl><class path="haxe._Rest.Rest_Impl_" params="" file="/usr/share/haxe/std/lua/_std/haxe/Rest.hx" private="1" module="haxe.Rest" final="1"><meta>
	<m n=":keep"/>
	<m n=":coreApi"/>
</meta></class></impl>
	</abstract>
	<class path="haxe.ValueException" params="" file="/usr/share/haxe/std/haxe/ValueException.hx">
		<extends path="haxe.Exception"/>
		<value public="1" set="null">
			<x path="Any"/>
			<haxe_doc>Thrown value.</haxe_doc>
		</value>
		<unwrap set="method" line="35" override="1">
			<f a=""><x path="Any"/></f>
			<haxe_doc>Extract an originally thrown value.

		This method must return the same value on subsequent calls.
		Used internally for catching non-native exceptions.
		Do _not_ override unless you know what you are doing.</haxe_doc>
		</unwrap>
		<new public="1" set="method" line="23"><f a="value:?previous:?native">
	<x path="Any"/>
	<c path="haxe.Exception"/>
	<x path="Any"/>
	<x path="Void"/>
</f></new>
		<haxe_doc>An exception containing arbitrary value.

	This class is automatically used for throwing values, which don't extend `haxe.Exception`
	or native exception type.
	For example:
	```haxe
	throw "Terrible error";
	```
	will be compiled to
	```haxe
	throw new ValueException("Terrible error");
	```</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="lua.Table" params="A:B" file="/usr/share/haxe/std/lua/Table.hx" extern="1">
		<create public="1" params="A:B" set="method" static="1"><f a="?arr:?hsh">
	<c path="Array"><c path="create.B"/></c>
	<d/>
	<c path="lua.Table">
		<c path="create.A"/>
		<c path="create.B"/>
	</c>
</f></create>
		<fromArray public="1" params="T" get="inline" set="null" line="37" static="1"><f a="arr">
	<c path="Array"><c path="fromArray.T"/></c>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="fromArray.T"/>
	</c>
</f></fromArray>
		<fromMap public="1" params="A:B" get="inline" set="null" line="45" static="1">
			<f a="map">
				<t path="Map">
					<c path="fromMap.A"/>
					<c path="fromMap.B"/>
				</t>
				<c path="lua.Table">
					<c path="fromMap.A"/>
					<c path="fromMap.B"/>
				</c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</fromMap>
		<fromDynamic public="1" params="A:B" get="inline" set="null" line="53" static="1">
			<f a="dyn">
				<d/>
				<c path="lua.Table">
					<c path="fromDynamic.A"/>
					<c path="fromDynamic.B"/>
				</c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</fromDynamic>
		<toMap public="1" params="A:B" get="inline" set="null" line="61" static="1"><f a="tbl">
	<c path="lua.Table">
		<c path="toMap.A"/>
		<c path="toMap.B"/>
	</c>
	<t path="Map">
		<c path="toMap.A"/>
		<c path="toMap.B"/>
	</t>
</f></toMap>
		<toObject public="1" params="T" get="inline" set="null" line="73" static="1">
			<f a="t">
				<c path="lua.Table">
					<c path="String"/>
					<c path="toObject.T"/>
				</c>
				<d><c path="toObject.T"/></d>
			</f>
			<haxe_doc>Copies the table argument and converts it to an Object.</haxe_doc>
		</toObject>
		<toArray public="1" params="T" get="inline" set="null" line="78" static="1"><f a="tbl:?length">
	<c path="lua.Table">
		<x path="Int"/>
		<c path="toArray.T"/>
	</c>
	<x path="Int"/>
	<c path="Array"><c path="toArray.T"/></c>
</f></toArray>
		<concat public="1" params="A:B" set="method" static="1">
			<f a="table:?sep:?i:?j">
				<c path="lua.Table">
					<c path="concat.A"/>
					<c path="concat.B"/>
				</c>
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<overloads><concat public="1" params="A:B" set="method"><f a="table">
	<c path="lua.Table">
		<c path="concat.A"/>
		<c path="concat.B"/>
	</c>
	<x path="Void"/>
</f></concat></overloads>
		</concat>
		<sort public="1" params="A:B" set="method" static="1"><f a="table:?order">
	<c path="lua.Table">
		<c path="sort.A"/>
		<c path="sort.B"/>
	</c>
	<f a=":">
		<c path="sort.A"/>
		<c path="sort.A"/>
		<x path="Bool"/>
	</f>
	<x path="Void"/>
</f></sort>
		<insert public="1" params="B" set="method" static="1">
			<f a="table:pos:value">
				<c path="lua.Table">
					<x path="Int"/>
					<c path="insert.B"/>
				</c>
				<x path="Int"/>
				<c path="insert.B"/>
				<x path="Void"/>
			</f>
			<overloads><insert public="1" params="B" set="method"><f a="table:value">
	<c path="lua.Table">
		<x path="Int"/>
		<c path="insert.B"/>
	</c>
	<c path="insert.B"/>
	<x path="Void"/>
</f></insert></overloads>
		</insert>
		<remove public="1" params="B" set="method" static="1">
			<f a="table:?pos">
				<c path="lua.Table">
					<x path="Int"/>
					<c path="remove.B"/>
				</c>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads><remove public="1" params="B" set="method"><f a="table">
	<c path="lua.Table">
		<x path="Int"/>
		<c path="remove.B"/>
	</c>
	<x path="Void"/>
</f></remove></overloads>
		</remove>
		<haxe_doc>This library provides generic functions for table manipulation.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"_G.table"</e></m>
		</meta>
	</class>
	<abstract path="haxe.ds.Map" params="K:V" file="/usr/share/haxe/std/haxe/ds/Map.hx">
		<from>
			<icast field="fromStringMap"><c path="haxe.ds.StringMap"><c path="fromStringMap.V"/></c></icast>
			<icast field="fromIntMap"><c path="haxe.ds.IntMap"><c path="fromIntMap.V"/></c></icast>
			<icast field="fromObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="fromObjectMap.K"/>
	<c path="fromObjectMap.V"/>
</c></icast>
		</from>
		<this><c path="haxe.IMap">
	<c path="haxe.ds.Map.K"/>
	<c path="haxe.ds.Map.V"/>
</c></this>
		<to>
			<icast field="toStringMap"><c path="haxe.ds.StringMap"><c path="toStringMap.V"/></c></icast>
			<icast field="toIntMap"><c path="haxe.ds.IntMap"><c path="toIntMap.V"/></c></icast>
			<icast field="toEnumValueMapMap"><c path="haxe.ds.EnumValueMap">
	<c path="toEnumValueMapMap.K"/>
	<c path="toEnumValueMapMap.V"/>
</c></icast>
			<icast field="toObjectMap"><c path="haxe.ds.ObjectMap">
	<c path="toObjectMap.K"/>
	<c path="toObjectMap.V"/>
</c></icast>
		</to>
		<haxe_doc><![CDATA[Map allows key to value mapping for arbitrary value types, and many key
	types.

	This is a multi-type abstract, it is instantiated as one of its
	specialization types depending on its type parameters.

	A Map can be instantiated without explicit type parameters. Type inference
	will then determine the type parameters from the usage.

	Maps can also be created with `[key1 => value1, key2 => value2]` syntax.

	Map is an abstract type, it is not available at runtime.

	@see https://haxe.org/manual/std-Map.html]]></haxe_doc>
		<meta>
			<m n=":transitive"/>
			<m n=":multiType"><e>@:followWithAbstracts K</e></m>
		</meta>
		<impl><class path="haxe.ds._Map.Map_Impl_" params="" file="/usr/share/haxe/std/haxe/ds/Map.hx" private="1" module="haxe.ds.Map" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.ObjectMap" params="A:B" file="/usr/share/haxe/std/lua/_std/haxe/ds/ObjectMap.hx">
		<implements path="haxe.IMap">
			<c path="haxe.ds.ObjectMap.A"/>
			<c path="haxe.ds.ObjectMap.B"/>
		</implements>
		<h><d/></h>
		<k><d/></k>
		<get public="1" get="inline" set="null" line="51">
			<f a="key">
				<c path="haxe.ds.ObjectMap.A"/>
				<x path="Null"><c path="haxe.ds.ObjectMap.B"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</get>
		<keys public="1" set="method" line="70">
			<f a=""><t path="Iterator"><c path="haxe.ds.ObjectMap.A"/></t></f>
			<meta><m n=":has_untyped"/></meta>
		</keys>
		<new public="1" get="inline" set="null" line="39"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<abstract path="haxe.ds.ReadOnlyArray" params="T" file="/usr/share/haxe/std/haxe/ds/ReadOnlyArray.hx">
		<from><icast><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></icast></from>
		<this><c path="Array"><c path="haxe.ds.ReadOnlyArray.T"/></c></this>
		<to><icast><t path="Iterable"><c path="haxe.ds.ReadOnlyArray.T"/></t></icast></to>
		<haxe_doc>`ReadOnlyArray` is an abstract over an ordinary `Array` which only exposes
	APIs that don't modify the instance, hence "read-only".

	Note that this doesn't necessarily mean that the instance is *immutable*.
	Other code holding a reference to the underlying `Array` can still modify it,
	and the reference can be obtained with a `cast`.</haxe_doc>
		<meta><m n=":forward">
	<e>copy</e>
	<e>filter</e>
	<e>indexOf</e>
	<e>iterator</e>
	<e>keyValueIterator</e>
	<e>join</e>
	<e>lastIndexOf</e>
	<e>map</e>
	<e>slice</e>
	<e>contains</e>
	<e>toString</e>
</m></meta>
		<impl><class path="haxe.ds._ReadOnlyArray.ReadOnlyArray_Impl_" params="" file="/usr/share/haxe/std/haxe/ds/ReadOnlyArray.hx" private="1" module="haxe.ds.ReadOnlyArray" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="haxe.ds.StringMap" params="T" file="/usr/share/haxe/std/lua/_std/haxe/ds/StringMap.hx">
		<implements path="haxe.IMap">
			<c path="String"/>
			<c path="haxe.ds.StringMap.T"/>
		</implements>
		<tnull expr="lua.Table.create()" line="30" static="1">
			<d/>
			<meta><m n=":value"><e>lua.Table.create()</e></m></meta>
		</tnull>
		<h><c path="lua.Table">
	<c path="String"/>
	<c path="haxe.ds.StringMap.T"/>
</c></h>
		<get public="1" get="inline" set="null" line="46">
			<f a="key">
				<c path="String"/>
				<x path="Null"><c path="haxe.ds.StringMap.T"/></x>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</get>
		<keys public="1" set="method" line="69"><f a=""><t path="Iterator"><c path="String"/></t></f></keys>
		<new public="1" get="inline" set="null" line="32"><f a=""><x path="Void"/></f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.exceptions.PosException" params="" file="/usr/share/haxe/std/haxe/exceptions/PosException.hx">
		<extends path="haxe.Exception"/>
		<posInfos final="1" public="1">
			<t path="haxe.PosInfos"/>
			<haxe_doc>Position where this exception was created.</haxe_doc>
		</posInfos>
		<toString public="1" set="method" line="24" override="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns exception message.</haxe_doc>
		</toString>
		<new public="1" set="method" line="12"><f a="message:?previous:?pos">
	<c path="String"/>
	<c path="haxe.Exception"/>
	<x path="Null"><t path="haxe.PosInfos"/></x>
	<x path="Void"/>
</f></new>
		<haxe_doc>An exception that carry position information of a place where it was created.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<class path="haxe.exceptions.ArgumentException" params="" file="/usr/share/haxe/std/haxe/exceptions/ArgumentException.hx">
		<extends path="haxe.exceptions.PosException"/>
		<argument final="1" public="1">
			<c path="String"/>
			<haxe_doc>An argument name.</haxe_doc>
		</argument>
		<new public="1" set="method" line="12"><f a="argument:?message:?previous:?pos">
	<c path="String"/>
	<c path="String"/>
	<c path="haxe.Exception"/>
	<x path="Null"><t path="haxe.PosInfos"/></x>
	<x path="Void"/>
</f></new>
		<haxe_doc>An exception that is thrown when an invalid value provided for an argument of a function.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.exceptions.NotImplementedException" params="" file="/usr/share/haxe/std/haxe/exceptions/NotImplementedException.hx">
		<extends path="haxe.exceptions.PosException"/>
		<new public="1" set="method" line="7">
			<f a="?message:?previous:?pos" v="&quot;Not implemented&quot;::">
				<c path="String"/>
				<c path="haxe.Exception"/>
				<x path="Null"><t path="haxe.PosInfos"/></x>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ message : "Not implemented" }</e></m></meta>
		</new>
		<haxe_doc>An exception that is thrown when requested function or operation does not have an implementation.</haxe_doc>
		<meta><m n=":keep"/></meta>
	</class>
	<abstract path="haxe.extern.EitherType" params="T1:T2" file="/usr/share/haxe/std/haxe/extern/EitherType.hx">
		<from>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
		</from>
		<this><d/></this>
		<to>
			<icast><c path="haxe.extern.EitherType.T1"/></icast>
			<icast><c path="haxe.extern.EitherType.T2"/></icast>
		</to>
		<haxe_doc><![CDATA[An abstract type allowing values to be either of `T1` or `T2` type.
	Supports implicit casts from/to either types.

	It is useful for interfacing with external code on dynamic platforms
	such as JavaScript or Python.

	Otherwise, use of this type is discouraged.

	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
		<meta><m n=":transitive"/></meta>
		<impl><class path="haxe.extern._EitherType.EitherType_Impl_" params="" file="/usr/share/haxe/std/haxe/extern/EitherType.hx" private="1" module="haxe.extern.EitherType" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<typedef path="haxe.extern.Rest" params="T" file="/usr/share/haxe/std/haxe/extern/Rest.hx">
		<x path="haxe.Rest"><c path="haxe.extern.Rest.T"/></x>
		<haxe_doc><![CDATA[DEPRECATED: use haxe.Rest instead.
	
	A special type that represents "rest" function argument.
	Should be used as a type for the last argument of an extern method,
	representing that arbitrary number of arguments of given type can be
	passed to that method.
	@see <https://haxe.org/manual/lf-externs.html>]]></haxe_doc>
	</typedef>
	<typedef path="haxe.io.BytesData" params="" file="/usr/share/haxe/std/haxe/io/BytesData.hx"><c path="Array"><x path="Int"/></c></typedef>
	<class path="haxe.iterators.ArrayIterator" params="T" file="/usr/share/haxe/std/haxe/iterators/ArrayIterator.hx">
		<array final="1"><c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c></array>
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<hasNext public="1" get="inline" set="null" line="44">
			<f a=""><x path="Bool"/></f>
			<haxe_doc>See `Iterator.hasNext`</haxe_doc>
		</hasNext>
		<next public="1" get="inline" set="null" line="52">
			<f a=""><c path="haxe.iterators.ArrayIterator.T"/></f>
			<haxe_doc>See `Iterator.next`</haxe_doc>
		</next>
		<new public="1" get="inline" set="null" line="35">
			<f a="array">
				<c path="Array"><c path="haxe.iterators.ArrayIterator.T"/></c>
				<x path="Void"/>
			</f>
			<haxe_doc>Create a new `ArrayIterator`.</haxe_doc>
		</new>
		<haxe_doc><![CDATA[This iterator is used only when `Array<T>` is passed to `Iterable<T>`]]></haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="haxe.iterators.ArrayKeyValueIterator" params="T" file="/usr/share/haxe/std/haxe/iterators/ArrayKeyValueIterator.hx">
		<current expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</current>
		<array><c path="Array"><c path="haxe.iterators.ArrayKeyValueIterator.T"/></c></array>
		<hasNext public="1" get="inline" set="null" line="34"><f a=""><x path="Bool"/></f></hasNext>
		<next public="1" get="inline" set="null" line="38"><f a=""><a>
	<value><c path="haxe.iterators.ArrayKeyValueIterator.T"/></value>
	<key><x path="Int"/></key>
</a></f></next>
		<new public="1" get="inline" set="null" line="30"><f a="array">
	<c path="Array"><c path="haxe.iterators.ArrayKeyValueIterator.T"/></c>
	<x path="Void"/>
</f></new>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":ifFeature">
				<e>"anon_read.keyValueIterator"</e>
				<e>"dynamic_read.keyValueIterator"</e>
			</m>
		</meta>
	</class>
	<abstract path="haxe.xml._Access.NodeAccess" params="" file="/usr/share/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.NodeAccess_Impl_" params="" file="/usr/share/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.xml._Access.AttribAccess" params="" file="/usr/share/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.AttribAccess_Impl_" params="" file="/usr/share/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.xml._Access.HasAttribAccess" params="" file="/usr/share/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.HasAttribAccess_Impl_" params="" file="/usr/share/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.xml._Access.HasNodeAccess" params="" file="/usr/share/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.HasNodeAccess_Impl_" params="" file="/usr/share/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.xml._Access.NodeListAccess" params="" file="/usr/share/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access">
		<from><icast><c path="Xml"/></icast></from>
		<this><c path="Xml"/></this>
		<impl><class path="haxe.xml._Access.NodeListAccess_Impl_" params="" file="/usr/share/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.xml.Access" params="" file="/usr/share/haxe/std/haxe/xml/Access.hx">
		<this><c path="Xml"/></this>
		<haxe_doc>The `haxe.xml.Access` API helps providing a fast dot-syntax access to the
	most common `Xml` methods.</haxe_doc>
		<impl><class path="haxe.xml._Access.Access_Impl_" params="" file="/usr/share/haxe/std/haxe/xml/Access.hx" private="1" module="haxe.xml.Access" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<abstract path="haxe.xml._Parser.S" params="" file="/usr/share/haxe/std/haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser">
		<this><x path="Int"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="haxe.xml._Parser.S_Impl_" params="" file="/usr/share/haxe/std/haxe/xml/Parser.hx" private="1" module="haxe.xml.Parser" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<enum path="kernel.MouseEventType" params="" file="src/kernel/Driver.hx" module="kernel.Driver">
		<Click/>
		<ClickUp/>
		<Drag/>
		<Scroll/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<enum path="kernel.MouseButton" params="" file="src/kernel/Driver.hx" module="kernel.Driver">
		<None/>
		<Left/>
		<Right/>
		<Middle/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<class path="kernel.MouseEvent" params="" file="src/kernel/Driver.hx" module="kernel.Driver">
		<x public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</x>
		<y public="1" expr="0">
			<x path="Float"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</y>
		<button public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</button>
		<type public="1" expr="MouseEventType.Click">
			<e path="kernel.MouseEventType"/>
			<meta><m n=":value"><e>MouseEventType.Click</e></m></meta>
		</type>
		<new public="1" set="method" line="27"><f a="type:x:y:button">
	<e path="kernel.MouseEventType"/>
	<x path="Float"/>
	<x path="Float"/>
	<x path="Int"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="kernel.DriverProvides" params="" file="src/kernel/Driver.hx" module="kernel.Driver">
		<Keyboard/>
		<Mouse/>
		<Terminal/>
		<Sound/>
		<Disk/>
		<Http/>
		<Network/>
		<Clock/>
		<Custom a="name"><c path="String"/></Custom>
		<meta><m n=":directlyUsed"/></meta>
	</enum>
	<class path="kernel.Driver" params="" file="src/kernel/Driver.hx" abstract="1">
		<init abstract="1" public="1" set="method"><f a=""><x path="Void"/></f></init>
		<deinit abstract="1" public="1" set="method"><f a=""><x path="Void"/></f></deinit>
		<bg abstract="1" public="1" set="method"><f a="ev">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></bg>
		<dataread abstract="1" public="1" set="method"><f a=""><c path="String"/></f></dataread>
		<datawrite abstract="1" public="1" set="method"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></datawrite>
		<deviceName public="1"><c path="String"/></deviceName>
		<provides public="1"><e path="kernel.DriverProvides"/></provides>
	</class>
	<class path="kernel.KeyboardDriver" params="" file="src/kernel/Driver.hx" module="kernel.Driver" abstract="1">
		<extends path="kernel.Driver"/>
		<readInt abstract="1" public="1" set="method">
			<f a="?timeout" v="-1">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ timeout : -1 }</e></m></meta>
		</readInt>
		<readChar abstract="1" public="1" set="method">
			<f a="?timeout" v="-1">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ timeout : -1 }</e></m></meta>
		</readChar>
		<readChars abstract="1" public="1" set="method">
			<f a="num:?timeout:?echo:?echoOutput:?showCursor" v=":-1:&quot;/&quot;::true">
				<x path="Int"/>
				<x path="Float"/>
				<c path="String"/>
				<c path="globals.Output"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ showCursor : true, echo : "/", timeout : -1 }</e></m></meta>
		</readChars>
		<readLine public="1" set="method" line="69">
			<f a="?timeout:?echo:?echoOutput:?showCursor" v="-1:&quot;/&quot;::false">
				<x path="Float"/>
				<c path="String"/>
				<c path="globals.Output"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ showCursor : false, echo : "/", timeout : -1 }</e></m></meta>
		</readLine>
		<new public="1" set="method" line="120"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<enum path="kernel.FileType" params="" file="src/kernel/Driver.hx" module="kernel.Driver">
		<Directory/>
		<File/>
		<Link/>
		<Device/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="kernel.FileSystemDriver" params="" file="src/kernel/Driver.hx" module="kernel.Driver" abstract="1">
		<extends path="kernel.Driver"/>
		<read abstract="1" public="1" set="method"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></read>
		<readBytes abstract="1" public="1" set="method">
			<f a="path:bytes:?fromPos" v="::0">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ fromPos : 0 }</e></m></meta>
		</readBytes>
		<write abstract="1" public="1" set="method"><f a="path:text">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></write>
		<writeByte abstract="1" public="1" set="method"><f a="path:byte">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<append abstract="1" public="1" set="method"><f a="path:text">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></append>
		<exists abstract="1" public="1" set="method"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<isReadOnly abstract="1" public="1" set="method">
			<f a="path:?user" v=":&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ user : "" }</e></m></meta>
		</isReadOnly>
		<list abstract="1" public="1" set="method"><f a="dir">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></list>
		<type abstract="1" public="1" set="method"><f a="path">
	<c path="String"/>
	<e path="kernel.FileType"/>
</f></type>
		<new public="1" set="method" line="151"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel.MouseDriver" params="" file="src/kernel/Driver.hx" module="kernel.Driver" abstract="1">
		<extends path="kernel.Driver"/>
		<getEvent abstract="1" public="1" set="method"><f a="filter">
	<x path="Null"><e path="kernel.MouseEventType"/></x>
	<c path="kernel.MouseEvent"/>
</f></getEvent>
		<new public="1" set="method" line="159"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel._Driver.TDOutput" params="" file="src/kernel/Driver.hx" private="1" module="kernel.Driver">
		<extends path="globals.Output"/>
		<td expr="null">
			<c path="kernel.TerminalDriver"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</td>
		<write public="1" set="method" line="171" override="1"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></write>
		<clear public="1" set="method" line="175" override="1"><f a=""><x path="Void"/></f></clear>
		<setFGColor public="1" set="method" line="179" override="1"><f a="col">
	<c path="globals.Color"/>
	<x path="Void"/>
</f></setFGColor>
		<setBGColor public="1" set="method" line="183" override="1"><f a="col">
	<c path="globals.Color"/>
	<x path="Void"/>
</f></setBGColor>
		<set_palette public="1" set="method" line="187" override="1"><f a="newc">
	<c path="Array"><c path="globals.RGBColor"/></c>
	<c path="Array"><c path="globals.RGBColor"/></c>
</f></set_palette>
		<getCursorPos public="1" set="method" line="191" override="1"><f a=""><c path="globals.Vector2i"/></f></getCursorPos>
		<setCursorPos public="1" set="method" line="195" override="1"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setCursorPos>
		<setCursorPosRelative public="1" set="method" line="199" override="1"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setCursorPosRelative>
		<get_size public="1" set="method" line="203" override="1"><f a=""><c path="globals.Vector2i"/></f></get_size>
		<new public="1" set="method" line="167"><f a="td">
	<c path="kernel.TerminalDriver"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel.TerminalDriver" params="" file="src/kernel/Driver.hx" module="kernel.Driver" abstract="1">
		<extends path="kernel.Driver"/>
		<write abstract="1" public="1" set="method"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></write>
		<print public="1" set="method" line="211"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></print>
		<clear abstract="1" public="1" set="method"><f a=""><x path="Void"/></f></clear>
		<setFGColor abstract="1" public="1" set="method"><f a="col">
	<c path="globals.Color"/>
	<x path="Void"/>
</f></setFGColor>
		<setBGColor abstract="1" public="1" set="method"><f a="col">
	<c path="globals.Color"/>
	<x path="Void"/>
</f></setBGColor>
		<apalette expr="[new RGBColor(236, 239, 244), new RGBColor(0, 0, 0), new RGBColor(180, 142, 173), new RGBColor(0, 0, 0), new RGBColor(235, 203, 139), new RGBColor(163, 190, 140), new RGBColor(0, 0, 0), new RGBColor(173, 179, 187), new RGBColor(216, 222, 187), new RGBColor(136, 192, 208), new RGBColor(0, 0, 0), new RGBColor(129, 161, 193), new RGBColor(0, 0, 0), new RGBColor(163, 190, 140), new RGBColor(191, 97, 106), new RGBColor(59, 66, 82)]">
			<c path="Array"><c path="globals.RGBColor"/></c>
			<meta><m n=":value"><e>[new RGBColor(236, 239, 244), new RGBColor(0, 0, 0), new RGBColor(180, 142, 173), new RGBColor(0, 0, 0), new RGBColor(235, 203, 139), new RGBColor(163, 190, 140), new RGBColor(0, 0, 0), new RGBColor(173, 179, 187), new RGBColor(216, 222, 187), new RGBColor(136, 192, 208), new RGBColor(0, 0, 0), new RGBColor(129, 161, 193), new RGBColor(0, 0, 0), new RGBColor(163, 190, 140), new RGBColor(191, 97, 106), new RGBColor(59, 66, 82)]</e></m></meta>
		</apalette>
		<palette public="1" get="accessor" set="accessor"><c path="Array"><c path="globals.RGBColor"/></c></palette>
		<size public="1" get="accessor" set="accessor"><c path="globals.Vector2i"/></size>
		<set_palette abstract="1" public="1" set="method"><f a="newc">
	<c path="Array"><c path="globals.RGBColor"/></c>
	<c path="Array"><c path="globals.RGBColor"/></c>
</f></set_palette>
		<get_palette public="1" set="method" line="245"><f a=""><c path="Array"><c path="globals.RGBColor"/></c></f></get_palette>
		<getCursorPos abstract="1" public="1" set="method"><f a=""><c path="globals.Vector2i"/></f></getCursorPos>
		<setCursorPos abstract="1" public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setCursorPos>
		<setCursorPosRelative abstract="1" public="1" set="method"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setCursorPosRelative>
		<get_size abstract="1" public="1" set="method"><f a=""><c path="globals.Vector2i"/></f></get_size>
		<set_size public="1" set="method" line="257"><f a="s">
	<c path="globals.Vector2i"/>
	<c path="globals.Vector2i"/>
</f></set_size>
		<asOutput public="1" set="method" line="261"><f a=""><c path="globals.Output"/></f></asOutput>
		<new public="1" set="method" line="265"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel.SoundDriver" params="" file="src/kernel/Driver.hx" module="kernel.Driver" abstract="1">
		<extends path="kernel.Driver"/>
		<playNote abstract="1" public="1" set="method">
			<f a="instrument:?volume:?pitch" v=":2:1">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ pitch : 1, volume : 2 }</e></m></meta>
		</playNote>
		<playSound abstract="1" public="1" set="method">
			<f a="name:?volume:?pitch" v=":2:1">
				<c path="String"/>
				<x path="Float"/>
				<x path="Float"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ pitch : 1, volume : 2 }</e></m></meta>
		</playSound>
		<playAudio abstract="1" public="1" set="method"><f a="audio:volume">
	<c path="Array"><x path="Int"/></c>
	<x path="Float"/>
	<x path="Void"/>
</f></playAudio>
		<new public="1" set="method" line="277"><f a=""><x path="Void"/></f></new>
	</class>
	<enum path="kernel.RequestType" params="" file="src/kernel/Driver.hx" module="kernel.Driver">
		<Post/>
		<Get/>
		<meta><m n=":flatEnum"/></meta>
	</enum>
	<enum path="kernel.Since" params="" file="src/kernel/Driver.hx" module="kernel.Driver">
		<ComputerStart/>
		<UnixEpoch/>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":flatEnum"/>
		</meta>
	</enum>
	<class path="kernel.HttpDriver" params="" file="src/kernel/Driver.hx" module="kernel.Driver" abstract="1">
		<extends path="kernel.Driver"/>
		<sendRequest abstract="1" public="1" set="method">
			<f a="url:?requestType:body:headers" v=":RequestType.Get::">
				<c path="String"/>
				<e path="kernel.RequestType"/>
				<c path="String"/>
				<t path="Map">
					<c path="String"/>
					<c path="String"/>
				</t>
				<x path="Null"><c path="String"/></x>
			</f>
			<meta><m n=":value"><e>{ requestType : RequestType.Get }</e></m></meta>
		</sendRequest>
		<new public="1" set="method" line="294"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="kernel.ClockDriver" params="" file="src/kernel/Driver.hx" module="kernel.Driver" abstract="1">
		<extends path="kernel.Driver"/>
		<getEpoch abstract="1" public="1" set="method">
			<f a="since">
				<e path="kernel.Since"/>
				<x path="Float"/>
			</f>
			<haxe_doc>* Returns an epoch 
	 * @param since Since (x)
	 * @return The epoch</haxe_doc>
		</getEpoch>
		<new public="1" set="method" line="306"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="kernel.Drivers" params="" file="src/kernel/Drivers.hx">
		<sdrivers expr="[]" line="7" static="1">
			<c path="Array"><c path="kernel.Driver"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</sdrivers>
		<drivers public="1" get="accessor" set="accessor" static="1"><c path="Array"><c path="kernel.Driver"/></c></drivers>
		<getDriversByType public="1" set="method" line="10" static="1"><f a="type">
	<d/>
	<c path="Array"><c path="kernel.Driver"/></c>
</f></getDriversByType>
		<getDriverByType public="1" set="method" line="20" static="1"><f a="type">
	<d/>
	<x path="Null"><c path="kernel.Driver"/></x>
</f></getDriverByType>
		<getDriversByProvides public="1" set="method" line="28" static="1"><f a="p">
	<e path="kernel.DriverProvides"/>
	<c path="Array"><c path="kernel.Driver"/></c>
</f></getDriversByProvides>
		<getDriverByProvides public="1" set="method" line="38" static="1"><f a="p">
	<e path="kernel.DriverProvides"/>
	<x path="Null"><d/></x>
</f></getDriverByProvides>
		<getDriverByName public="1" set="method" line="46" static="1"><f a="name">
	<c path="String"/>
	<x path="Null"><c path="kernel.Driver"/></x>
</f></getDriverByName>
		<add public="1" set="method" line="56" static="1"><f a="d">
	<c path="kernel.Driver"/>
	<x path="Void"/>
</f></add>
		<rem public="1" set="method" line="62" static="1"><f a="name">
	<c path="String"/>
	<x path="Bool"/>
</f></rem>
		<set_drivers set="method" line="79" static="1"><f a="value">
	<c path="Array"><c path="kernel.Driver"/></c>
	<c path="Array"><c path="kernel.Driver"/></c>
</f></set_drivers>
		<get_drivers set="method" line="83" static="1"><f a=""><c path="Array"><c path="kernel.Driver"/></c></f></get_drivers>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"drv"</e></m>
		</meta>
	</class>
	<class path="kernel.Hook" params="" file="src/kernel/Hook.hx" abstract="1">
		<init abstract="1" public="1" set="method"><f a=""><x path="Void"/></f></init>
		<bg abstract="1" public="1" set="method"><f a="ev">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></bg>
		<deinit abstract="1" public="1" set="method"><f a=""><x path="Void"/></f></deinit>
		<new public="1" set="method" line="4"><f a=""><x path="Void"/></f></new>
	</class>
	<class path="kernel._Kernel.KFSMount" params="" file="src/kernel/Kernel.hx" private="1" module="kernel.Kernel">
		<filePath public="1"><c path="globals.FilePath"/></filePath>
		<fsd public="1"><c path="kernel.FileSystemDriver"/></fsd>
		<new public="1" set="method" line="21"><f a="fp:s">
	<c path="globals.FilePath"/>
	<c path="kernel.FileSystemDriver"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel._Kernel.MountNotFoundException" params="" file="src/kernel/Kernel.hx" private="1" module="kernel.Kernel">
		<extends path="haxe.Exception"/>
		<new public="1" set="method" line="27"><f a="message:?previous:?native">
	<c path="String"/>
	<c path="haxe.Exception"/>
	<x path="Any"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel._Kernel.KFSDriver" params="" file="src/kernel/Kernel.hx" private="1" module="kernel.Kernel">
		<extends path="kernel.FileSystemDriver"/>
		<mounts expr="[]">
			<c path="Array"><c path="kernel._Kernel.KFSMount"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</mounts>
		<getFS set="method" line="37"><f a="path">
	<c path="globals.FilePath"/>
	<c path="kernel.FileSystemDriver"/>
</f></getFS>
		<getFSS set="method" line="55"><f a="path">
	<c path="String"/>
	<c path="kernel.FileSystemDriver"/>
</f></getFSS>
		<init public="1" set="method" line="59" override="1"><f a=""><x path="Void"/></f></init>
		<deinit public="1" set="method" line="61" override="1"><f a=""><x path="Void"/></f></deinit>
		<bg public="1" set="method" line="63" override="1"><f a="ev">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></bg>
		<read public="1" set="method" line="65" override="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></read>
		<readBytes public="1" set="method" line="71" override="1">
			<f a="path:bytes:?fromPos" v="::0">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ fromPos : 0 }</e></m></meta>
		</readBytes>
		<write public="1" set="method" line="75" override="1"><f a="path:text">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></write>
		<writeByte public="1" set="method" line="80" override="1"><f a="path:byte">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<append public="1" set="method" line="84" override="1"><f a="path:text">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></append>
		<exists public="1" set="method" line="89" override="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<isReadOnly public="1" set="method" line="94" override="1">
			<f a="path:?user" v=":&quot;&quot;">
				<c path="String"/>
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":value"><e>{ user : "" }</e></m></meta>
		</isReadOnly>
		<list public="1" set="method" line="99" override="1"><f a="dir">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></list>
		<type public="1" set="method" line="110" override="1"><f a="path">
	<c path="String"/>
	<e path="kernel.FileType"/>
</f></type>
		<dataread public="1" set="method" line="115" override="1"><f a=""><c path="String"/></f></dataread>
		<datawrite public="1" set="method" line="119" override="1"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></datawrite>
		<new public="1" set="method" line="32"><f a="upfs">
	<c path="kernel.FileSystemDriver"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel.OS" params="" file="src/kernel/Kernel.hx" module="kernel.Kernel">
		<run public="1" set="method" line="123" static="1">
			<f a="env:path">
				<t path="Map">
					<c path="String"/>
					<d/>
				</t>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</run>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"XGos"</e></m>
		</meta>
	</class>
	<class path="kernel.Kernel" params="" file="src/kernel/Kernel.hx">
		<threadRunner static="1"><c path="kernel.KThreadRunner"/></threadRunner>
		<panic public="1" set="method" line="215" static="1"><f a="reason:?posinfo">
	<c path="String"/>
	<x path="Null"><t path="haxe.PosInfos"/></x>
	<x path="Void"/>
</f></panic>
		<main public="1" set="method" line="253" static="1">
			<f a=""><x path="Void"/></f>
			<meta>
				<m n=":keep"/>
				<m n=":has_untyped"/>
			</meta>
		</main>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel.Logger" params="" file="src/kernel/Logger.hx">
		<logBuf public="1" expr="&quot;&quot;" line="10" static="1">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</logBuf>
		<log public="1" set="method" line="11" static="1"><f a="text:?pos">
	<c path="String"/>
	<t path="haxe.PosInfos"/>
	<x path="Void"/>
</f></log>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel.KThread" params="" file="src/kernel/Thread.hx" module="kernel.Thread">
		<pInfo public="1" expr="new KThreadInfo(&quot;&quot;, 0, new Map&lt;String,String&gt;(), &quot;KTrunner&quot;)">
			<c path="kernel.KThreadInfo"/>
			<meta><m n=":value"><e><![CDATA[new KThreadInfo("", 0, new Map<String,String>(), "KTrunner")]]></e></m></meta>
		</pInfo>
		<pCoroutine public="1"><c path="lua.Coroutine"><d/></c></pCoroutine>
		<pDI public="1" expr="null">
			<t path="lua.DebugInfo"/>
			<meta><m n=":value"><e>null</e></m></meta>
		</pDI>
		<new public="1" set="method" line="20">
			<f a="name:callback:cId:pEnv:user">
				<c path="String"/>
				<f a=""><x path="Void"/></f>
				<x path="Int"/>
				<t path="Map">
					<c path="String"/>
					<c path="String"/>
				</t>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel.KThreadInfo" params="" file="src/kernel/Thread.hx" module="kernel.Thread">
		<name public="1" expr="&quot;(empty)&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"(empty)"</e></m></meta>
		</name>
		<creatorID public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</creatorID>
		<ID public="1" expr="0">
			<x path="Int"/>
			<meta><m n=":value"><e>0</e></m></meta>
		</ID>
		<user public="1" expr="&quot;&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>""</e></m></meta>
		</user>
		<env public="1" expr="[]">
			<t path="Map">
				<c path="String"/>
				<c path="String"/>
			</t>
			<meta><m n=":value"><e>[]</e></m></meta>
		</env>
		<copy public="1" set="method" line="41"><f a=""><c path="kernel.KThreadInfo"/></f></copy>
		<new public="1" set="method" line="35"><f a="name:creatorID:env:user">
	<c path="String"/>
	<x path="Int"/>
	<t path="Map">
		<c path="String"/>
		<c path="String"/>
	</t>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel.KThreadRunner" params="" file="src/kernel/Thread.hx" module="kernel.Thread">
		<tasks public="1" expr="[]">
			<c path="Array"><c path="kernel.KThread"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</tasks>
		<hooks expr="[]">
			<c path="Array"><c path="kernel.Hook"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</hooks>
		<current public="1" expr="new KThread(&quot;krnl.lua&quot;, function() -&gt;  @:implicitReturn return { }, 0, [], &quot;KrnlRunner&quot;)">
			<c path="kernel.KThread"/>
			<meta><m n=":value"><e><![CDATA[new KThread("krnl.lua", function() ->  @:implicitReturn return { }, 0, [], "KrnlRunner")]]></e></m></meta>
		</current>
		<ongoingQueueEvents public="1" expr="[]">
			<c path="Array"><c path="Array"><d/></c></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</ongoingQueueEvents>
		<run public="1" set="method" line="53"><f a=""><x path="Void"/></f></run>
		<addThread public="1" set="method" line="109"><f a="th">
	<c path="kernel.KThread"/>
	<x path="Void"/>
</f></addThread>
		<new public="1" set="method" line="120"><f a="hooks">
	<c path="Array"><c path="kernel.Hook"/></c>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel.KThreadAPI" params="" file="src/kernel/Thread.hx" module="kernel.Thread">
		<te><c path="kernel.KThreadRunner"/></te>
		<current public="1" get="accessor" set="accessor"><c path="kernel.KThreadInfo"/></current>
		<get_current public="1" set="method" line="126"><f a=""><c path="kernel.KThreadInfo"/></f></get_current>
		<set_current public="1" set="method" line="129"><f a="v">
	<c path="kernel.KThreadInfo"/>
	<c path="kernel.KThreadInfo"/>
</f></set_current>
		<create public="1" set="method" line="133"><f a="name:callback">
	<c path="String"/>
	<f a=""><x path="Void"/></f>
	<x path="Void"/>
</f></create>
		<queue public="1" set="method" line="137"><f a="event">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></queue>
		<getTasks public="1" set="method" line="145"><f a=""><c path="Array"><c path="kernel.KThreadInfo"/></c></f></getTasks>
		<new public="1" set="method" line="141"><f a="te">
	<c path="kernel.KThreadRunner"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel.XG" params="" file="src/kernel/Thread.hx" module="kernel.Thread">
		<fs public="1" static="1">
			<c path="kernel.FileSystemDriver"/>
			<meta><m n=":native"><e>"fs"</e></m></meta>
		</fs>
		<api public="1" static="1">
			<c path="kernel.KThreadAPI"/>
			<meta><m n=":native"><e>"api"</e></m></meta>
		</api>
		<inp public="1" static="1">
			<c path="kernel.KeyboardDriver"/>
			<meta><m n=":native"><e>"inp"</e></m></meta>
		</inp>
		<out public="1" static="1">
			<c path="globals.Output"/>
			<meta><m n=":native"><e>"out"</e></m></meta>
		</out>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"xg"</e></m>
		</meta>
	</class>
	<class path="kernel.hooks.CCFileSystemDriver" params="" file="src/kernel/hooks/CCFSDriverHook.hx" module="kernel.hooks.CCFSDriverHook">
		<extends path="kernel.FileSystemDriver"/>
		<rootpath expr="&quot;/&quot;">
			<c path="String"/>
			<meta><m n=":value"><e>"/"</e></m></meta>
		</rootpath>
		<init public="1" set="method" line="23" override="1"><f a=""><x path="Void"/></f></init>
		<deinit public="1" set="method" line="26" override="1"><f a=""><x path="Void"/></f></deinit>
		<bg public="1" set="method" line="29" override="1"><f a="ev">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></bg>
		<read public="1" set="method" line="31" override="1"><f a="path">
	<c path="String"/>
	<c path="String"/>
</f></read>
		<readBytes public="1" set="method" line="41" override="1">
			<f a="path:bytes:?fromPos" v="::0">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="Array"><x path="Int"/></c>
			</f>
			<meta><m n=":value"><e>{ fromPos : 0 }</e></m></meta>
		</readBytes>
		<write public="1" set="method" line="50" override="1"><f a="path:text">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></write>
		<writeByte public="1" set="method" line="57" override="1"><f a="path:byte">
	<c path="String"/>
	<x path="Int"/>
	<x path="Void"/>
</f></writeByte>
		<append public="1" set="method" line="64" override="1"><f a="path:text">
	<c path="String"/>
	<c path="String"/>
	<x path="Void"/>
</f></append>
		<exists public="1" set="method" line="69" override="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></exists>
		<isReadOnly public="1" set="method" line="73" override="1"><f a="path:?user">
	<c path="String"/>
	<c path="String"/>
	<x path="Bool"/>
</f></isReadOnly>
		<list public="1" set="method" line="77" override="1"><f a="dir">
	<c path="String"/>
	<c path="Array"><c path="String"/></c>
</f></list>
		<type public="1" set="method" line="82" override="1"><f a="path">
	<c path="String"/>
	<e path="kernel.FileType"/>
</f></type>
		<dataread public="1" set="method" line="86" override="1"><f a=""><c path="String"/></f></dataread>
		<datawrite public="1" set="method" line="91" override="1"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></datawrite>
		<new public="1" set="method" line="13">
			<f a="?path" v="&quot;/&quot;">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":value"><e>{ path : "/" }</e></m></meta>
		</new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel.hooks.CCFSDriverHook" params="" file="src/kernel/hooks/CCFSDriverHook.hx">
		<extends path="kernel.Hook"/>
		<init public="1" set="method" line="98" override="1"><f a=""><x path="Void"/></f></init>
		<deinit public="1" set="method" line="102" override="1"><f a=""><x path="Void"/></f></deinit>
		<bg public="1" set="method" line="104" override="1"><f a="ev">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></bg>
		<new public="1" set="method" line="96"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel.hooks.MonitorTerminalBackend" params="" file="src/kernel/hooks/CCMonitorDriverHook.hx" module="kernel.hooks.CCMonitorDriverHook">
		<extends path="globals.Output"/>
		<peripheral>
			<d/>
			<meta><m n=":native"><e>"peripheral"</e></m></meta>
		</peripheral>
		<write public="1" set="method" line="11" override="1">
			<f a="s">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</write>
		<clear public="1" set="method" line="21" override="1">
			<f a=""><x path="Void"/></f>
			<meta><m n=":has_untyped"/></meta>
		</clear>
		<setFGColor public="1" set="method" line="24" override="1">
			<f a="col">
				<c path="globals.Color"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setFGColor>
		<setBGColor public="1" set="method" line="27" override="1">
			<f a="col">
				<c path="globals.Color"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setBGColor>
		<setCursorPos public="1" set="method" line="30" override="1">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setCursorPos>
		<getCursorPos public="1" set="method" line="33" override="1">
			<f a=""><c path="globals.Vector2i"/></f>
			<meta><m n=":has_untyped"/></meta>
		</getCursorPos>
		<setCursorPosRelative public="1" set="method" line="37" override="1">
			<f a="x:y">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</setCursorPosRelative>
		<get_size public="1" set="method" line="49" override="1">
			<f a=""><c path="globals.Vector2i"/></f>
			<meta><m n=":has_untyped"/></meta>
		</get_size>
		<set_palette public="1" set="method" line="53" override="1">
			<f a="newc">
				<c path="Array"><c path="globals.RGBColor"/></c>
				<c path="Array"><c path="globals.RGBColor"/></c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</set_palette>
		<new public="1" set="method" line="66"><f a="monName">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel.hooks.MonitorOutputDriver" params="" file="src/kernel/hooks/CCMonitorDriverHook.hx" module="kernel.hooks.CCMonitorDriverHook">
		<extends path="kernel.TerminalDriver"/>
		<output><c path="globals.Output"/></output>
		<write public="1" set="method" line="80" override="1"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></write>
		<clear public="1" set="method" line="83" override="1"><f a=""><x path="Void"/></f></clear>
		<setFGColor public="1" set="method" line="86" override="1"><f a="col">
	<c path="globals.Color"/>
	<x path="Void"/>
</f></setFGColor>
		<setBGColor public="1" set="method" line="89" override="1"><f a="col">
	<c path="globals.Color"/>
	<x path="Void"/>
</f></setBGColor>
		<set_palette public="1" set="method" line="92" override="1"><f a="newc">
	<c path="Array"><c path="globals.RGBColor"/></c>
	<c path="Array"><c path="globals.RGBColor"/></c>
</f></set_palette>
		<getCursorPos public="1" set="method" line="95" override="1"><f a=""><c path="globals.Vector2i"/></f></getCursorPos>
		<setCursorPos public="1" set="method" line="98" override="1"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setCursorPos>
		<setCursorPosRelative public="1" set="method" line="101" override="1"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setCursorPosRelative>
		<get_size public="1" set="method" line="104" override="1"><f a=""><c path="globals.Vector2i"/></f></get_size>
		<init public="1" set="method" line="109" override="1"><f a=""><x path="Void"/></f></init>
		<deinit public="1" set="method" line="111" override="1"><f a=""><x path="Void"/></f></deinit>
		<bg public="1" set="method" line="113" override="1"><f a="ev">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></bg>
		<dataread public="1" set="method" line="115" override="1"><f a=""><c path="String"/></f></dataread>
		<datawrite public="1" set="method" line="119" override="1"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></datawrite>
		<new public="1" set="method" line="75"><f a="monName">
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel.hooks.CCMonitorDriverHook" params="" file="src/kernel/hooks/CCMonitorDriverHook.hx">
		<extends path="kernel.Hook"/>
		<mons expr="[]">
			<c path="Array"><c path="String"/></c>
			<meta><m n=":value"><e>[]</e></m></meta>
		</mons>
		<init public="1" set="method" line="127" override="1"><f a=""><x path="Void"/></f></init>
		<deinit public="1" set="method" line="135" override="1"><f a=""><x path="Void"/></f></deinit>
		<bg public="1" set="method" line="137" override="1"><f a="ev">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></bg>
		<addMonitior set="method" line="149"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></addMonitior>
		<remMonitior set="method" line="153"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></remMonitior>
		<new public="1" set="method" line="124"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel.hooks.OutputDriver" params="" file="src/kernel/hooks/CCTermHook.hx" module="kernel.hooks.CCTermHook">
		<extends path="kernel.TerminalDriver"/>
		<output expr="new Terminal()">
			<c path="globals.Output"/>
			<meta><m n=":value"><e>new Terminal()</e></m></meta>
		</output>
		<write public="1" set="method" line="23" override="1"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></write>
		<clear public="1" set="method" line="26" override="1"><f a=""><x path="Void"/></f></clear>
		<setFGColor public="1" set="method" line="29" override="1"><f a="col">
	<c path="globals.Color"/>
	<x path="Void"/>
</f></setFGColor>
		<setBGColor public="1" set="method" line="32" override="1"><f a="col">
	<c path="globals.Color"/>
	<x path="Void"/>
</f></setBGColor>
		<set_palette public="1" set="method" line="35" override="1"><f a="newc">
	<c path="Array"><c path="globals.RGBColor"/></c>
	<c path="Array"><c path="globals.RGBColor"/></c>
</f></set_palette>
		<getCursorPos public="1" set="method" line="38" override="1"><f a=""><c path="globals.Vector2i"/></f></getCursorPos>
		<setCursorPos public="1" set="method" line="41" override="1"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setCursorPos>
		<setCursorPosRelative public="1" set="method" line="44" override="1"><f a="x:y">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setCursorPosRelative>
		<get_size public="1" set="method" line="47" override="1"><f a=""><c path="globals.Vector2i"/></f></get_size>
		<init public="1" set="method" line="52" override="1"><f a=""><x path="Void"/></f></init>
		<deinit public="1" set="method" line="54" override="1"><f a=""><x path="Void"/></f></deinit>
		<bg public="1" set="method" line="56" override="1"><f a="ev">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></bg>
		<dataread public="1" set="method" line="58" override="1"><f a=""><c path="String"/></f></dataread>
		<datawrite public="1" set="method" line="62" override="1"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></datawrite>
		<new public="1" set="method" line="18"><f a="output:name">
	<c path="globals.Output"/>
	<c path="String"/>
	<x path="Void"/>
</f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel.hooks.MouseEventYReturn" params="" file="src/kernel/hooks/CCTermHook.hx" module="kernel.hooks.CCTermHook" extern="1">
		<eventName public="1"><c path="String"/></eventName>
		<mouseButton public="1"><x path="Int"/></mouseButton>
		<x public="1"><x path="Float"/></x>
		<y public="1"><x path="Float"/></y>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="kernel.hooks.CCMouseDriver" params="" file="src/kernel/hooks/CCTermHook.hx" module="kernel.hooks.CCTermHook">
		<extends path="kernel.MouseDriver"/>
		<init public="1" set="method" line="76" override="1"><f a=""><x path="Void"/></f></init>
		<deinit public="1" set="method" line="78" override="1"><f a=""><x path="Void"/></f></deinit>
		<bg public="1" set="method" line="80" override="1"><f a="ev">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></bg>
		<getEvent public="1" set="method" line="82" override="1"><f a="filter">
	<x path="Null"><e path="kernel.MouseEventType"/></x>
	<c path="kernel.MouseEvent"/>
</f></getEvent>
		<dataread public="1" set="method" line="105" override="1"><f a=""><c path="String"/></f></dataread>
		<datawrite public="1" set="method" line="110" override="1"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></datawrite>
		<new public="1" set="method" line="100"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel.hooks.CCKeyboardDriver" params="" file="src/kernel/hooks/CCTermHook.hx" module="kernel.hooks.CCTermHook">
		<extends path="kernel.KeyboardDriver"/>
		<init public="1" set="method" line="119" override="1"><f a=""><x path="Void"/></f></init>
		<deinit public="1" set="method" line="121" override="1"><f a=""><x path="Void"/></f></deinit>
		<bg public="1" set="method" line="123" override="1"><f a="ev">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></bg>
		<readInt public="1" set="method" line="125" override="1">
			<f a="?timeout" v="-1">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<meta><m n=":value"><e>{ timeout : -1 }</e></m></meta>
		</readInt>
		<readChar public="1" set="method" line="144" override="1">
			<f a="?timeout" v="-1">
				<x path="Float"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ timeout : -1 }</e></m></meta>
		</readChar>
		<readChars public="1" set="method" line="163" override="1">
			<f a="num:?timeout:?echo:?echoOutput:?showCursor" v=":-1:&quot;/&quot;::false">
				<x path="Int"/>
				<x path="Float"/>
				<c path="String"/>
				<c path="globals.Output"/>
				<x path="Bool"/>
				<c path="String"/>
			</f>
			<meta><m n=":value"><e>{ showCursor : false, echo : "/", timeout : -1 }</e></m></meta>
		</readChars>
		<dataread public="1" set="method" line="202" override="1"><f a=""><c path="String"/></f></dataread>
		<datawrite public="1" set="method" line="206" override="1"><f a="s">
	<c path="String"/>
	<x path="Void"/>
</f></datawrite>
		<new public="1" set="method" line="114"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="kernel.hooks.CCTermHook" params="" file="src/kernel/hooks/CCTermHook.hx">
		<extends path="kernel.Hook"/>
		<init public="1" set="method" line="211" override="1"><f a=""><x path="Void"/></f></init>
		<deinit public="1" set="method" line="216" override="1"><f a=""><x path="Void"/></f></deinit>
		<bg public="1" set="method" line="220" override="1"><f a="ev">
	<c path="Array"><d/></c>
	<x path="Void"/>
</f></bg>
		<new public="1" set="method" line="210"><f a=""><x path="Void"/></f></new>
		<meta><m n=":directlyUsed"/></meta>
	</class>
	<class path="lua.Boot" params="" file="/usr/share/haxe/std/lua/Boot.hx">
		<__instanceof set="method" line="89" static="1">
			<f a="o:cl">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<meta>
				<m n=":has_untyped"/>
				<m n=":ifFeature"><e>"typed_catch"</e></m>
			</meta>
			<haxe_doc>Indicates if the given object is an instance of the given Type</haxe_doc>
		</__instanceof>
		<isArray set="method" line="130" static="1">
			<f a="o">
				<d/>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</isArray>
		<__cast set="method" line="148" static="1">
			<f a="o:t">
				<d/>
				<d/>
				<d/>
			</f>
			<meta><m n=":ifFeature"><e>"typed_cast"</e></m></meta>
		</__cast>
		<extendsOrImplements public="1" set="method" line="226" static="1">
			<f a="cl1:cl2">
				<x path="Class"><d/></x>
				<x path="Class"><d/></x>
				<x path="Bool"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
			<haxe_doc>Helper method to determine if class cl1 extends, implements, or otherwise equals cl2</haxe_doc>
		</extendsOrImplements>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
			<m n=":dox"><e>hide</e></m>
		</meta>
	</class>
	<class path="lua.Thread" params="" file="/usr/share/haxe/std/lua/Thread.hx">
		<haxe_doc>The sole purpose of this extern is to provide a concrete type for
	basic reflection purposes.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="lua.Coroutine" params="T" file="/usr/share/haxe/std/lua/Coroutine.hx" extern="1">
		<extends path="lua.Thread"/>
		<create public="1" params="T" set="method" static="1">
			<f a="f">
				<c path="create.T"/>
				<c path="lua.Coroutine"><c path="create.T"/></c>
			</f>
			<haxe_doc>Creates a new coroutine, with body `f`. `f` must be a Lua function.</haxe_doc>
		</create>
		<running public="1" set="method" static="1">
			<f a=""><c path="lua.CoroutineRunning"/></f>
			<haxe_doc>Returns the running coroutine plus a boolean, true when the running coroutine is the main one.</haxe_doc>
		</running>
		<status public="1" set="method" static="1">
			<f a="c">
				<c path="lua.Coroutine"><d/></c>
				<x path="lua.CoroutineState"/>
			</f>
			<haxe_doc>Returns the status of coroutine.</haxe_doc>
		</status>
		<resume public="1" params="A:B" set="method" static="1">
			<f a="c:args">
				<c path="lua.Coroutine"><d/></c>
				<t path="haxe.extern.Rest"><c path="resume.A"/></t>
				<c path="lua.CoroutineResume"><c path="resume.B"/></c>
			</f>
			<haxe_doc>Starts or continues the execution of coroutine.
		The first time you resume a coroutine, it starts running its body.
		The values `args` are passed as the arguments to the body function.
		If the coroutine has yielded, `resume` restarts it;
		the values `args` are passed as the results from the yield.

		If the coroutine runs without any errors, `resume` returns `true` plus any
		values passed to `yield` (if the coroutine yields) or any values returned
		by the body function (if the coroutine terminates). If there is any error,
		`resume` returns `false` plus the error message.</haxe_doc>
		</resume>
		<yield public="1" params="T" set="method" static="1">
			<f a="args">
				<t path="haxe.extern.Rest"><d/></t>
				<c path="yield.T"/>
			</f>
			<haxe_doc>Suspends the execution of the calling coroutine.
		The coroutine cannot be running a C function, a metamethod, or an iterator.
		Any arguments to `yield` are passed as extra results to `resume`.</haxe_doc>
		</yield>
		<wrap public="1" params="T" set="method" static="1">
			<f a="f">
				<c path="wrap.T"/>
				<c path="wrap.T"/>
			</f>
			<haxe_doc>Creates a new coroutine, with body `f`.
		Returns a function that resumes the coroutine each time it is called.
		Any arguments passed to the function behave as the extra arguments to `resume`.
		Returns the same values returned by `resume`, except the first boolean.
		In case of error, propagates the error.</haxe_doc>
		</wrap>
		<haxe_doc>Externs for native Lua coroutines.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"_G.coroutine"</e></m>
		</meta>
	</class>
	<abstract path="lua.CoroutineState" params="" file="/usr/share/haxe/std/lua/Coroutine.hx" module="lua.Coroutine">
		<this><c path="String"/></this>
		<haxe_doc>A enumerator that describes the output of `Coroutine.status()`.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua._Coroutine.CoroutineState_Impl_" params="" file="/usr/share/haxe/std/lua/Coroutine.hx" private="1" module="lua.Coroutine" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="lua.CoroutineResume" params="T" file="/usr/share/haxe/std/lua/Coroutine.hx" module="lua.Coroutine" extern="1">
		<success public="1"><x path="Bool"/></success>
		<result public="1"><c path="lua.CoroutineResume.T"/></result>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.CoroutineRunning" params="" file="/usr/share/haxe/std/lua/Coroutine.hx" module="lua.Coroutine" extern="1">
		<coroutine public="1"><c path="lua.Coroutine"><d/></c></coroutine>
		<status public="1"><x path="Bool"/></status>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.Debug" params="" file="/usr/share/haxe/std/lua/Debug.hx" extern="1">
		<getlocal public="1" set="method" static="1">
			<f a="stackLevel:idx">
				<x path="Int"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>This function returns the name and the value of the local variable with
		index local of the function at level level of the stack.</haxe_doc>
		</getlocal>
		<setlocal public="1" set="method" static="1">
			<f a="stackLevel:varName:value">
				<x path="Int"/>
				<c path="String"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>This function assigns the value value to the local variable with index
		local of the function at level level of the stack.
		Call `getinfo` to check whether the level is valid.</haxe_doc>
		</setlocal>
		<getinfo public="1" set="method" static="1">
			<f a="stackLevel">
				<x path="Int"/>
				<t path="lua.DebugInfo"/>
			</f>
			<haxe_doc>Returns a table with information about a function.</haxe_doc>
		</getinfo>
		<sethook public="1" set="method" static="1">
			<f a="?fun:?monitor">
				<x path="haxe.Function"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the given function as a hook.
		When called without arguments, `Debug.sethook` turns off the hook.</haxe_doc>
		</sethook>
		<debug public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Enters an interactive mode with the user, running each string that the user enters.
		Using simple commands and other debug facilities, the user can inspect
		global and local variables, change their values, evaluate expressions,
		and so on. A line containing only the word `cont` finishes this function,
		so that the caller continues its execution.

		Note that commands for `Debug.debug` are not lexically nested within any
		function, and so have no direct access to local variables.</haxe_doc>
		</debug>
		<gethook public="1" set="method" static="1">
			<f a="thread">
				<c path="lua.Thread"/>
				<x path="haxe.Function"/>
			</f>
			<haxe_doc>Returns the current hook settings of the thread, as three values:
		the current hook function, the current hook mask, and the current hook count
		(as set by the `Debug.sethook` function).</haxe_doc>
		</gethook>
		<getregistry public="1" set="method" static="1">
			<f a=""><t path="lua.AnyTable"/></f>
			<haxe_doc>Returns the registry table.</haxe_doc>
		</getregistry>
		<getmetatable public="1" set="method" static="1">
			<f a="value">
				<t path="lua.AnyTable"/>
				<t path="lua.AnyTable"/>
			</f>
			<haxe_doc>Returns the metatable of the given `value` or `null` if it does not have a metatable.</haxe_doc>
		</getmetatable>
		<setmetatable public="1" set="method" static="1">
			<f a="value:table">
				<t path="lua.AnyTable"/>
				<t path="lua.AnyTable"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the metatable for the given `value` to the given `table` (can be `null`).</haxe_doc>
		</setmetatable>
		<getupvalue public="1" set="method" static="1">
			<f a="f:up">
				<x path="haxe.Function"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>This function returns the name and the value of the upvalue with index `up`
		of the function `f`. The function returns `null` if there is no upvalue with
		the given index.</haxe_doc>
		</getupvalue>
		<setupvalue public="1" set="method" static="1">
			<f a="f:up:val">
				<x path="haxe.Function"/>
				<x path="Int"/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>This function assigns the value value to the upvalue with index up of
		the function `f`. The function returns `null` if there is no upvalue with
		the given index. Otherwise, it returns the name of the upvalue.</haxe_doc>
		</setupvalue>
		<getuservalue public="1" set="method" static="1">
			<f a="val">
				<d/>
				<d/>
			</f>
			<haxe_doc>Returns the Lua value associated to `val`.
		If `val` is not a `UserData`, returns `null`.</haxe_doc>
		</getuservalue>
		<setuservalue public="1" set="method" static="1">
			<f a="udata:val">
				<d/>
				<d/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the given value as the Lua value associated to the given udata.
		`udata` must be a full `UserData`.</haxe_doc>
		</setuservalue>
		<traceback public="1" set="method" static="1">
			<f a="?thread:?message:?level">
				<c path="lua.Thread"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns a string with a traceback of the call stack.
		@param message (optional) is appended at the beginning of the traceback.
		@param level (optional) tells at which level to start the traceback.
			   default is `1`, the function calling traceback.</haxe_doc>
		</traceback>
		<upvalueid public="1" set="method" static="1">
			<f a="f:n">
				<x path="haxe.Function"/>
				<x path="Int"/>
				<d/>
			</f>
			<haxe_doc>Returns a unique identifier (as a light userdata) for the upvalue numbered
		`n` from the given function `f`.</haxe_doc>
		</upvalueid>
		<upvaluejoin public="1" set="method" static="1">
			<f a="f1:n1:f2:n2">
				<x path="haxe.Function"/>
				<x path="Int"/>
				<x path="haxe.Function"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Make the `n1`-th upvalue of the Lua closure `f1` refer to the `n2`-th
		upvalue of the Lua closure `f2`.</haxe_doc>
		</upvaluejoin>
		<haxe_doc>Externs for the "debug" class for Haxe lua</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"debug"</e></m>
		</meta>
	</class>
	<typedef path="lua.DebugInfo" params="" file="/usr/share/haxe/std/lua/Debug.hx" module="lua.Debug">
		<a>
			<what><c path="String"/></what>
			<source><c path="String"/></source>
			<short_src><c path="String"/></short_src>
			<nups><x path="Int"/></nups>
			<nparams><x path="Int"/></nparams>
			<namewhat><c path="String"/></namewhat>
			<name><c path="String"/></name>
			<linedefined><x path="Int"/></linedefined>
			<lastlinedefined><x path="Int"/></lastlinedefined>
			<isvararg><x path="Bool"/></isvararg>
			<istailcall><x path="Bool"/></istailcall>
			<func><x path="haxe.Function"/></func>
			<currentline><x path="Int"/></currentline>
		</a>
		<haxe_doc>A enumerator that describes the output of `Debug.getinfo()`.</haxe_doc>
	</typedef>
	<class path="lua.UserData" params="" file="/usr/share/haxe/std/lua/UserData.hx"><meta>
	<m n=":keep"/>
	<m n=":directlyUsed"/>
</meta></class>
	<class path="lua.FileHandle" params="" file="/usr/share/haxe/std/lua/FileHandle.hx" extern="1">
		<extends path="lua.UserData"/>
		<flush public="1" set="method"><f a=""><x path="Void"/></f></flush>
		<read public="1" set="method"><f a="arg">
	<t path="haxe.extern.Rest"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<x path="Int"/>
</x></t>
	<c path="String"/>
</f></read>
		<lines public="1" set="method"><f a=""><x path="lua.NativeIterator"><c path="String"/></x></f></lines>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<write public="1" set="method"><f a="str">
	<c path="String"/>
	<x path="Void"/>
</f></write>
		<seek public="1" set="method">
			<f a="arg:pos">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<overloads>
				<seek public="1" set="method"><f a=""><x path="Int"/></f></seek>
				<seek public="1" set="method"><f a="arg">
	<c path="String"/>
	<x path="Int"/>
</f></seek>
			</overloads>
		</seek>
	</class>
	<class path="lua.Io" params="" file="/usr/share/haxe/std/lua/Io.hx" extern="1">
		<stdin public="1" static="1"><c path="lua.FileHandle"/></stdin>
		<stderr public="1" static="1"><c path="lua.FileHandle"/></stderr>
		<stdout public="1" static="1"><c path="lua.FileHandle"/></stdout>
		<close public="1" set="method" static="1">
			<f a="?file">
				<c path="lua.FileHandle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Function to close regular files.</haxe_doc>
		</close>
		<flush public="1" set="method" static="1">
			<f a=""><x path="Void"/></f>
			<haxe_doc>Saves any written data to file.</haxe_doc>
		</flush>
		<input public="1" set="method" static="1">
			<f a="file">
				<c path="lua.FileHandle"/>
				<x path="Void"/>
			</f>
			<haxe_doc>When called with a file name, it opens the named file (in text mode),
		and sets its handle as the default input file. When called with a file handle,
		it simply sets this file handle as the default input file.
		When called without parameters, it returns the current default input file.

		In case of errors this function raises the error, instead of returning an
		error code.</haxe_doc>
			<overloads><input public="1" set="method">
	<f a="file">
		<c path="String"/>
		<x path="Void"/>
	</f>
	<haxe_doc>When called with a file name, it opens the named file (in text mode),
		and sets its handle as the default input file. When called with a file handle,
		it simply sets this file handle as the default input file.
		When called without parameters, it returns the current default input file.

		In case of errors this function raises the error, instead of returning an
		error code.</haxe_doc>
</input></overloads>
		</input>
		<lines public="1" set="method" static="1">
			<f a="?file">
				<c path="String"/>
				<x path="lua.NativeIterator"><c path="String"/></x>
			</f>
			<haxe_doc>Opens the given file name in read mode and returns an iterator function that,
		each time it is called, returns a new line from the file.</haxe_doc>
		</lines>
		<open public="1" set="method" static="1">
			<f a="filename:?mode">
				<c path="String"/>
				<c path="String"/>
				<c path="lua.FileHandle"/>
			</f>
			<haxe_doc>This function opens a file, in the mode specified in the string mode.
		It returns a new file handle, or, in case of errors, `null` plus an error message.

		The mode string can be any of the following:

		* `"r"`: read mode (the default)
		* `"w"`: write mode
		* `"a"`: append mode
		* `"r+"`: update mode, all previous data is preserved
		* `"w+"`: update mode, all previous data is erased
		* `"a+"`: append update mode, previous data is preserved, writing is only
			allowed at the end of file

		The mode string can also have a `b` at the end, which is needed in some systems
		to open the file in binary mode. This string is exactly what is used in the
		standard C function fopen.</haxe_doc>
		</open>
		<popen public="1" set="method" static="1">
			<f a="command:?mode">
				<c path="String"/>
				<c path="String"/>
				<c path="lua.FileHandle"/>
			</f>
			<haxe_doc>Starts program `command` in a separated process and returns a file handle that
		you can use to read data from this program (if mode is `"r"`, the default)
		or to write data to this program (if mode is `"w"`).

		This function is system dependent and is not available on all platforms.</haxe_doc>
		</popen>
		<read public="1" set="method" static="1">
			<f a="?filename">
				<c path="String"/>
				<c path="String"/>
			</f>
			<overloads><read public="1" set="method"><f a="?count">
	<x path="Int"/>
	<c path="String"/>
</f></read></overloads>
		</read>
		<write public="1" set="method" static="1">
			<f a="v">
				<t path="haxe.extern.Rest"><c path="String"/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>Writes the value of each of its arguments to the file. The arguments must
		be strings or numbers.
		To write other values, use `Lua.tostring` or `NativeStringTools.format`
		before write.</haxe_doc>
		</write>
		<output public="1" set="method" static="1"><f a="?file">
	<c path="String"/>
	<c path="lua.FileHandle"/>
</f></output>
		<tmpfile public="1" set="method" static="1">
			<f a=""><c path="lua.FileHandle"/></f>
			<haxe_doc>Returns a handle for a temporary file. This file is opened in update mode
		and it is automatically removed when the program ends.</haxe_doc>
		</tmpfile>
		<type public="1" set="method" static="1">
			<f a="obj">
				<c path="lua.FileHandle"/>
				<x path="lua.IoType"/>
			</f>
			<haxe_doc>Checks whether `obj` is a valid file handle.</haxe_doc>
		</type>
		<haxe_doc>Input and Output Facilities</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"_G.io"</e></m>
		</meta>
	</class>
	<abstract path="lua.IoType" params="" file="/usr/share/haxe/std/lua/Io.hx" module="lua.Io">
		<this><c path="String"/></this>
		<to><icast field="toString"><c path="String"/></icast></to>
		<haxe_doc>A enumerator that describes the output of `Io.type()`.</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua._Io.IoType_Impl_" params="" file="/usr/share/haxe/std/lua/Io.hx" private="1" module="lua.Io" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="lua.LocaleCategory" params="" file="/usr/share/haxe/std/lua/LocaleCategory.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua._LocaleCategory.LocaleCategory_Impl_" params="" file="/usr/share/haxe/std/lua/LocaleCategory.hx" private="1" module="lua.LocaleCategory" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="lua.Lua" params="" file="/usr/share/haxe/std/lua/Lua.hx" extern="1">
		<_VERSION public="1" static="1">
			<c path="String"/>
			<haxe_doc>A global variable that holds a string containing the current interpreter
		version.</haxe_doc>
		</_VERSION>
		<arg public="1" static="1"><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></arg>
		<getmetatable public="1" set="method" static="1">
			<f a="tbl">
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
			</f>
			<haxe_doc>Pushes onto the stack the metatable in the registry.</haxe_doc>
		</getmetatable>
		<setmetatable public="1" set="method" static="1">
			<f a="tbl:mtbl">
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
			</f>
			<haxe_doc>Pops a table from the stack and sets it as the new metatable for the value
		at the given acceptable index.</haxe_doc>
		</setmetatable>
		<setfenv public="1" set="method" static="1">
			<f a="i:tbl">
				<x path="Int"/>
				<c path="lua.Table">
					<d/>
					<d/>
				</c>
				<x path="Void"/>
			</f>
			<haxe_doc>Pops a table from the stack and sets it as the new environment for the value
		at the given index. If the value at the given index is neither a function nor
		a thread nor a userdata, lua_setfenv returns `0`.
		Otherwise it returns `1`.</haxe_doc>
		</setfenv>
		<next public="1" params="K:V" set="method" static="1">
			<f a="k:?i">
				<c path="lua.Table">
					<c path="next.K"/>
					<c path="next.V"/>
				</c>
				<c path="next.K"/>
				<c path="lua.NextResult">
					<c path="next.K"/>
					<c path="next.V"/>
				</c>
			</f>
			<haxe_doc>Allows a program to traverse all fields of a table.
		Its first argument is a table and its second argument is an index in this
		table. `next` returns the next index of the table and its associated value.
		When `i` is `null`, `next` returns an initial index and its associated value.
		When called with the last index, or with `null` in an empty table, `next`
		returns `null`.  In particular, you can use `next(t)` to check whether a
		table is empty.

		The order in which the indices are enumerated is not specified, even for
		numeric indices. (To traverse a table in numeric order, use a numerical for
		or the `ipairs` function).

		The behavior of next is undefined if, during the traversal, any value
		to a non-existent field in the table is assigned. Existing fields may
		however be modified. In particular, existing fields may be cleared.</haxe_doc>
		</next>
		<tostring public="1" set="method" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Receives an argument of any type and converts it to a string in a reasonable
		format.

		For complete control of how numbers are converted, use`NativeStringTools.format`.</haxe_doc>
		</tostring>
		<ipairs public="1" params="K:V" set="method" static="1"><f a="t">
	<c path="lua.Table">
		<c path="ipairs.K"/>
		<c path="ipairs.V"/>
	</c>
	<c path="lua.IPairsResult">
		<c path="ipairs.K"/>
		<c path="ipairs.V"/>
	</c>
</f></ipairs>
		<pairs public="1" params="K:V" set="method" static="1"><f a="t">
	<c path="lua.Table">
		<c path="pairs.K"/>
		<c path="pairs.V"/>
	</c>
	<c path="lua.PairsResult">
		<c path="pairs.K"/>
		<c path="pairs.V"/>
	</c>
</f></pairs>
		<require public="1" set="method" static="1"><f a="module">
	<c path="String"/>
	<d/>
</f></require>
		<tonumber public="1" set="method" static="1">
			<f a="str:?base">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Converts the Lua value at the given acceptable base to `Int`.
		The Lua value must be a number or a string convertible to a number,
		otherwise `tonumber` returns `0`.</haxe_doc>
		</tonumber>
		<type public="1" set="method" static="1">
			<f a="v">
				<d/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the Lua type of its only argument as a string.
		The possible results of this function are:

		* `"nil"` (a string, not the Lua value nil),
		* `"number"`
		* `"string"`
		* `"boolean"`
		* `"table"`
		* `"function"`
		* `"thread"`
		* `"userdata"`</haxe_doc>
		</type>
		<print public="1" set="method" static="1">
			<f a="v">
				<t path="haxe.extern.Rest"><d/></t>
				<x path="Void"/>
			</f>
			<haxe_doc>Receives any number of arguments, and prints their values to stdout,
		using the tostring function to convert them to strings.
		`print` is not intended for formatted output, but only as a quick way to show
		a value, typically for debugging.

		For complete control of how numbers are converted, use `NativeStringTools.format`.</haxe_doc>
		</print>
		<select public="1" set="method" static="1">
			<f a="n:rest">
				<d/>
				<t path="haxe.extern.Rest"><d/></t>
				<d/>
			</f>
			<haxe_doc>If `n` is a number, returns all arguments after argument number `n`.
		Otherwise, `n` must be the string `"#"`, and select returns the total
		number of extra arguments it received.</haxe_doc>
		</select>
		<rawget public="1" params="K:V" set="method" static="1">
			<f a="t:k">
				<c path="lua.Table">
					<c path="rawget.K"/>
					<c path="rawget.V"/>
				</c>
				<c path="rawget.K"/>
				<c path="rawget.V"/>
			</f>
			<haxe_doc>Gets the real value of `table[index]`, without invoking any metamethod.</haxe_doc>
		</rawget>
		<rawset public="1" params="K:V" set="method" static="1">
			<f a="t:k:v">
				<c path="lua.Table">
					<c path="rawset.K"/>
					<c path="rawset.V"/>
				</c>
				<c path="rawset.K"/>
				<c path="rawset.V"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Sets the real value of `table[index]` to value, without invoking any metamethod.</haxe_doc>
		</rawset>
		<collectgarbage public="1" set="method" static="1">
			<f a="opt:?arg">
				<x path="lua.CollectGarbageOption"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>This function is a generic interface to the garbage collector.
		It performs different functions according to its first argument.</haxe_doc>
		</collectgarbage>
		<assert public="1" params="T" set="method" static="1">
			<f a="v:?message">
				<c path="assert.T"/>
				<c path="String"/>
				<c path="assert.T"/>
			</f>
			<haxe_doc>Issues an error when the value of its argument `v` is `false` (i.e., `null`
		or `false`) otherwise, returns all its arguments. message is an error message.
		when absent, it defaults to "assertion failed!"</haxe_doc>
		</assert>
		<dofile public="1" set="method" static="1">
			<f a="filename">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Loads and runs the given file.</haxe_doc>
		</dofile>
		<error public="1" set="method" static="1">
			<f a="message:?level">
				<c path="String"/>
				<x path="Int"/>
				<x path="Void"/>
			</f>
			<haxe_doc>Generates a Lua error. The error message (which can actually be a Lua value
		of any type) must be on the stack top. This function does a long jump,
		and therefore never returns.</haxe_doc>
		</error>
		<pcall public="1" set="method" static="1">
			<f a="f:rest">
				<x path="haxe.Function"/>
				<t path="haxe.extern.Rest"><d/></t>
				<c path="lua.PCallResult"/>
			</f>
			<haxe_doc>Calls a function in protected mode.</haxe_doc>
		</pcall>
		<rawequal public="1" set="method" static="1">
			<f a="v1:v2">
				<d/>
				<d/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Returns `true` if the two values in acceptable indices `v1` and `v2` are
		primitively equal (that is, without calling metamethods).
		Otherwise returns `false`.
		Also returns `false` if any of the indices are non valid.</haxe_doc>
		</rawequal>
		<xpcall public="1" set="method" static="1">
			<f a="f:msgh:rest">
				<x path="haxe.Function"/>
				<x path="haxe.Function"/>
				<t path="haxe.extern.Rest"><d/></t>
				<c path="lua.PCallResult"/>
			</f>
			<haxe_doc>This function is similar to pcall, except that you can set a new error
		handler.</haxe_doc>
		</xpcall>
		<loadfile public="1" set="method" static="1">
			<f a="filename">
				<c path="String"/>
				<c path="lua.LoadResult"/>
			</f>
			<haxe_doc>Loads the chunk from file filename or from the standard input if no filename
		is given.</haxe_doc>
		</loadfile>
		<load public="1" set="method" static="1">
			<f a="code">
				<x path="haxe.extern.EitherType">
					<c path="String"/>
					<f a=""><c path="String"/></f>
				</x>
				<c path="lua.LoadResult"/>
			</f>
			<haxe_doc>Loads the chunk from given string.</haxe_doc>
		</load>
		<haxe_doc>These are all global static methods within Lua.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"_G"</e></m>
		</meta>
	</class>
	<abstract path="lua.CollectGarbageOption" params="" file="/usr/share/haxe/std/lua/Lua.hx" module="lua.Lua">
		<this><c path="String"/></this>
		<haxe_doc>Enum for describing garbage collection options</haxe_doc>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua._Lua.CollectGarbageOption_Impl_" params="" file="/usr/share/haxe/std/lua/Lua.hx" private="1" module="lua.Lua" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="lua.PCallResult" params="" file="/usr/share/haxe/std/lua/Lua.hx" module="lua.Lua" extern="1">
		<status public="1"><x path="Bool"/></status>
		<value public="1"><d/></value>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.NextResult" params="K:V" file="/usr/share/haxe/std/lua/Lua.hx" module="lua.Lua" extern="1">
		<index public="1"><c path="lua.NextResult.K"/></index>
		<value public="1"><c path="lua.NextResult.V"/></value>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.IPairsResult" params="K:V" file="/usr/share/haxe/std/lua/Lua.hx" module="lua.Lua" extern="1">
		<next public="1"><f a=":">
	<c path="lua.Table">
		<c path="lua.IPairsResult.K"/>
		<c path="lua.IPairsResult.V"/>
	</c>
	<x path="Int"/>
	<c path="lua.NextResult">
		<x path="Int"/>
		<c path="lua.IPairsResult.V"/>
	</c>
</f></next>
		<table public="1"><c path="lua.Table">
	<c path="lua.IPairsResult.K"/>
	<c path="lua.IPairsResult.V"/>
</c></table>
		<index public="1"><x path="Int"/></index>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.PairsResult" params="K:V" file="/usr/share/haxe/std/lua/Lua.hx" module="lua.Lua" extern="1">
		<next public="1"><f a=":">
	<c path="lua.Table">
		<c path="lua.PairsResult.K"/>
		<c path="lua.PairsResult.V"/>
	</c>
	<c path="lua.PairsResult.K"/>
	<c path="lua.NextResult">
		<c path="lua.PairsResult.K"/>
		<c path="lua.PairsResult.V"/>
	</c>
</f></next>
		<table public="1"><c path="lua.Table">
	<c path="lua.PairsResult.K"/>
	<c path="lua.PairsResult.V"/>
</c></table>
		<index public="1"><c path="lua.PairsResult.K"/></index>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.LoadResult" params="" file="/usr/share/haxe/std/lua/Lua.hx" module="lua.Lua" extern="1">
		<func public="1"><x path="haxe.Function"/></func>
		<message public="1"><c path="String"/></message>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.Math" params="" file="/usr/share/haxe/std/lua/Math.hx" extern="1">
		<pi public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>The value of pi.</haxe_doc>
		</pi>
		<huge public="1" set="null" static="1">
			<x path="Float"/>
			<haxe_doc>The value HUGE_VAL, a value larger than or equal to any other numerical value.</haxe_doc>
		</huge>
		<abs public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the absolute value of x.</haxe_doc>
		</abs>
		<ceil public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the smallest integer larger than or equal to x.</haxe_doc>
		</ceil>
		<floor public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the largest integer smaller than or equal to x.</haxe_doc>
		</floor>
		<acos public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the arc cosine of x (in radians).</haxe_doc>
		</acos>
		<asin public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the arc sine of x (in radians).</haxe_doc>
		</asin>
		<atan public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the arc tangent of x (in radians).</haxe_doc>
		</atan>
		<atan2 public="1" set="method" static="1">
			<f a="y:x">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the arc tangent of y/x (in radians), but uses the signs of both parameters to find the quadrant of the result.
		(It also handles correctly the case of x being zero.)</haxe_doc>
		</atan2>
		<cos public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the cosine of x (assumed to be in radians).</haxe_doc>
		</cos>
		<cosh public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the hyperbolic cosine of x.</haxe_doc>
		</cosh>
		<sin public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the sine of x (assumed to be in radians).</haxe_doc>
		</sin>
		<sinh public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the hyperbolic sine of x.</haxe_doc>
		</sinh>
		<tan public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the tangent of x (assumed to be in radians)</haxe_doc>
		</tan>
		<tanh public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the hyperbolic tangent of x.</haxe_doc>
		</tanh>
		<rad public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the angle x (given in degrees) in radians.</haxe_doc>
		</rad>
		<modf public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns two numbers, the integral part of x and the fractional part of x.</haxe_doc>
		</modf>
		<fmod public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the remainder of the division of x by y that rounds the quotient towards zero.</haxe_doc>
		</fmod>
		<pow public="1" set="method" static="1">
			<f a="x:y">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns y-th power of x.</haxe_doc>
		</pow>
		<sqrt public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the square root of x.</haxe_doc>
		</sqrt>
		<exp public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the value e^x.</haxe_doc>
		</exp>
		<frexp public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<c path="lua.MathFrexpResult"/>
			</f>
			<haxe_doc>Returns m and e such that x = m2^e, e is an integer and the absolute value of m is in the range [0.5, 1) (or zero when x is zero).</haxe_doc>
		</frexp>
		<ldexp public="1" set="method" static="1">
			<f a="m:e">
				<x path="Float"/>
				<x path="Int"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns m2^e (e should be an integer).</haxe_doc>
		</ldexp>
		<log public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the natural logarithm of x.</haxe_doc>
		</log>
		<log10 public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the base-10 logarithm of x.</haxe_doc>
		</log10>
		<max public="1" set="method" static="1">
			<f a="x:numbers">
				<x path="Float"/>
				<t path="haxe.extern.Rest"><x path="Float"/></t>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the maximum value among its arguments.</haxe_doc>
		</max>
		<min public="1" set="method" static="1">
			<f a="x:numbers">
				<x path="Float"/>
				<t path="haxe.extern.Rest"><x path="Float"/></t>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the minimum value among its arguments.</haxe_doc>
		</min>
		<deg public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the angle x (given in radians) in degrees.</haxe_doc>
		</deg>
		<random public="1" set="method" static="1">
			<f a="?m:?n">
				<x path="Float"/>
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>This function is an interface to the simple pseudo-random generator function rand provided by ANSI C.
		(No guarantees can be given for its statistical properties.)

		When called without arguments, returns a uniform pseudo-random real number in the range [0,1).
		When called with an integer number `m`, returns a uniform pseudo-random integer in the range [1, m].
		When called with two integer numbers `m` and `n`, returns a uniform pseudo-random integer in the range [m, n].</haxe_doc>
		</random>
		<randomseed public="1" set="method" static="1">
			<f a="x">
				<x path="Float"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Sets `x` as the "seed" for the pseudo-random generator: equal seeds produce equal sequences of numbers.</haxe_doc>
		</randomseed>
		<haxe_doc>Mathematical Functions</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"_G.math"</e></m>
		</meta>
	</class>
	<class path="lua.MathFrexpResult" params="" file="/usr/share/haxe/std/lua/Math.hx" module="lua.Math" extern="1">
		<m public="1"><x path="Float"/></m>
		<e public="1"><x path="Int"/></e>
		<haxe_doc>The return value of `Math.frexp`.</haxe_doc>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<abstract path="lua.NativeIterator" params="T" file="/usr/share/haxe/std/lua/NativeIterator.hx">
		<from><icast field="fromF"><f a=""><c path="fromF.T"/></f></icast></from>
		<this><f a=""><c path="lua.NativeIterator.T"/></f></this>
		<to><icast field="toIterator"><a>
	<next set="method">
		<f a=""><c path="lua.NativeIterator.T"/></f>
		<haxe_doc>Returns the current item of the `Iterator` and advances to the next one.

		This method is not required to check `hasNext()` first. A call to this
		method while `hasNext()` is `false` yields unspecified behavior.

		On the other hand, iterators should not require a call to `hasNext()`
		before the first call to `next()` if an element is available.</haxe_doc>
	</next>
	<hasNext set="method">
		<f a=""><x path="Bool"/></f>
		<haxe_doc>Returns `false` if the iteration is complete, `true` otherwise.

		Usually iteration is considered to be complete if all elements of the
		underlying data structure were handled through calls to `next()`. However,
		in custom iterators any logic may be used to determine the completion
		state.</haxe_doc>
	</hasNext>
</a></icast></to>
		<haxe_doc>This abstract enables easy conversion from basic lua iterators
	(i.e., a function that is called until it returns null), and
	Haxe iterators, which provide a next/hasNext interface.</haxe_doc>
		<meta><m n=":callable"/></meta>
		<impl><class path="lua._NativeIterator.NativeIterator_Impl_" params="" file="/usr/share/haxe/std/lua/NativeIterator.hx" private="1" module="lua.NativeIterator" final="1"><meta><m n=":keep"/></meta></class></impl>
	</abstract>
	<class path="lua.StringFind" params="" file="/usr/share/haxe/std/lua/NativeStringTools.hx" module="lua.NativeStringTools" extern="1">
		<begin public="1"><x path="Int"/></begin>
		<end public="1"><x path="Int"/></end>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.StringSub" params="" file="/usr/share/haxe/std/lua/NativeStringTools.hx" module="lua.NativeStringTools" extern="1">
		<match public="1"><c path="String"/></match>
		<count public="1"><x path="Int"/></count>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.Os" params="" file="/usr/share/haxe/std/lua/Os.hx" extern="1">
		<clock public="1" set="method" static="1">
			<f a=""><x path="Float"/></f>
			<haxe_doc>Returns an approximation of the amount in seconds of CPU time used by the
		program.</haxe_doc>
		</clock>
		<date public="1" set="method" static="1">
			<f a=""><t path="lua.DateType"/></f>
			<overloads>
				<date public="1" set="method"><f a="format:time">
	<c path="String"/>
	<t path="lua.Time"/>
	<t path="lua.DateType"/>
</f></date>
				<date public="1" set="method"><f a="format">
	<c path="String"/>
	<t path="lua.DateType"/>
</f></date>
			</overloads>
		</date>
		<difftime public="1" set="method" static="1">
			<f a="t2:t1">
				<t path="lua.Time"/>
				<t path="lua.Time"/>
				<x path="Float"/>
			</f>
			<haxe_doc>Returns the number of seconds from time `t1` to time `t2`.
		In POSIX, Windows, and some other systems, this value is exactly `t2-t1`.</haxe_doc>
		</difftime>
		<execute public="1" set="method" static="1">
			<f a="?command">
				<c path="String"/>
				<d/>
			</f>
			<haxe_doc>This function is equivalent to the C function system. It passes command to
		be executed by an operating system shell. It returns a status code,
		which is system-dependent. If command is absent, then it returns
		nonzero if a shell is available and zero otherwise.</haxe_doc>
		</execute>
		<exit public="1" set="method" static="1">
			<f a="code">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Calls the C function exit, with an optional code, to terminate the host program.
		The default value for code is the success code.</haxe_doc>
		</exit>
		<getenv public="1" set="method" static="1">
			<f a="varname">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Returns the value of the process environment variable `varname`, or `null`
		if the variable is not defined.</haxe_doc>
		</getenv>
		<remove public="1" set="method" static="1">
			<f a="filename">
				<c path="String"/>
				<c path="lua.OsSuccess"/>
			</f>
			<haxe_doc>Deletes the file or directory with the given name.
		Directories must be empty to be removed.</haxe_doc>
		</remove>
		<rename public="1" set="method" static="1">
			<f a="oldname:newname">
				<c path="String"/>
				<c path="String"/>
				<c path="lua.OsSuccess"/>
			</f>
			<haxe_doc>Renames file or directory named `oldname` to `newname`.</haxe_doc>
		</rename>
		<setlocale public="1" set="method" static="1">
			<f a="locale:?category">
				<c path="String"/>
				<x path="lua.LocaleCategory"/>
				<c path="String"/>
			</f>
			<haxe_doc>Sets the current locale of the program.</haxe_doc>
		</setlocale>
		<time public="1" set="method" static="1">
			<f a="?arg">
				<x path="Null"><t path="lua.TimeParam"/></x>
				<t path="lua.Time"/>
			</f>
			<haxe_doc>Returns the current time when called without arguments, or a time
		representing the date and time specified by the given table.

		The returned value is a number, whose meaning depends on your system.
		In POSIX, Windows, and some other systems, this number counts the number
		of seconds since some given start time (the "epoch").
		In other systems, the meaning is not specified, and the number returned
		by time can be used only as an argument to date and difftime.</haxe_doc>
		</time>
		<tmpname public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<haxe_doc>Returns a string with a file name that can be used for a temporary file.
		The file must be explicitly opened before its use and explicitly removed
		when no longer needed.

		When possible, you may prefer to use `Io.tmpfile`, which automatically
		removes the file when the program ends.</haxe_doc>
		</tmpname>
		<haxe_doc>Operating System Facilities.</haxe_doc>
		<meta><m n=":native"><e>"_G.os"</e></m></meta>
	</class>
	<typedef path="lua.TimeParam" params="" file="/usr/share/haxe/std/lua/Os.hx" module="lua.Os">
		<a>
			<year><x path="Int"/></year>
			<sec>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
			</sec>
			<month><x path="Int"/></month>
			<min>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
			</min>
			<isdst>
				<x path="Null"><x path="Bool"/></x>
				<meta><m n=":optional"/></meta>
			</isdst>
			<hour>
				<x path="Null"><x path="Int"/></x>
				<meta><m n=":optional"/></meta>
			</hour>
			<day><x path="Int"/></day>
		</a>
		<haxe_doc>A typedef that matches the date parameter `Os.time()` will accept.</haxe_doc>
	</typedef>
	<typedef path="lua.DateType" params="" file="/usr/share/haxe/std/lua/Os.hx" module="lua.Os">
		<a>
			<year><x path="Int"/></year>
			<yday><x path="Int"/></yday>
			<wday><x path="Int"/></wday>
			<sec><x path="Int"/></sec>
			<month><x path="Int"/></month>
			<min><x path="Int"/></min>
			<isdst><x path="Bool"/></isdst>
			<hour><x path="Int"/></hour>
			<day><x path="Int"/></day>
		</a>
		<haxe_doc>A typedef that describes the output of `Os.date()`.</haxe_doc>
	</typedef>
	<class path="lua.OsExecute" params="" file="/usr/share/haxe/std/lua/Os.hx" module="lua.Os" extern="1">
		<success public="1"><x path="Bool"/></success>
		<output public="1"><c path="String"/></output>
		<status public="1"><x path="Int"/></status>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.OsSuccess" params="" file="/usr/share/haxe/std/lua/Os.hx" module="lua.Os" extern="1">
		<success public="1"><x path="Bool"/></success>
		<message public="1"><c path="String"/></message>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.PairTools" params="" file="/usr/share/haxe/std/lua/PairTools.hx">
		<pairsFold public="1" params="A:B:C" set="method" line="54" static="1">
			<f a="table:func:seed">
				<c path="lua.Table">
					<c path="pairsFold.A"/>
					<c path="pairsFold.B"/>
				</c>
				<f a="::">
					<c path="pairsFold.A"/>
					<c path="pairsFold.B"/>
					<c path="pairsFold.C"/>
					<c path="pairsFold.C"/>
				</f>
				<c path="pairsFold.C"/>
				<c path="pairsFold.C"/>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</pairsFold>
		<copy public="1" params="A:B" set="method" line="87" static="1">
			<f a="table1">
				<c path="lua.Table">
					<c path="copy.A"/>
					<c path="copy.B"/>
				</c>
				<c path="lua.Table">
					<c path="copy.A"/>
					<c path="copy.B"/>
				</c>
			</f>
			<meta><m n=":has_untyped"/></meta>
		</copy>
		<haxe_doc>A set of utility methods for working with the Lua table extern.</haxe_doc>
		<meta>
			<m n=":keep"/>
			<m n=":directlyUsed"/>
		</meta>
	</class>
	<class path="lua.Result" params="T" file="/usr/share/haxe/std/lua/Result.hx" extern="1">
		<result public="1"><c path="lua.Result.T"/></result>
		<message public="1"><c path="String"/></message>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<typedef path="lua.AnyTable" params="" file="/usr/share/haxe/std/lua/Table.hx" module="lua.Table"><c path="lua.Table">
	<d/>
	<d/>
</c></typedef>
	<class path="lua.TableTools" params="" file="/usr/share/haxe/std/lua/TableTools.hx" extern="1">
		<pack public="1" params="T" set="method" static="1"><f a="args">
	<t path="haxe.extern.Rest"><c path="pack.T"/></t>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="pack.T"/>
	</c>
</f></pack>
		<unpack public="1" params="Int:V" set="method" static="1"><f a="args:?min:?max">
	<c path="lua.Table">
		<c path="unpack.Int"/>
		<c path="unpack.V"/>
	</c>
	<c path="unpack.Int"/>
	<c path="unpack.Int"/>
	<d/>
</f></unpack>
		<maxn public="1" set="method" static="1"><f a="t">
	<t path="lua.AnyTable"/>
	<x path="Int"/>
</f></maxn>
		<haxe_doc>This library is an extern for a polyfill library of common lua table
    methods.</haxe_doc>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":native"><e>"_hx_table"</e></m>
		</meta>
	</class>
	<typedef path="lua.Time" params="" file="/usr/share/haxe/std/lua/Time.hx"><x path="Float"/></typedef>
	<class path="lua.lib.luautf8.Utf8" params="" file="/usr/share/haxe/std/lua/lib/luautf8/Utf8.hx" extern="1">
		<len public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Receives a string and returns its length. The empty string `""` has
		length `0`. Embedded zeros are counted, so `"a\000bc\000"` has length `5`.</haxe_doc>
		</len>
		<char public="1" set="method" static="1">
			<f a="codes">
				<t path="haxe.extern.Rest"><x path="Int"/></t>
				<c path="String"/>
			</f>
			<haxe_doc>Receives zero or more integers. Returns a string with length equal to the
		number of arguments, in which each character has the internal numerical
		code equal to its corresponding argument.
		Note that numerical codes are not necessarily portable across platforms.</haxe_doc>
		</char>
		<sub public="1" set="method" static="1">
			<f a="str:start:?end">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="lua.lib.luautf8.StringSub"/>
			</f>
			<haxe_doc>Returns the substring of `str` that starts at `start` and continues until `end`;
		`start` and `end` can be negative. If `end` is absent, then it is assumed to be
		equal to `-1` (which is the same as the string length).
		In particular, the call `sub(str,1,end)` returns a prefix of `str`
		with length `end`, and `sub(str, -end)` returns a suffix of `str` with
		length `start`.</haxe_doc>
		</sub>
		<find public="1" set="method" static="1">
			<f a="str:target:?start:?plain">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
				<c path="lua.lib.luautf8.StringFind"/>
			</f>
			<haxe_doc>Looks for the first match of pattern in the string `str`.
		If it finds a match, then `find` returns the indices of `str` where this
		occurrence starts and ends.

		@param target If the target has captures, then in a successful match the
			   captured values are also returned, after the two indices.
		@param start specifies where to start the search; its default value is `1`
			   and can be negative.
		@param plain turns off the pattern matching facilities, so the function does
			   a plain "find substring" operation, with no characters in pattern
			   being considered "magic". Note that if plain is given, then `start` must be given as well.</haxe_doc>
		</find>
		<byte public="1" set="method" static="1">
			<f a="str:?index">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<haxe_doc>Returns the internal numerical codes of the characters `str[index]`.
		Note that numerical codes are not necessarily portable across platforms.</haxe_doc>
		</byte>
		<gsub public="1" set="method" static="1">
			<f a="str:pattern:replace:?n">
				<c path="String"/>
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc></haxe_doc>
			<overloads>
				<gsub public="1" set="method">
					<f a="str:pattern:replace:?n">
						<c path="String"/>
						<c path="String"/>
						<f a="">
							<c path="String"/>
							<x path="Void"/>
						</f>
						<x path="Int"/>
						<c path="String"/>
					</f>
					<haxe_doc></haxe_doc>
				</gsub>
				<gsub public="1" set="method">
					<f a="str:pattern:replace:?n">
						<c path="String"/>
						<c path="String"/>
						<f a="">
							<c path="String"/>
							<c path="String"/>
						</f>
						<x path="Int"/>
						<c path="String"/>
					</f>
					<haxe_doc></haxe_doc>
				</gsub>
			</overloads>
		</gsub>
		<gmatch public="1" set="method" static="1">
			<f a="str:pattern">
				<c path="String"/>
				<c path="String"/>
				<f a=""><c path="String"/></f>
			</f>
			<haxe_doc>Returns an iterator function that, each time it is called, returns the next
		captures from pattern over string `str`. If `pattern` specifies no captures,
		then the whole match is produced in each call.</haxe_doc>
			<overloads><gmatch public="1" set="method">
	<f a="str:pattern:match:?n">
		<c path="String"/>
		<c path="String"/>
		<f a=""><c path="String"/></f>
		<x path="Int"/>
		<f a="">
			<c path="String"/>
			<x path="Void"/>
		</f>
	</f>
	<haxe_doc>Returns an iterator function that, each time it is called, returns the next
		captures from pattern over string `str`. If `pattern` specifies no captures,
		then the whole match is produced in each call.</haxe_doc>
</gmatch></overloads>
		</gmatch>
		<match public="1" set="method" static="1">
			<f a="str:pattern:?n">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="String"/>
			</f>
			<haxe_doc>Looks for the first match of pattern in the string s. If it finds one,
		then match returns the captures from the pattern; otherwise it returns `null`.
		If pattern specifies no captures, then the whole match is returned.
		The optional argument `n` specifies where to start the search;
		its default value is `1` and can be negative.</haxe_doc>
		</match>
		<upper public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Receives a string and returns a copy of this string with all lowercase
		letters changed to uppercase. All other characters are left unchanged.
		The definition of what a lowercase letter is depends on the current locale.</haxe_doc>
		</upper>
		<lower public="1" set="method" static="1">
			<f a="str">
				<c path="String"/>
				<c path="String"/>
			</f>
			<haxe_doc>Receives a string and returns a copy of this string with all uppercase
		letters changed to lowercase. All other characters are left unchanged.
		The definition of what an uppercase letter is depends on the current locale.</haxe_doc>
		</lower>
		<codes public="1" set="method" static="1"><f a="str">
	<c path="String"/>
	<f a=":">
		<c path="String"/>
		<x path="Int"/>
		<c path="lua.lib.luautf8.StringCodePoint"/>
	</f>
</f></codes>
		<haxe_doc>These are all externs for the lua-utf8 library, which functions
	as an additional set of string tools.

	Note that all relevant indexes are "1" based.</haxe_doc>
		<meta><m n=":luaRequire"><e>"lua-utf8"</e></m></meta>
	</class>
	<class path="lua.lib.luautf8.StringFind" params="" file="/usr/share/haxe/std/lua/lib/luautf8/Utf8.hx" module="lua.lib.luautf8.Utf8" extern="1">
		<begin public="1"><x path="Int"/></begin>
		<end public="1"><x path="Int"/></end>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.lib.luautf8.StringSub" params="" file="/usr/share/haxe/std/lua/lib/luautf8/Utf8.hx" module="lua.lib.luautf8.Utf8" extern="1">
		<match public="1"><c path="String"/></match>
		<count public="1"><x path="Int"/></count>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.lib.luautf8.StringCodePoint" params="" file="/usr/share/haxe/std/lua/lib/luautf8/Utf8.hx" module="lua.lib.luautf8.Utf8" extern="1">
		<position public="1"><x path="Int"/></position>
		<codepoint public="1"><x path="Int"/></codepoint>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.lib.luv.Handle" params="" file="/usr/share/haxe/std/lua/lib/luv/Handle.hx" extern="1">
		<is_active public="1" set="method"><f a=""><x path="Bool"/></f></is_active>
		<is_closing public="1" set="method"><f a=""><x path="Bool"/></f></is_closing>
		<close public="1" set="method"><f a=""><x path="Void"/></f></close>
		<ref public="1" set="method"><f a=""><x path="Void"/></f></ref>
		<unref public="1" set="method"><f a=""><x path="Void"/></f></unref>
		<has_ref public="1" set="method"><f a=""><x path="Bool"/></f></has_ref>
		<send_buffer_size public="1" set="method"><f a="size">
	<x path="Int"/>
	<x path="Int"/>
</f></send_buffer_size>
		<recv_buffer_size public="1" set="method"><f a="size">
	<x path="Int"/>
	<x path="Int"/>
</f></recv_buffer_size>
		<fileno public="1" set="method"><f a=""><x path="Int"/></f></fileno>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<class path="lua.lib.luv.Loop" params="" file="/usr/share/haxe/std/lua/lib/luv/Loop.hx" extern="1">
		<loop_close public="1" set="method" static="1"><f a=""><x path="Bool"/></f></loop_close>
		<run public="1" set="method" static="1">
			<f a="?mode">
				<c path="String"/>
				<x path="Bool"/>
			</f>
			<haxe_doc>Runs the event loop of libuv.

		Haxe compiler automatically inserts a call to this function at the end of user's code if needed.</haxe_doc>
		</run>
		<loop_alive public="1" set="method" static="1"><f a=""><x path="Bool"/></f></loop_alive>
		<stop public="1" set="method" static="1"><f a=""><x path="Void"/></f></stop>
		<backend_fd public="1" set="method" static="1"><f a=""><x path="Int"/></f></backend_fd>
		<backend_timeout public="1" set="method" static="1"><f a=""><x path="Int"/></f></backend_timeout>
		<now public="1" set="method" static="1"><f a=""><x path="Int"/></f></now>
		<update_time public="1" set="method" static="1"><f a=""><x path="Void"/></f></update_time>
		<walk public="1" set="method" static="1"><f a="cb">
	<f a="">
		<c path="lua.lib.luv.Handle"/>
		<x path="Void"/>
	</f>
	<x path="Void"/>
</f></walk>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<class path="lua.lib.luv.Misc" params="" file="/usr/share/haxe/std/lua/lib/luv/Misc.hx" extern="1">
		<chdir public="1" set="method" static="1"><f a="path">
	<c path="String"/>
	<x path="Bool"/>
</f></chdir>
		<cpu_info public="1" set="method" static="1"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<t path="lua.lib.luv.CpuInfo"/>
</c></f></cpu_info>
		<cwd public="1" set="method" static="1"><f a=""><c path="String"/></f></cwd>
		<exepath public="1" set="method" static="1"><f a=""><c path="String"/></f></exepath>
		<get_process_title public="1" set="method" static="1"><f a=""><c path="String"/></f></get_process_title>
		<get_total_memory public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_total_memory>
		<get_free_memory public="1" set="method" static="1"><f a=""><x path="Int"/></f></get_free_memory>
		<getpid public="1" set="method" static="1"><f a=""><x path="Int"/></f></getpid>
		<getrusage public="1" set="method" static="1"><f a=""><t path="lua.lib.luv.ResourceUsage"/></f></getrusage>
		<guess_handle public="1" set="method" static="1"><f a="handle">
	<x path="Int"/>
	<c path="String"/>
</f></guess_handle>
		<hrtime public="1" set="method" static="1"><f a=""><x path="Float"/></f></hrtime>
		<gettimeofday public="1" set="method" static="1"><f a=""><c path="lua.lib.luv.TimeOfDay"/></f></gettimeofday>
		<interface_addresses public="1" set="method" static="1"><f a=""><d/></f></interface_addresses>
		<loadavg public="1" set="method" static="1"><f a=""><x path="Float"/></f></loadavg>
		<resident_set_memory public="1" set="method" static="1"><f a=""><x path="Int"/></f></resident_set_memory>
		<set_process_title public="1" set="method" static="1"><f a="title">
	<c path="String"/>
	<x path="Bool"/>
</f></set_process_title>
		<uptime public="1" set="method" static="1"><f a=""><x path="Int"/></f></uptime>
		<version public="1" set="method" static="1"><f a=""><x path="Int"/></f></version>
		<version_string public="1" set="method" static="1"><f a=""><c path="String"/></f></version_string>
		<getuid public="1" set="method" static="1"><f a=""><x path="Int"/></f></getuid>
		<setuid public="1" set="method" static="1"><f a="from:to">
	<x path="Int"/>
	<x path="Int"/>
	<c path="String"/>
</f></setuid>
		<getgid public="1" set="method" static="1"><f a=""><x path="Int"/></f></getgid>
		<setgid public="1" set="method" static="1"><f a="from:to">
	<x path="Int"/>
	<x path="Int"/>
	<x path="Void"/>
</f></setgid>
		<print_all_handles public="1" set="method" static="1"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></f></print_all_handles>
		<print_active_handles public="1" set="method" static="1"><f a=""><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></f></print_active_handles>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<typedef path="lua.lib.luv.CpuInfo" params="" file="/usr/share/haxe/std/lua/lib/luv/Misc.hx" module="lua.lib.luv.Misc"><a>
	<times><t path="lua.lib.luv.CpuTimes"/></times>
	<speed><x path="Int"/></speed>
	<model><c path="String"/></model>
</a></typedef>
	<typedef path="lua.lib.luv.CpuTimes" params="" file="/usr/share/haxe/std/lua/lib/luv/Misc.hx" module="lua.lib.luv.Misc"><a>
	<user><x path="Int"/></user>
	<sys><x path="Int"/></sys>
	<irq><x path="Int"/></irq>
	<idle><x path="Int"/></idle>
</a></typedef>
	<typedef path="lua.lib.luv.ResourceUsage" params="" file="/usr/share/haxe/std/lua/lib/luv/Misc.hx" module="lua.lib.luv.Misc"><a>
	<utime><t path="lua.lib.luv.MicroTimeStamp"/></utime>
	<stime><t path="lua.lib.luv.MicroTimeStamp"/></stime>
	<oublock><x path="Int"/></oublock>
	<nvcsw><x path="Int"/></nvcsw>
	<nswap><x path="Int"/></nswap>
	<nsignals><x path="Int"/></nsignals>
	<nivcsw><x path="Int"/></nivcsw>
	<msgsnd><x path="Int"/></msgsnd>
	<msgrcv><x path="Int"/></msgrcv>
	<minflt><x path="Int"/></minflt>
	<maxrss><x path="Int"/></maxrss>
	<majflt><x path="Int"/></majflt>
	<ixrss><x path="Int"/></ixrss>
	<isrss><x path="Int"/></isrss>
	<inblock><x path="Int"/></inblock>
	<idrss><x path="Int"/></idrss>
</a></typedef>
	<typedef path="lua.lib.luv.MicroTimeStamp" params="" file="/usr/share/haxe/std/lua/lib/luv/Misc.hx" module="lua.lib.luv.Misc"><a>
	<usec><x path="Int"/></usec>
	<sec><x path="Int"/></sec>
</a></typedef>
	<class path="lua.lib.luv.TimeOfDay" params="" file="/usr/share/haxe/std/lua/lib/luv/Misc.hx" module="lua.lib.luv.Misc" extern="1">
		<seconds public="1"><x path="Int"/></seconds>
		<microseconds public="1"><x path="Int"/></microseconds>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.lib.luv.Os" params="" file="/usr/share/haxe/std/lua/lib/luv/Os.hx" extern="1">
		<homedir public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"os_homedir"</e></m></meta>
		</homedir>
		<tmpdir public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"os_tmpdir"</e></m></meta>
		</tmpdir>
		<get_passwd public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"os_get_passwd"</e></m></meta>
		</get_passwd>
		<getenv public="1" set="method" static="1">
			<f a="env">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"os_getenv"</e></m></meta>
		</getenv>
		<setenv public="1" set="method" static="1">
			<f a="env:value">
				<c path="String"/>
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"os_setenv"</e></m></meta>
		</setenv>
		<unsetenv public="1" set="method" static="1">
			<f a="env">
				<c path="String"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"os_unsetenv"</e></m></meta>
		</unsetenv>
		<gethostname public="1" set="method" static="1">
			<f a=""><c path="String"/></f>
			<meta><m n=":native"><e>"os_gethostname"</e></m></meta>
		</gethostname>
		<environ public="1" set="method" static="1">
			<f a=""><c path="lua.Table">
	<c path="String"/>
	<c path="String"/>
</c></f>
			<meta><m n=":native"><e>"os_environ"</e></m></meta>
		</environ>
		<uname public="1" set="method" static="1">
			<f a=""><t path="lua.lib.luv.Uname"/></f>
			<meta><m n=":native"><e>"os_uname"</e></m></meta>
		</uname>
		<getpid public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"os_getpid"</e></m></meta>
		</getpid>
		<getppid public="1" set="method" static="1">
			<f a=""><x path="Int"/></f>
			<meta><m n=":native"><e>"os_getppid"</e></m></meta>
		</getppid>
		<getpriority public="1" set="method" static="1">
			<f a="pid">
				<x path="Int"/>
				<x path="Int"/>
			</f>
			<meta><m n=":native"><e>"os_getpriority"</e></m></meta>
		</getpriority>
		<setpriority public="1" set="method" static="1">
			<f a="pid:priority">
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"os_setpriority"</e></m></meta>
		</setpriority>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<typedef path="lua.lib.luv.Uname" params="" file="/usr/share/haxe/std/lua/lib/luv/Os.hx" module="lua.lib.luv.Os"><a>
	<version><c path="String"/></version>
	<sysname><c path="String"/></sysname>
	<release><c path="String"/></release>
	<machine><c path="String"/></machine>
</a></typedef>
	<class path="lua.lib.luv.Stream" params="" file="/usr/share/haxe/std/lua/lib/luv/Stream.hx" extern="1">
		<extends path="lua.lib.luv.Handle"/>
		<shutdown public="1" set="method"><f a="?cb">
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
</f></shutdown>
		<listen public="1" set="method"><f a="backlog:cb">
	<x path="Int"/>
	<f a=":">
		<c path="String"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
</f></listen>
		<accept public="1" set="method"><f a="client_stream">
	<c path="lua.lib.luv.Stream"/>
	<x path="Int"/>
</f></accept>
		<read_start public="1" set="method"><f a="cb">
	<f a=":">
		<c path="String"/>
		<c path="String"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
</f></read_start>
		<read_stop public="1" set="method"><f a=""><x path="Int"/></f></read_stop>
		<write public="1" set="method"><f a="data:?cb">
	<t path="lua.lib.luv.StreamData"/>
	<f a=":">
		<c path="String"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
</f></write>
		<write2 public="1" set="method"><f a="data:send_handle:cb">
	<t path="lua.lib.luv.StreamData"/>
	<c path="lua.lib.luv.net.Tcp"/>
	<f a=":">
		<c path="String"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
</f></write2>
		<try_write public="1" set="method"><f a="data">
	<t path="lua.lib.luv.StreamData"/>
	<x path="Int"/>
</f></try_write>
		<is_readable public="1" set="method"><f a=""><x path="Bool"/></f></is_readable>
		<is_writable public="1" set="method"><f a=""><x path="Bool"/></f></is_writable>
		<set_blocking public="1" set="method"><f a="blocking">
	<x path="Bool"/>
	<x path="Int"/>
</f></set_blocking>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<class path="lua.lib.luv.Pipe" params="" file="/usr/share/haxe/std/lua/lib/luv/Pipe.hx" extern="1">
		<extends path="lua.lib.luv.Stream"/>
		<new_pipe public="1" set="method" static="1"><f a="ipc">
	<x path="Bool"/>
	<c path="lua.lib.luv.Pipe"/>
</f></new_pipe>
		<open public="1" set="method"><f a="file">
	<x path="haxe.extern.EitherType">
		<c path="lua.FileHandle"/>
		<c path="lua.lib.luv.Handle"/>
	</x>
	<c path="lua.lib.luv.Pipe"/>
</f></open>
		<bind public="1" set="method"><f a="name">
	<c path="String"/>
	<c path="lua.lib.luv.Pipe"/>
</f></bind>
		<connect public="1" set="method"><f a="name:cb">
	<c path="String"/>
	<f a=":">
		<c path="String"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
</f></connect>
		<getsockname public="1" set="method"><f a=""><c path="String"/></f></getsockname>
		<pending_instances public="1" set="method"><f a="count">
	<x path="Int"/>
	<x path="Int"/>
</f></pending_instances>
		<pending_count public="1" set="method"><f a=""><x path="Int"/></f></pending_count>
		<pending_type public="1" set="method"><f a=""><x path="Int"/></f></pending_type>
		<new public="1" set="method">
			<f a="ipc">
				<x path="Bool"/>
				<x path="Void"/>
			</f>
			<meta><m n=":native"><e>"new_pipe"</e></m></meta>
		</new>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<class path="lua.lib.luv.Process" params="" file="/usr/share/haxe/std/lua/lib/luv/Process.hx" extern="1">
		<extends path="lua.lib.luv.Handle"/>
		<disable_stdio_inheritance public="1" set="method" static="1"><f a=""><x path="Void"/></f></disable_stdio_inheritance>
		<spawn public="1" set="method" static="1"><f a="path:options:cb">
	<c path="String"/>
	<d/>
	<f a=":">
		<x path="Int"/>
		<c path="lua.lib.luv.Signal"/>
		<x path="Void"/>
	</f>
	<c path="lua.lib.luv.LuvSpawn"/>
</f></spawn>
		<kill public="1" set="method"><f a="sig">
	<c path="String"/>
	<x path="Int"/>
</f></kill>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<typedef path="lua.lib.luv.ProcessOptions" params="" file="/usr/share/haxe/std/lua/lib/luv/Process.hx" module="lua.lib.luv.Process"><a>
	<stdio><c path="lua.Table">
	<x path="Int"/>
	<c path="lua.lib.luv.Pipe"/>
</c></stdio>
	<args><c path="lua.Table">
	<x path="Int"/>
	<c path="String"/>
</c></args>
</a></typedef>
	<class path="lua.lib.luv.LuvSpawn" params="" file="/usr/share/haxe/std/lua/lib/luv/Process.hx" module="lua.lib.luv.Process" extern="1">
		<handle public="1"><c path="lua.lib.luv.Process"/></handle>
		<pid public="1"><x path="Int"/></pid>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<class path="lua.lib.luv.Request" params="" file="/usr/share/haxe/std/lua/lib/luv/Request.hx" extern="1">
		<cancel public="1" set="method"><f a=""><x path="Bool"/></f></cancel>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<class path="lua.lib.luv.Signal" params="" file="/usr/share/haxe/std/lua/lib/luv/Signal.hx" extern="1">
		<extends path="lua.lib.luv.Handle"/>
		<new_signal public="1" set="method" static="1"><f a=""><c path="lua.lib.luv.Signal"/></f></new_signal>
		<start public="1" set="method"><f a="sigtype:?cb">
	<x path="haxe.extern.EitherType">
		<x path="Int"/>
		<c path="String"/>
	</x>
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
</f></start>
		<stop public="1" set="method"><f a=""><x path="Int"/></f></stop>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":native"><e>"new_signal"</e></m></meta>
		</new>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<typedef path="lua.lib.luv.StreamData" params="" file="/usr/share/haxe/std/lua/lib/luv/Stream.hx" module="lua.lib.luv.Stream"><x path="haxe.extern.EitherType">
	<c path="String"/>
	<c path="lua.Table">
		<x path="Int"/>
		<c path="String"/>
	</c>
</x></typedef>
	<class path="lua.lib.luv.Thread" params="" file="/usr/share/haxe/std/lua/lib/luv/Thread.hx" extern="1">
		<new_thread public="1" set="method" static="1"><f a=""><c path="lua.lib.luv.Timer"/></f></new_thread>
		<self public="1" set="method" static="1"><f a=""><c path="lua.lib.luv.Thread"/></f></self>
		<sleep public="1" set="method" static="1"><f a="msec">
	<x path="Int"/>
	<x path="Void"/>
</f></sleep>
		<equal public="1" set="method"><f a="t">
	<c path="lua.lib.luv.Thread"/>
	<x path="Bool"/>
</f></equal>
		<join public="1" set="method"><f a="t">
	<c path="lua.lib.luv.Thread"/>
	<x path="Bool"/>
</f></join>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":native"><e>"new_thread"</e></m></meta>
		</new>
		<meta>
			<m n=":directlyUsed"/>
			<m n=":luaRequire"><e>"luv"</e></m>
		</meta>
	</class>
	<class path="lua.lib.luv.Timer" params="" file="/usr/share/haxe/std/lua/lib/luv/Timer.hx" extern="1">
		<extends path="lua.lib.luv.Handle"/>
		<new_timer public="1" set="method" static="1"><f a=""><c path="lua.lib.luv.Timer"/></f></new_timer>
		<start public="1" set="method"><f a="timeout:repeat:cb">
	<x path="Int"/>
	<x path="Int"/>
	<f a=""><x path="Void"/></f>
	<x path="Int"/>
</f></start>
		<stop public="1" set="method"><f a=""><x path="Int"/></f></stop>
		<again public="1" set="method"><f a=""><x path="Int"/></f></again>
		<set_repeat public="1" set="method"><f a="repeat">
	<x path="Int"/>
	<x path="Void"/>
</f></set_repeat>
		<get_repeat public="1" set="method"><f a=""><x path="Int"/></f></get_repeat>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":native"><e>"new_timer"</e></m></meta>
		</new>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<typedef path="lua.lib.luv.fs.FileDescriptor" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/FileDescriptor.hx"><x path="Int"/></typedef>
	<class path="lua.lib.luv.fs.FileSystem" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/FileSystem.hx" extern="1">
		<constants final="1" public="1" set="null" static="1"><c path="lua.Table">
	<c path="String"/>
	<x path="Int"/>
</c></constants>
		<close public="1" set="method" static="1">
			<f a="file">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_close"</e></m></meta>
			<overloads><fs_close public="1" set="method">
	<f a="file:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_close"</e></m></meta>
</fs_close></overloads>
		</close>
		<open public="1" set="method" static="1">
			<f a="path:flags:mode">
				<c path="String"/>
				<x path="lua.lib.luv.fs.Open"/>
				<x path="Int"/>
				<c path="lua.Result"><t path="lua.lib.luv.fs.FileDescriptor"/></c>
			</f>
			<meta><m n=":native"><e>"fs_open"</e></m></meta>
			<overloads>
				<fs_open public="1" set="method">
					<f a="path:flags:mode">
						<c path="String"/>
						<x path="Int"/>
						<x path="Int"/>
						<c path="lua.Result"><t path="lua.lib.luv.fs.FileDescriptor"/></c>
					</f>
					<meta><m n=":native"><e>"fs_open"</e></m></meta>
				</fs_open>
				<fs_open public="1" set="method">
					<f a="path:flags:mode:?cb">
						<c path="String"/>
						<x path="Int"/>
						<x path="Int"/>
						<f a=":">
							<c path="String"/>
							<t path="lua.lib.luv.fs.FileDescriptor"/>
							<x path="Void"/>
						</f>
						<c path="lua.lib.luv.Request"/>
					</f>
					<meta><m n=":native"><e>"fs_open"</e></m></meta>
				</fs_open>
				<fs_open public="1" set="method">
					<f a="path:flags:mode:?cb">
						<c path="String"/>
						<x path="lua.lib.luv.fs.Open"/>
						<x path="Int"/>
						<f a=":">
							<c path="String"/>
							<t path="lua.lib.luv.fs.FileDescriptor"/>
							<x path="Void"/>
						</f>
						<c path="lua.lib.luv.Request"/>
					</f>
					<meta><m n=":native"><e>"fs_open"</e></m></meta>
				</fs_open>
			</overloads>
		</open>
		<read public="1" set="method" static="1">
			<f a="file:len:offset">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="lua.Result"><c path="String"/></c>
			</f>
			<meta><m n=":native"><e>"fs_read"</e></m></meta>
			<overloads><fs_read public="1" set="method">
	<f a="file:len:offset:?cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<x path="Int"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<c path="String"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_read"</e></m></meta>
</fs_read></overloads>
		</read>
		<unlink public="1" set="method" static="1">
			<f a="file:content">
				<c path="String"/>
				<c path="String"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_unlink"</e></m></meta>
			<overloads><fs_unlink public="1" set="method">
	<f a="file:?cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_unlink"</e></m></meta>
</fs_unlink></overloads>
		</unlink>
		<write public="1" set="method" static="1">
			<f a="file:content:offset">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<c path="String"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Int"/></c>
			</f>
			<meta><m n=":native"><e>"fs_write"</e></m></meta>
			<overloads><fs_write public="1" set="method">
	<f a="file:content:offset:?cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<c path="String"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<x path="Int"/>
	</f>
	<meta><m n=":native"><e>"fs_write"</e></m></meta>
</fs_write></overloads>
		</write>
		<mkdir public="1" set="method" static="1">
			<f a="path:mode">
				<c path="String"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_mkdir"</e></m></meta>
			<overloads><fs_mkdir public="1" set="method">
	<f a="path:mode:cb">
		<c path="String"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_mkdir"</e></m></meta>
</fs_mkdir></overloads>
		</mkdir>
		<mkdtemp public="1" set="method" static="1">
			<f a="template">
				<c path="String"/>
				<c path="lua.Result"><c path="String"/></c>
			</f>
			<meta><m n=":native"><e>"fs_mkdtemp"</e></m></meta>
			<overloads><fs_mkdtemp public="1" set="method">
	<f a="template:cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<c path="String"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_mkdtemp"</e></m></meta>
</fs_mkdtemp></overloads>
		</mkdtemp>
		<mkstemp public="1" set="method" static="1">
			<f a="template">
				<c path="String"/>
				<c path="lua.Result"><t path="lua.lib.luv.fs.FileDescriptor"/></c>
			</f>
			<meta><m n=":native"><e>"fs_mkstemp"</e></m></meta>
			<overloads><fs_mkstemp public="1" set="method">
	<f a="template:cb">
		<c path="String"/>
		<f a="::">
			<c path="String"/>
			<t path="lua.lib.luv.fs.FileDescriptor"/>
			<c path="String"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_mkstemp"</e></m></meta>
</fs_mkstemp></overloads>
		</mkstemp>
		<rmdir public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="lua.Result"><x path="Int"/></c>
			</f>
			<meta><m n=":native"><e>"fs_rmdir"</e></m></meta>
			<overloads><fs_rmdir public="1" set="method">
	<f a="path:cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_rmdir"</e></m></meta>
</fs_rmdir></overloads>
		</rmdir>
		<scandir public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="lua.lib.luv.fs.ScanDirMarker"/>
			</f>
			<meta><m n=":native"><e>"fs_scandir"</e></m></meta>
			<overloads><fs_scandir public="1" set="method">
	<f a="path:cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_scandir"</e></m></meta>
</fs_scandir></overloads>
		</scandir>
		<scandir_next public="1" set="method" static="1">
			<f a="scandir">
				<c path="lua.lib.luv.fs.ScanDirMarker"/>
				<c path="lua.lib.luv.fs.ScandirNext"/>
			</f>
			<meta><m n=":native"><e>"fs_scandir_next"</e></m></meta>
		</scandir_next>
		<stat public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="lua.Result"><t path="lua.lib.luv.fs.Stat"/></c>
			</f>
			<meta><m n=":native"><e>"fs_stat"</e></m></meta>
			<overloads><fs_stat public="1" set="method">
	<f a="path:cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<t path="lua.lib.luv.fs.Stat"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_stat"</e></m></meta>
</fs_stat></overloads>
		</stat>
		<fstat public="1" set="method" static="1">
			<f a="descriptor">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<c path="lua.Result"><t path="lua.lib.luv.fs.Stat"/></c>
			</f>
			<meta><m n=":native"><e>"fs_fstat"</e></m></meta>
			<overloads><fs_fstat public="1" set="method">
	<f a="descriptor:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<f a=":">
			<c path="String"/>
			<t path="lua.lib.luv.fs.Stat"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_fstat"</e></m></meta>
</fs_fstat></overloads>
		</fstat>
		<lstat public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="lua.Result"><t path="lua.lib.luv.fs.Stat"/></c>
			</f>
			<meta><m n=":native"><e>"fs_lstat"</e></m></meta>
			<overloads><fs_lstat public="1" set="method">
	<f a="path:cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<t path="lua.lib.luv.fs.Stat"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_lstat"</e></m></meta>
</fs_lstat></overloads>
		</lstat>
		<rename public="1" set="method" static="1">
			<f a="path:newpath">
				<c path="String"/>
				<c path="String"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_rename"</e></m></meta>
			<overloads><fs_rename public="1" set="method">
	<f a="path:newpath:cb">
		<c path="String"/>
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_rename"</e></m></meta>
</fs_rename></overloads>
		</rename>
		<fsync public="1" set="method" static="1">
			<f a="descriptor">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_fsync"</e></m></meta>
			<overloads><fs_fsync public="1" set="method">
	<f a="descriptor:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_fsync"</e></m></meta>
</fs_fsync></overloads>
		</fsync>
		<fdatasync public="1" set="method" static="1">
			<f a="descriptor">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_fdatasync"</e></m></meta>
			<overloads><fs_fdatasync public="1" set="method">
	<f a="descriptor:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_fdatasync"</e></m></meta>
</fs_fdatasync></overloads>
		</fdatasync>
		<ftruncate public="1" set="method" static="1">
			<f a="descriptor:offset">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_ftruncate"</e></m></meta>
			<overloads><fs_ftruncate public="1" set="method">
	<f a="descriptor:offset:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_ftruncate"</e></m></meta>
</fs_ftruncate></overloads>
		</ftruncate>
		<sendfile public="1" set="method" static="1">
			<f a="fin:fout">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<c path="lua.Result"><x path="Int"/></c>
			</f>
			<meta><m n=":native"><e>"fs_sendfile"</e></m></meta>
			<overloads><fs_sendfile public="1" set="method">
	<f a="fin:fout:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<f a=":">
			<c path="String"/>
			<x path="Int"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_sendfile"</e></m></meta>
</fs_sendfile></overloads>
		</sendfile>
		<access public="1" set="method" static="1">
			<f a="path:mode">
				<c path="String"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_access"</e></m></meta>
			<overloads><fs_access public="1" set="method">
	<f a="path:mode:cb">
		<c path="String"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_access"</e></m></meta>
</fs_access></overloads>
		</access>
		<chmod public="1" set="method" static="1">
			<f a="path:mode">
				<c path="String"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_chmod"</e></m></meta>
			<overloads><fs_chmod public="1" set="method">
	<f a="path:mode:cb">
		<c path="String"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_chmod"</e></m></meta>
</fs_chmod></overloads>
		</chmod>
		<fchmod public="1" set="method" static="1">
			<f a="descriptor:mode">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_fchmod"</e></m></meta>
			<overloads><fs_fchmod public="1" set="method">
	<f a="descriptor:mode:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_fchmod"</e></m></meta>
</fs_fchmod></overloads>
		</fchmod>
		<futime public="1" set="method" static="1">
			<f a="descriptor:actime:modtime">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_futime"</e></m></meta>
			<overloads><fs_futime public="1" set="method">
	<f a="descriptor:actime:modtime:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<x path="Int"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_futime"</e></m></meta>
</fs_futime></overloads>
		</futime>
		<utime public="1" set="method" static="1">
			<f a="path:actime:modtime">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_utime"</e></m></meta>
			<overloads><fs_utime public="1" set="method">
	<f a="path:actime:modtime:cb">
		<c path="String"/>
		<x path="Int"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_utime"</e></m></meta>
</fs_utime></overloads>
		</utime>
		<link public="1" set="method" static="1">
			<f a="oldpath:newpath">
				<c path="String"/>
				<c path="String"/>
				<c path="lua.Result"><x path="Bool"/></c>
			</f>
			<meta><m n=":native"><e>"fs_link"</e></m></meta>
			<overloads><fs_link public="1" set="method">
	<f a="oldpath:newpath:cb">
		<c path="String"/>
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_link"</e></m></meta>
</fs_link></overloads>
		</link>
		<symlink public="1" set="method" static="1">
			<f a="oldpath:newpath:flags">
				<c path="String"/>
				<c path="String"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"fs_symlink"</e></m></meta>
			<overloads><fs_symlink public="1" set="method">
	<f a="oldpath:newpath:flags:cb">
		<c path="String"/>
		<c path="String"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_symlink"</e></m></meta>
</fs_symlink></overloads>
		</symlink>
		<readlink public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"fs_readlink"</e></m></meta>
			<overloads><fs_readlink public="1" set="method">
	<f a="path:cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<c path="String"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_readlink"</e></m></meta>
</fs_readlink></overloads>
		</readlink>
		<realpath public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="String"/>
			</f>
			<meta><m n=":native"><e>"fs_realpath"</e></m></meta>
			<overloads><fs_realpath public="1" set="method">
	<f a="path:cb">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<c path="String"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_realpath"</e></m></meta>
</fs_realpath></overloads>
		</realpath>
		<chown public="1" set="method" static="1">
			<f a="path:uid:gid">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"fs_chown"</e></m></meta>
			<overloads><fs_chown public="1" set="method">
	<f a="path:uid:gid:cb">
		<c path="String"/>
		<x path="Int"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_chown"</e></m></meta>
</fs_chown></overloads>
		</chown>
		<fchown public="1" set="method" static="1">
			<f a="descriptor:uid:gid">
				<t path="lua.lib.luv.fs.FileDescriptor"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"fs_fchown"</e></m></meta>
			<overloads><fs_fchown public="1" set="method">
	<f a="descriptor:uid:gid:cb">
		<t path="lua.lib.luv.fs.FileDescriptor"/>
		<x path="Int"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_fchown"</e></m></meta>
</fs_fchown></overloads>
		</fchown>
		<lchown public="1" set="method" static="1">
			<f a="descriptor:uid:gid">
				<c path="String"/>
				<x path="Int"/>
				<x path="Int"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"fs_lchown"</e></m></meta>
			<haxe_doc>Not available on windows</haxe_doc>
			<overloads><fs_lchown public="1" set="method">
	<f a="descriptor:uid:gid:cb">
		<c path="String"/>
		<x path="Int"/>
		<x path="Int"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_lchown"</e></m></meta>
	<haxe_doc>Not available on windows</haxe_doc>
</fs_lchown></overloads>
		</lchown>
		<copyfile public="1" set="method" static="1">
			<f a="path:newPath:?flags">
				<c path="String"/>
				<c path="String"/>
				<x path="Null"><t path="lua.lib.luv.fs.CopyFlags"/></x>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"fs_copyfile"</e></m></meta>
			<overloads><fs_copyfile public="1" set="method">
	<f a="path:newPath:flags:cb">
		<c path="String"/>
		<c path="String"/>
		<x path="Null"><t path="lua.lib.luv.fs.CopyFlags"/></x>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_copyfile"</e></m></meta>
</fs_copyfile></overloads>
		</copyfile>
		<statfs public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<t path="lua.lib.luv.fs.StatFs"/>
			</f>
			<meta><m n=":native"><e>"fs_statfs"</e></m></meta>
			<overloads><fs_statfs public="1" set="method">
	<f a="path:cb">
		<c path="String"/>
		<f a=":">
			<t path="lua.lib.luv.fs.StatFs"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_statfs"</e></m></meta>
</fs_statfs></overloads>
		</statfs>
		<opendir public="1" set="method" static="1">
			<f a="path">
				<c path="String"/>
				<c path="lua.lib.luv.Handle"/>
			</f>
			<meta><m n=":native"><e>"fs_opendir"</e></m></meta>
			<overloads><fs_opendir public="1" set="method">
	<f a="path:cb:?entries">
		<c path="String"/>
		<f a=":">
			<c path="String"/>
			<c path="lua.lib.luv.Handle"/>
			<x path="Void"/>
		</f>
		<x path="Int"/>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_opendir"</e></m></meta>
</fs_opendir></overloads>
		</opendir>
		<readdir public="1" set="method" static="1">
			<f a="path">
				<c path="lua.lib.luv.Handle"/>
				<c path="lua.Table">
					<x path="Int"/>
					<t path="lua.lib.luv.fs.NameType"/>
				</c>
			</f>
			<meta><m n=":native"><e>"fs_readdir"</e></m></meta>
			<overloads><fs_readdir public="1" set="method">
	<f a="dir:cb">
		<c path="lua.lib.luv.Handle"/>
		<f a=":">
			<c path="String"/>
			<c path="lua.Table">
				<x path="Int"/>
				<t path="lua.lib.luv.fs.NameType"/>
			</c>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_readdir"</e></m></meta>
</fs_readdir></overloads>
		</readdir>
		<closedir public="1" set="method" static="1">
			<f a="dir">
				<c path="lua.lib.luv.Handle"/>
				<x path="Bool"/>
			</f>
			<meta><m n=":native"><e>"fs_closedir"</e></m></meta>
			<overloads><fs_closedir public="1" set="method">
	<f a="dir:cb">
		<c path="lua.lib.luv.Handle"/>
		<f a=":">
			<c path="String"/>
			<x path="Bool"/>
			<x path="Void"/>
		</f>
		<c path="lua.lib.luv.Request"/>
	</f>
	<meta><m n=":native"><e>"fs_closedir"</e></m></meta>
</fs_closedir></overloads>
		</closedir>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<class path="lua.lib.luv.fs.ScanDirMarker" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/FileSystem.hx" module="lua.lib.luv.fs.FileSystem" extern="1"/>
	<class path="lua.lib.luv.fs.ScandirNext" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/FileSystem.hx" module="lua.lib.luv.fs.FileSystem" extern="1">
		<name public="1"><c path="String"/></name>
		<type public="1"><c path="String"/></type>
		<meta><m n=":multiReturn"/></meta>
	</class>
	<typedef path="lua.lib.luv.fs.NameType" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/FileSystem.hx" module="lua.lib.luv.fs.FileSystem"><a>
	<type><c path="String"/></type>
	<name><c path="String"/></name>
</a></typedef>
	<typedef path="lua.lib.luv.fs.Stat" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/FileSystem.hx" module="lua.lib.luv.fs.FileSystem"><a>
	<uid><x path="Int"/></uid>
	<type><c path="String"/></type>
	<size><x path="Int"/></size>
	<rdev><x path="Int"/></rdev>
	<nlink><x path="Int"/></nlink>
	<mtime><t path="lua.lib.luv.fs.TimeStamp"/></mtime>
	<mode><x path="Int"/></mode>
	<ino><x path="Int"/></ino>
	<gid><x path="Int"/></gid>
	<gen><x path="Int"/></gen>
	<flags><x path="Int"/></flags>
	<dev><x path="Int"/></dev>
	<ctime><t path="lua.lib.luv.fs.TimeStamp"/></ctime>
	<blocks><x path="Int"/></blocks>
	<blksize><x path="Int"/></blksize>
	<birthtime><t path="lua.lib.luv.fs.TimeStamp"/></birthtime>
	<atime><t path="lua.lib.luv.fs.TimeStamp"/></atime>
</a></typedef>
	<typedef path="lua.lib.luv.fs.TimeStamp" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/FileSystem.hx" module="lua.lib.luv.fs.FileSystem"><a>
	<sec><x path="Int"/></sec>
	<nsec><x path="Int"/></nsec>
</a></typedef>
	<typedef path="lua.lib.luv.fs.StatFs" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/FileSystem.hx" module="lua.lib.luv.fs.FileSystem"><a>
	<type><x path="Int"/></type>
	<files><x path="Int"/></files>
	<ffree><x path="Int"/></ffree>
	<bsize><x path="Int"/></bsize>
	<blocks><x path="Int"/></blocks>
	<bfree><x path="Int"/></bfree>
	<bavail><x path="Int"/></bavail>
</a></typedef>
	<typedef path="lua.lib.luv.fs.CopyFlags" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/FileSystem.hx" module="lua.lib.luv.fs.FileSystem"><a>
	<ficlone_force>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</ficlone_force>
	<ficlone>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</ficlone>
	<excl>
		<x path="Null"><x path="Bool"/></x>
		<meta><m n=":optional"/></meta>
	</excl>
</a></typedef>
	<abstract path="lua.lib.luv.fs.AccessMode" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/FileSystem.hx" module="lua.lib.luv.fs.FileSystem">
		<this><x path="Int"/></this>
		<to><icast><x path="Int"/></icast></to>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua.lib.luv.fs._FileSystem.AccessMode_Impl_" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/FileSystem.hx" private="1" module="lua.lib.luv.fs.FileSystem" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<abstract path="lua.lib.luv.fs.Open" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/Open.hx">
		<this><c path="String"/></this>
		<meta><m n=":enum"/></meta>
		<impl><class path="lua.lib.luv.fs._Open.Open_Impl_" params="" file="/usr/share/haxe/std/lua/lib/luv/fs/Open.hx" private="1" module="lua.lib.luv.fs.Open" final="1"><meta>
	<m n=":keep"/>
	<m n=":enum"/>
</meta></class></impl>
	</abstract>
	<class path="lua.lib.luv.net.Tcp" params="" file="/usr/share/haxe/std/lua/lib/luv/net/Tcp.hx" extern="1">
		<extends path="lua.lib.luv.Stream"/>
		<new_tcp public="1" set="method" static="1"><f a=""><c path="lua.lib.luv.net.Tcp"/></f></new_tcp>
		<open public="1" set="method"><f a="sock">
	<x path="Int"/>
	<x path="Int"/>
</f></open>
		<nodelay public="1" set="method"><f a="enable">
	<x path="Bool"/>
	<x path="Int"/>
</f></nodelay>
		<keepalive public="1" set="method"><f a="enable:?delay">
	<x path="Bool"/>
	<x path="Int"/>
	<x path="Int"/>
</f></keepalive>
		<simultaneous_accepts public="1" set="method"><f a="enable">
	<x path="Bool"/>
	<x path="Int"/>
</f></simultaneous_accepts>
		<bind public="1" set="method"><f a="address:port">
	<c path="String"/>
	<x path="Int"/>
	<x path="Int"/>
</f></bind>
		<getsockname public="1" set="method"><f a=""><x path="Int"/></f></getsockname>
		<getpeername public="1" set="method"><f a=""><c path="String"/></f></getpeername>
		<connect public="1" set="method"><f a="host:port:cb">
	<c path="String"/>
	<x path="Int"/>
	<f a=":">
		<c path="String"/>
		<x path="Bool"/>
		<x path="Void"/>
	</f>
	<x path="Int"/>
</f></connect>
		<write_queue_size public="1" set="method"><f a=""><x path="Int"/></f></write_queue_size>
		<new public="1" set="method">
			<f a=""><x path="Void"/></f>
			<meta><m n=":native"><e>"new_tcp"</e></m></meta>
		</new>
		<meta><m n=":luaRequire"><e>"luv"</e></m></meta>
	</class>
	<typedef path="sys.FileStat" params="" file="/usr/share/haxe/std/sys/FileStat.hx">
		<a>
			<uid>
				<x path="Int"/>
				<haxe_doc>The user id for the file owner.</haxe_doc>
			</uid>
			<size>
				<x path="Int"/>
				<haxe_doc>The size of the file, in bytes.</haxe_doc>
			</size>
			<rdev>
				<x path="Int"/>
				<haxe_doc>The device type on which stat resides (special files only).</haxe_doc>
			</rdev>
			<nlink>
				<x path="Int"/>
				<haxe_doc>The number of hard links to stat.</haxe_doc>
			</nlink>
			<mtime>
				<c path="Date"/>
				<haxe_doc>The last modification time for the file.</haxe_doc>
			</mtime>
			<mode>
				<x path="Int"/>
				<haxe_doc>The permission bits of stat. The meaning of the bits is platform dependent.</haxe_doc>
			</mode>
			<ino>
				<x path="Int"/>
				<haxe_doc>The inode number for stat.</haxe_doc>
			</ino>
			<gid>
				<x path="Int"/>
				<haxe_doc>The user group id for the file owner.</haxe_doc>
			</gid>
			<dev>
				<x path="Int"/>
				<haxe_doc>The device on which stat resides.</haxe_doc>
			</dev>
			<ctime>
				<c path="Date"/>
				<haxe_doc>The creation time for the file (not all file systems support this).</haxe_doc>
			</ctime>
			<atime>
				<c path="Date"/>
				<haxe_doc>The last access time for the file (when enabled by the file system).</haxe_doc>
			</atime>
		</a>
		<haxe_doc>File information, as given by `sys.FileSystem.stat`.</haxe_doc>
	</typedef>
</haxe>