-- Generated by Haxe 4.3.6
local _hx_hidden = {__id__=true, hx__closures=true, super=true, prototype=true, __fields__=true, __ifields__=true, __class__=true, __properties__=true, __fields__=true, __name__=true}

_hx_array_mt = {
    __newindex = function(t,k,v)
        local len = t.length
        t.length =  k >= len and (k + 1) or len
        rawset(t,k,v)
    end
}

function _hx_is_array(o)
    return type(o) == "table"
        and o.__enum__ == nil
        and getmetatable(o) == _hx_array_mt
end



function _hx_tab_array(tab, length)
    tab.length = length
    return setmetatable(tab, _hx_array_mt)
end



function _hx_print_class(obj, depth)
    local first = true
    local result = ''
    for k,v in pairs(obj) do
        if _hx_hidden[k] == nil then
            if first then
                first = false
            else
                result = result .. ', '
            end
            if _hx_hidden[k] == nil then
                result = result .. k .. ':' .. _hx_tostring(v, depth+1)
            end
        end
    end
    return '{ ' .. result .. ' }'
end

function _hx_print_enum(o, depth)
    if o.length == 2 then
        return o[0]
    else
        local str = o[0] .. "("
        for i = 2, (o.length-1) do
            if i ~= 2 then
                str = str .. "," .. _hx_tostring(o[i], depth+1)
            else
                str = str .. _hx_tostring(o[i], depth+1)
            end
        end
        return str .. ")"
    end
end

function _hx_tostring(obj, depth)
    if depth == nil then
        depth = 0
    elseif depth > 5 then
        return "<...>"
    end

    local tstr = _G.type(obj)
    if tstr == "string" then return obj
    elseif tstr == "nil" then return "null"
    elseif tstr == "number" then
        if obj == _G.math.POSITIVE_INFINITY then return "Infinity"
        elseif obj == _G.math.NEGATIVE_INFINITY then return "-Infinity"
        elseif obj == 0 then return "0"
        elseif obj ~= obj then return "NaN"
        else return _G.tostring(obj)
        end
    elseif tstr == "boolean" then return _G.tostring(obj)
    elseif tstr == "userdata" then
        local mt = _G.getmetatable(obj)
        if mt ~= nil and mt.__tostring ~= nil then
            return _G.tostring(obj)
        else
            return "<userdata>"
        end
    elseif tstr == "function" then return "<function>"
    elseif tstr == "thread" then return "<thread>"
    elseif tstr == "table" then
        if obj.__enum__ ~= nil then
            return _hx_print_enum(obj, depth)
        elseif obj.toString ~= nil and not _hx_is_array(obj) then return obj:toString()
        elseif _hx_is_array(obj) then
            if obj.length > 5 then
                return "[...]"
            else
                local str = ""
                for i=0, (obj.length-1) do
                    if i == 0 then
                        str = str .. _hx_tostring(obj[i], depth+1)
                    else
                        str = str .. "," .. _hx_tostring(obj[i], depth+1)
                    end
                end
                return "[" .. str .. "]"
            end
        elseif obj.__class__ ~= nil then
            return _hx_print_class(obj, depth)
        else
            local buffer = {}
            local ref = obj
            if obj.__fields__ ~= nil then
                ref = obj.__fields__
            end
            for k,v in pairs(ref) do
                if _hx_hidden[k] == nil then
                    _G.table.insert(buffer, _hx_tostring(k, depth+1) .. ' : ' .. _hx_tostring(obj[k], depth+1))
                end
            end

            return "{ " .. table.concat(buffer, ", ") .. " }"
        end
    else
        _G.error("Unknown Lua type", 0)
        return ""
    end
end

local function _hx_obj_newindex(t,k,v)
    t.__fields__[k] = true
    rawset(t,k,v)
end

local _hx_obj_mt = {__newindex=_hx_obj_newindex, __tostring=_hx_tostring}

local function _hx_a(...)
  local __fields__ = {};
  local ret = {__fields__ = __fields__};
  local max = select('#',...);
  local tab = {...};
  local cur = 1;
  while cur < max do
    local v = tab[cur];
    __fields__[v] = true;
    ret[v] = tab[cur+1];
    cur = cur + 2
  end
  return setmetatable(ret, _hx_obj_mt)
end

local function _hx_e()
  return setmetatable({__fields__ = {}}, _hx_obj_mt)
end

local function _hx_o(obj)
  return setmetatable(obj, _hx_obj_mt)
end

local function _hx_new(prototype)
  return setmetatable({__fields__ = {}}, {__newindex=_hx_obj_newindex, __index=prototype, __tostring=_hx_tostring})
end

function _hx_field_arr(obj)
    local res = {}
    local idx = 0
    if obj.__fields__ ~= nil then
        obj = obj.__fields__
    end
    for k,v in pairs(obj) do
        if _hx_hidden[k] == nil then
            res[idx] = k
            idx = idx + 1
        end
    end
    return _hx_tab_array(res, idx)
end

local _hxClasses = {}
local Int = _hx_e();
local Dynamic = _hx_e();
local Float = _hx_e();
local Bool = _hx_e();
local Class = _hx_e();
local Enum = _hx_e();

local argpstuff = {
    args = table.pack(...)
}
local Array = _hx_e()
local Math = _hx_e()
local String = _hx_e()
local Std = _hx_e()
local StringTools = _hx_e()
local Sys = _hx_e()
local Type = _hx_e()
__globals_Output = _hx_e()
__drivers_terminal_TerminalBackend = _hx_e()
__drivers_terminal_Terminal = _hx_e()
__globals_FilePath = _hx_e()
__globals_Vector2i = _hx_e()
__globals_Vector2f = _hx_e()
__globals_Globals = _hx_e()
__globals_Color = _hx_e()
__globals_RGBColor = _hx_e()
__globals_Colors = _hx_e()
__globals_Input = _hx_e()
__haxe_IMap = _hx_e()
__haxe_Exception = _hx_e()
__haxe_Log = _hx_e()
__haxe_NativeStackTrace = _hx_e()
__haxe__Rest_Rest_Impl_ = _hx_e()
__haxe_ValueException = _hx_e()
__haxe_ds_ObjectMap = _hx_e()
__haxe_ds_StringMap = _hx_e()
__haxe_exceptions_PosException = _hx_e()
__haxe_exceptions_ArgumentException = _hx_e()
__haxe_exceptions_NotImplementedException = _hx_e()
__haxe_iterators_ArrayIterator = _hx_e()
__haxe_iterators_ArrayKeyValueIterator = _hx_e()
__haxe_macro_Error = _hx_e()
__kernel_MouseEventType = _hx_e()
__kernel_MouseButton = _hx_e()
__kernel_MouseEvent = _hx_e()
__kernel_DriverProvides = _hx_e()
__kernel_Driver = _hx_e()
__kernel_KeyboardDriver = _hx_e()
__kernel_FileType = _hx_e()
__kernel_FileSystemDriver = _hx_e()
__kernel_MouseDriver = _hx_e()
__kernel__Driver_TDOutput = _hx_e()
__kernel_TerminalDriver = _hx_e()
__kernel_SoundDriver = _hx_e()
__kernel_RequestType = _hx_e()
__kernel_Since = _hx_e()
__kernel_HttpDriver = _hx_e()
__kernel_ClockDriver = _hx_e()
local drv = _hx_e()
__kernel_Hook = _hx_e()
__kernel__Kernel_KFSMount = _hx_e()
__kernel__Kernel_MountNotFoundException = _hx_e()
__kernel__Kernel_KFSDriver = _hx_e()
local XGos = _hx_e()
__kernel_Kernel = _hx_e()
__kernel_Logger = _hx_e()
__kernel_KThread = _hx_e()
__kernel_KThreadInfo = _hx_e()
__kernel_KThreadRunner = _hx_e()
__kernel_KThreadAPI = _hx_e()
local xg = _hx_e()
__kernel_hooks_CCFileSystemDriver = _hx_e()
__kernel_hooks_CCFSDriverHook = _hx_e()
__kernel_hooks_MonitorTerminalBackend = _hx_e()
__kernel_hooks_MonitorOutputDriver = _hx_e()
__kernel_hooks_CCMonitorDriverHook = _hx_e()
__kernel_hooks_OutputDriver = _hx_e()
__kernel_hooks_CCMouseDriver = _hx_e()
__kernel_hooks_CCKeyboardDriver = _hx_e()
__kernel_hooks_CCTermHook = _hx_e()
__lua_Boot = _hx_e()
__lua_Thread = _hx_e()
__lua_UserData = _hx_e()
__lua_PairTools = _hx_e()
__lua_lib_luv_Thread = {
    sleep = function(n)
        n = n / 1000
        if _G.sleep ~= nil then
            sleep(n)
        else
            print("Sleeping for " .. tonumber(n))
            os.execute("sleep " .. tonumber(n))
        end

    end,
    run = function(mode) return false end,
    loop_alive = function() return false end,
    fs_unlink = function(path)
        x= fs.delete(path)
        if not x then return true end
    end,
    fs_mkdir = function(path)
        x=fs.makeDir(path)
        if not x then return true end

    end,
    fs_rmdir = function(path)
        x= fs.delete(path)
        if not x then return true end
    end,
    fs_readdir = function(path)
        return fs.list(path)
    end,
    fs_scandir = function(path)
        
        return {0, path}
    end,
    fs_scandir_next = function(dsci)
        dsci[1] = dsci[1] + 1
        
        return fs.list(dsci[2])[dsci[1]]
    end,
    fs_stat = function(path)
        if not fs.exists(path) then return nil end
        return fs.attributes(path)
    end,
    fs_rename = function(p, np)
        return fs.move(p, np)
    end,
    fs_sendfile = function(outfile, infile)
        return fs.copy(infile, outfile)
    end,
    fs_chmod = function(a,b) end,
    fs_chown = function(a,b,c) end,
    fs_utime = function(a,b,c) end,
    fs_lstat = function(path) error("Tried link operation") end,-- This may be provided by your current os, but CraftOS or computercraft bios-level executed code do not have this operation
    fs_link = function(p, a) error("Tried link operation") end,-- This may be provided by your current os, but CraftOS or computercraft bios-level executed code do not have this operation
    fs_symlink = function(p, a, m) error("Tried link operation") end,-- This may be provided by your current os, but CraftOS or computercraft bios-level executed code do not have this operation
    fs_readlink = function(p) error("Tried link operation") end, -- This may be provided by your current os, but CraftOS or computercraft bios-level executed code do not have this operation 
    fs_cwd = function()
        if shell then return shell.dir() else return "/" end
    end,
    fs_chdir = function(path)
        if shell then return shell.setDir(path) end
    end,
    fs_exepath = function(path)
        if shell then
            return shell.getRunningProgram()
        else
            return debug.getinfo(1, "S").source
        end
    end,
    fs_open = function(path, mode, _)
        local f = fs.open(path, mode)
        return {
            read = function(len, offset)
                if offset then
                    f.seek(offset)
                end
                local actuallyread = f.read(len)
                return #actuallyread, actuallyread
            end,
            write = function(data, offset)
                if offset then
                    f.seek(offset)
                else
                    f.seek(1)
                end
                f.write(data)
            end,
            close = function()
                f.close()
            end,
            stat = function ()
                return fs.attributes(path)
            end,
            sync = function () end, -- There doesn't seem to be an imlpementation for this function in computercraft
            datasync = function () end, -- Same as above
            utime = function () end, -- Might be provided by os, but not in craftos or cc bioslevel.
            chmod = function () end, -- Might be provided by os, but not in craftos or cc bioslevel.
            chown = function () end, -- Might be provided by os, but not in craftos or cc bioslevel.
            truncate = function () end, -- Developer does not know what this means
        }

    end
}

local _hx_bind, _hx_bit, _hx_staticToInstance, _hx_funcToField, _hx_maxn, _hx_print, _hx_apply_self, _hx_box_mr, _hx_bit_clamp, _hx_table, _hx_bit_raw
local _hx_pcall_default = {};
local _hx_pcall_break = {};

Array.new = function() 
  local self = _hx_new(Array.prototype)
  Array.super(self)
  return self
end
Array.super = function(self) 
  _hx_tab_array(self, 0);
end
Array.__name__ = "Array"
Array.prototype = _hx_e();
Array.prototype.concat = function(self,a) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  local ret = _g;
  local _g = 0;
  while (_g < a.length) do _hx_do_first_1 = false;
    
    local i = a[_g];
    _g = _g + 1;
    ret:push(i);
  end;
  do return ret end
end
Array.prototype.join = function(self,sep) 
  local tbl = ({});
  local _g_current = 0;
  local _g_array = self;
  while (_g_current < _g_array.length) do _hx_do_first_1 = false;
    
    _g_current = _g_current + 1;
    local i = _g_array[_g_current - 1];
    _G.table.insert(tbl, Std.string(i));
  end;
  do return _G.table.concat(tbl, sep) end
end
Array.prototype.pop = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[self.length - 1];
  self[self.length - 1] = nil;
  self.length = self.length - 1;
  do return ret end
end
Array.prototype.push = function(self,x) 
  self[self.length] = x;
  do return self.length end
end
Array.prototype.reverse = function(self) 
  local tmp;
  local i = 0;
  while (i < Std.int(self.length / 2)) do _hx_do_first_1 = false;
    
    tmp = self[i];
    self[i] = self[(self.length - i) - 1];
    self[(self.length - i) - 1] = tmp;
    i = i + 1;
  end;
end
Array.prototype.shift = function(self) 
  if (self.length == 0) then 
    do return nil end;
  end;
  local ret = self[0];
  if (self.length == 1) then 
    self[0] = nil;
  else
    if (self.length > 1) then 
      self[0] = self[1];
      _G.table.remove(self, 1);
    end;
  end;
  local tmp = self;
  tmp.length = tmp.length - 1;
  do return ret end
end
Array.prototype.slice = function(self,pos,_end) 
  if ((_end == nil) or (_end > self.length)) then 
    _end = self.length;
  else
    if (_end < 0) then 
      _end = _G.math.fmod((self.length - (_G.math.fmod(-_end, self.length))), self.length);
    end;
  end;
  if (pos < 0) then 
    pos = _G.math.fmod((self.length - (_G.math.fmod(-pos, self.length))), self.length);
  end;
  if ((pos > _end) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  end;
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = _end;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    ret:push(self[i]);
  end;
  do return ret end
end
Array.prototype.sort = function(self,f) 
  local i = 0;
  local l = self.length;
  while (i < l) do _hx_do_first_1 = false;
    
    local swap = false;
    local j = 0;
    local max = (l - i) - 1;
    while (j < max) do _hx_do_first_2 = false;
      
      if (f(self[j], self[j + 1]) > 0) then 
        local tmp = self[j + 1];
        self[j + 1] = self[j];
        self[j] = tmp;
        swap = true;
      end;
      j = j + 1;
    end;
    if (not swap) then 
      break;
    end;
    i = i + 1;
  end;
end
Array.prototype.splice = function(self,pos,len) 
  if ((len < 0) or (pos > self.length)) then 
    do return _hx_tab_array({}, 0) end;
  else
    if (pos < 0) then 
      pos = self.length - (_G.math.fmod(-pos, self.length));
    end;
  end;
  len = Math.min(len, self.length - pos);
  local ret = _hx_tab_array({}, 0);
  local _g = pos;
  local _g1 = pos + len;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    ret:push(self[i]);
    self[i] = self[i + len];
  end;
  local _g = pos + len;
  local _g1 = self.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    self[i] = self[i + len];
  end;
  local tmp = self;
  tmp.length = tmp.length - len;
  do return ret end
end
Array.prototype.toString = function(self) 
  local tbl = ({});
  _G.table.insert(tbl, "[");
  _G.table.insert(tbl, self:join(","));
  _G.table.insert(tbl, "]");
  do return _G.table.concat(tbl, "") end
end
Array.prototype.unshift = function(self,x) 
  local len = self.length;
  local _g = 0;
  local _g1 = len;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    self[len - i] = self[(len - i) - 1];
  end;
  self[0] = x;
end
Array.prototype.insert = function(self,pos,x) 
  if (pos > self.length) then 
    pos = self.length;
  end;
  if (pos < 0) then 
    pos = self.length + pos;
    if (pos < 0) then 
      pos = 0;
    end;
  end;
  local cur_len = self.length;
  while (cur_len > pos) do _hx_do_first_1 = false;
    
    self[cur_len] = self[cur_len - 1];
    cur_len = cur_len - 1;
  end;
  self[pos] = x;
end
Array.prototype.remove = function(self,x) 
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (self[i] == x) then 
      local _g = i;
      local _g1 = self.length - 1;
      while (_g < _g1) do _hx_do_first_2 = false;
        
        _g = _g + 1;
        local j = _g - 1;
        self[j] = self[j + 1];
      end;
      self[self.length - 1] = nil;
      self.length = self.length - 1;
      do return true end;
    end;
  end;
  do return false end
end
Array.prototype.contains = function(self,x) 
  local _g = 0;
  local _g1 = self.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (self[i] == x) then 
      do return true end;
    end;
  end;
  do return false end
end
Array.prototype.indexOf = function(self,x,fromIndex) 
  local _end = self.length;
  if (fromIndex == nil) then 
    fromIndex = 0;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        fromIndex = 0;
      end;
    end;
  end;
  local _g = fromIndex;
  local _g1 = _end;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (x == self[i]) then 
      do return i end;
    end;
  end;
  do return -1 end
end
Array.prototype.lastIndexOf = function(self,x,fromIndex) 
  if ((fromIndex == nil) or (fromIndex >= self.length)) then 
    fromIndex = self.length - 1;
  else
    if (fromIndex < 0) then 
      fromIndex = self.length + fromIndex;
      if (fromIndex < 0) then 
        do return -1 end;
      end;
    end;
  end;
  local i = fromIndex;
  while (i >= 0) do _hx_do_first_1 = false;
    
    if (self[i] == x) then 
      do return i end;
    else
      i = i - 1;
    end;
  end;
  do return -1 end
end
Array.prototype.copy = function(self) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(i);
  end;
  do return _g end
end
Array.prototype.map = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    _g:push(f(i));
  end;
  do return _g end
end
Array.prototype.filter = function(self,f) 
  local _g = _hx_tab_array({}, 0);
  local _g1 = 0;
  local _g2 = self;
  while (_g1 < _g2.length) do _hx_do_first_1 = false;
    
    local i = _g2[_g1];
    _g1 = _g1 + 1;
    if (f(i)) then 
      _g:push(i);
    end;
  end;
  do return _g end
end
Array.prototype.iterator = function(self) 
  do return __haxe_iterators_ArrayIterator.new(self) end
end
Array.prototype.keyValueIterator = function(self) 
  do return __haxe_iterators_ArrayKeyValueIterator.new(self) end
end
Array.prototype.resize = function(self,len) 
  if (self.length < len) then 
    self.length = len;
  else
    if (self.length > len) then 
      local _g = len;
      local _g1 = self.length;
      while (_g < _g1) do _hx_do_first_1 = false;
        
        _g = _g + 1;
        local i = _g - 1;
        self[i] = nil;
      end;
      self.length = len;
    end;
  end;
end

Array.prototype.__class__ =  Array

Math.new = {}
Math.__name__ = "Math"
Math.isNaN = function(f) 
  do return f ~= f end;
end
Math.isFinite = function(f) 
  if (f > -_G.math.huge) then 
    do return f < _G.math.huge end;
  else
    do return false end;
  end;
end
Math.max = function(a,b) 
  if (Math.isNaN(a) or Math.isNaN(b)) then 
    do return (0/0) end;
  else
    do return _G.math.max(a, b) end;
  end;
end
Math.min = function(a,b) 
  if (Math.isNaN(a) or Math.isNaN(b)) then 
    do return (0/0) end;
  else
    do return _G.math.min(a, b) end;
  end;
end

String.new = function(string) 
  local self = _hx_new(String.prototype)
  String.super(self,string)
  self = string
  return self
end
String.super = function(self,string) 
end
String.__name__ = "String"
String.__index = function(s,k) 
  if (k == "length") then 
    do return _G.string.len(s) end;
  else
    local o = String.prototype;
    local field = k;
    if ((function() 
      local _hx_1
      if ((_G.type(o) == "function") and not ((function() 
        local _hx_2
        if (_G.type(o) ~= "table") then 
        _hx_2 = false; else 
        _hx_2 = o.__name__; end
        return _hx_2
      end )() or (function() 
        local _hx_3
        if (_G.type(o) ~= "table") then 
        _hx_3 = false; else 
        _hx_3 = o.__ename__; end
        return _hx_3
      end )())) then 
      _hx_1 = false; elseif ((_G.type(o) == "string") and ((String.prototype[field] ~= nil) or (field == "length"))) then 
      _hx_1 = true; elseif (o.__fields__ ~= nil) then 
      _hx_1 = o.__fields__[field] ~= nil; else 
      _hx_1 = o[field] ~= nil; end
      return _hx_1
    end )()) then 
      do return String.prototype[k] end;
    else
      if (String.__oldindex ~= nil) then 
        if (_G.type(String.__oldindex) == "function") then 
          do return String.__oldindex(s, k) end;
        else
          if (_G.type(String.__oldindex) == "table") then 
            do return String.__oldindex[k] end;
          end;
        end;
        do return nil end;
      else
        do return nil end;
      end;
    end;
  end;
end
String.indexOfEmpty = function(s,startIndex) 
  local length = _G.string.len(s);
  if (startIndex < 0) then 
    startIndex = length + startIndex;
    if (startIndex < 0) then 
      startIndex = 0;
    end;
  end;
  if (startIndex > length) then 
    do return length end;
  else
    do return startIndex end;
  end;
end
String.fromCharCode = function(code) 
  do return _G.string.char(code) end;
end
String.prototype = _hx_e();
String.prototype.toUpperCase = function(self) 
  do return _G.string.upper(self) end
end
String.prototype.toLowerCase = function(self) 
  do return _G.string.lower(self) end
end
String.prototype.indexOf = function(self,str,startIndex) 
  if (startIndex == nil) then 
    startIndex = 1;
  else
    startIndex = startIndex + 1;
  end;
  if (str == "") then 
    do return String.indexOfEmpty(self, startIndex - 1) end;
  end;
  local r = _G.string.find(self, str, startIndex, true);
  if ((r ~= nil) and (r > 0)) then 
    do return r - 1 end;
  else
    do return -1 end;
  end;
end
String.prototype.lastIndexOf = function(self,str,startIndex) 
  local ret = -1;
  if (startIndex == nil) then 
    startIndex = #self;
  end;
  while (true) do _hx_do_first_1 = false;
    
    local p = String.prototype.indexOf(self, str, ret + 1);
    if (((p == -1) or (p > startIndex)) or (p == ret)) then 
      break;
    end;
    ret = p;
  end;
  do return ret end
end
String.prototype.split = function(self,delimiter) 
  local idx = 1;
  local ret = _hx_tab_array({}, 0);
  while (idx ~= nil) do _hx_do_first_1 = false;
    
    local newidx = 0;
    if (#delimiter > 0) then 
      newidx = _G.string.find(self, delimiter, idx, true);
    else
      if (idx >= #self) then 
        newidx = nil;
      else
        newidx = idx + 1;
      end;
    end;
    if (newidx ~= nil) then 
      local match = _G.string.sub(self, idx, newidx - 1);
      ret:push(match);
      idx = newidx + #delimiter;
    else
      ret:push(_G.string.sub(self, idx, #self));
      idx = nil;
    end;
  end;
  do return ret end
end
String.prototype.toString = function(self) 
  do return self end
end
String.prototype.substring = function(self,startIndex,endIndex) 
  if (endIndex == nil) then 
    endIndex = #self;
  end;
  if (endIndex < 0) then 
    endIndex = 0;
  end;
  if (startIndex < 0) then 
    startIndex = 0;
  end;
  if (endIndex < startIndex) then 
    do return _G.string.sub(self, endIndex + 1, startIndex) end;
  else
    do return _G.string.sub(self, startIndex + 1, endIndex) end;
  end;
end
String.prototype.charAt = function(self,index) 
  do return _G.string.sub(self, index + 1, index + 1) end
end
String.prototype.charCodeAt = function(self,index) 
  do return _G.string.byte(self, index + 1) end
end
String.prototype.substr = function(self,pos,len) 
  if ((len == nil) or (len > (pos + #self))) then 
    len = #self;
  else
    if (len < 0) then 
      len = #self + len;
    end;
  end;
  if (pos < 0) then 
    pos = #self + pos;
  end;
  if (pos < 0) then 
    pos = 0;
  end;
  do return _G.string.sub(self, pos + 1, pos + len) end
end

String.prototype.__class__ =  String

Std.new = {}
Std.__name__ = "Std"
Std.string = function(s) 
  do return _hx_tostring(s, 0) end;
end
Std.int = function(x) 
  if (not Math.isFinite(x) or Math.isNaN(x)) then 
    do return 0 end;
  else
    do return _hx_bit_clamp(x) end;
  end;
end

StringTools.new = {}
StringTools.__name__ = "StringTools"
StringTools.rpad = function(s,c,l) 
  if (#c <= 0) then 
    do return s end;
  end;
  local buf_b = ({});
  local buf_length = 0;
  local str = Std.string(s);
  _G.table.insert(buf_b, str);
  buf_length = buf_length + #str;
  while (buf_length < l) do _hx_do_first_1 = false;
    
    local str = Std.string(c);
    _G.table.insert(buf_b, str);
    buf_length = buf_length + #str;
  end;
  do return _G.table.concat(buf_b) end;
end
StringTools.replace = function(s,sub,by) 
  do return String.prototype.split(s, sub):join(by) end;
end

Sys.new = {}
Sys.__name__ = "Sys"
Sys.sleep = function(seconds) 
  __lua_lib_luv_Thread.sleep(_G.math.floor(seconds * 1000));
end

Type.new = {}
Type.__name__ = "Type"
Type.getClass = function(o) 
  if (o == nil) then 
    do return nil end;
  end;
  local o = o;
  if (__lua_Boot.__instanceof(o, Array)) then 
    do return Array end;
  else
    if (__lua_Boot.__instanceof(o, String)) then 
      do return String end;
    else
      local cl = o.__class__;
      if (cl ~= nil) then 
        do return cl end;
      else
        do return nil end;
      end;
    end;
  end;
end

__globals_Output.new = function() 
  local self = _hx_new(__globals_Output.prototype)
  __globals_Output.super(self)
  return self
end
__globals_Output.super = function(self) 
  self.apalette = _hx_tab_array({[0]=__globals_RGBColor.new(236, 239, 244), __globals_RGBColor.new(0, 0, 0), __globals_RGBColor.new(180, 142, 173), __globals_RGBColor.new(0, 0, 0), __globals_RGBColor.new(235, 203, 139), __globals_RGBColor.new(163, 190, 140), __globals_RGBColor.new(0, 0, 0), __globals_RGBColor.new(173, 179, 187), __globals_RGBColor.new(216, 222, 187), __globals_RGBColor.new(136, 192, 208), __globals_RGBColor.new(0, 0, 0), __globals_RGBColor.new(129, 161, 193), __globals_RGBColor.new(0, 0, 0), __globals_RGBColor.new(163, 190, 140), __globals_RGBColor.new(191, 97, 106), __globals_RGBColor.new(59, 66, 82)}, 16);
end
__globals_Output.__name__ = "globals.Output"
__globals_Output.prototype = _hx_e();
__globals_Output.prototype.print = function(self,s) 
  local words = String.prototype.split(s, " ");
  local _g = 0;
  while (_g < words.length) do _hx_do_first_1 = false;
    
    local word = words[_g];
    _g = _g + 1;
    if ((self:getCursorPos().x + #word) > self:get_size().x) then 
      self:write("\n");
    end;
    self:write(Std.string(word) .. Std.string(" "));
  end;
end
__globals_Output.prototype.get_palette = function(self) 
  do return self.apalette end
end
__globals_Output.prototype.set_size = function(self,s) 
  do return self:get_size() end
end

__globals_Output.prototype.__class__ =  __globals_Output

__drivers_terminal_TerminalBackend.new = function() 
  local self = _hx_new(__drivers_terminal_TerminalBackend.prototype)
  __drivers_terminal_TerminalBackend.super(self)
  return self
end
__drivers_terminal_TerminalBackend.super = function(self) 
  __globals_Output.super(self);
  self:set_palette(self:get_palette());
end
__drivers_terminal_TerminalBackend.__name__ = "drivers.terminal.TerminalBackend"
__drivers_terminal_TerminalBackend.prototype = _hx_e();
__drivers_terminal_TerminalBackend.prototype.write = function(self,s) 
  local _g = 0;
  local _g1 = #s;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (_G.string.sub(s, i + 1, i + 1) == "\n") then 
      local _hx_1_o_x, _hx_1_o_y = term.getCursorPos();
      term.setCursorPos(1, _hx_1_o_y);
      self:setCursorPosRelative(0, 1);
    else
      term.write(_G.string.sub(s, i + 1, i + 1));
    end;
  end;
end
__drivers_terminal_TerminalBackend.prototype.clear = function(self) 
  term.clear();
end
__drivers_terminal_TerminalBackend.prototype.setFGColor = function(self,col) 
  term.setTextColor(col.bitASC);
end
__drivers_terminal_TerminalBackend.prototype.setBGColor = function(self,col) 
  term.setBackgroundColor(col.bitASC);
end
__drivers_terminal_TerminalBackend.prototype.setCursorPos = function(self,x,y) 
  term.setCursorPos(x, y);
end
__drivers_terminal_TerminalBackend.prototype.getCursorPos = function(self) 
  do return __globals_Vector2i.fromCPos(_hx_box_mr(_hx_table.pack(term.getCursorPos()), {"x", "y"})) end
end
__drivers_terminal_TerminalBackend.prototype.setCursorPosRelative = function(self,x,y) 
  local o = _hx_box_mr(_hx_table.pack(term.getCursorPos()), {"x", "y"});
  local o1 = o;
  o1.x = o1.x + x;
  local o1 = o;
  o1.y = o1.y + y;
  term.setCursorPos(o.x, o.y);
  if (o.y > _G.select(2, term.getSize())) then 
    term.scroll(((o.y - _G.select(2, term.getSize())) - 2) * -1);
    term.setCursorPos(o.x, _G.select(2, term.getSize()));
  end;
end
__drivers_terminal_TerminalBackend.prototype.get_size = function(self) 
  do return __globals_Vector2i.fromCPos(_hx_box_mr(_hx_table.pack(term.getSize()), {"x", "y"})) end
end
__drivers_terminal_TerminalBackend.prototype.set_palette = function(self,newc) 
  local i = 0;
  local _g = 0;
  while (_g < newc.length) do _hx_do_first_1 = false;
    
    local color = newc[_g];
    _g = _g + 1;
    self.apalette[i - 1] = color;
    term.setPaletteColor(Std.int(Math.max(_G.math.pow(2, i), 1)), color.red / 255.0, color.green / 255.0, color.blue / 255.0);
    i = i + 1;
  end;
  do return self.apalette end
end

__drivers_terminal_TerminalBackend.prototype.__class__ =  __drivers_terminal_TerminalBackend
__drivers_terminal_TerminalBackend.__super__ = __globals_Output
setmetatable(__drivers_terminal_TerminalBackend.prototype,{__index=__globals_Output.prototype})

__drivers_terminal_Terminal.new = function() 
  local self = _hx_new(__drivers_terminal_Terminal.prototype)
  __drivers_terminal_Terminal.super(self)
  return self
end
__drivers_terminal_Terminal.super = function(self) 
  __drivers_terminal_TerminalBackend.super(self);
end
__drivers_terminal_Terminal.__name__ = "drivers.terminal.Terminal"
__drivers_terminal_Terminal.prototype = _hx_e();

__drivers_terminal_Terminal.prototype.__class__ =  __drivers_terminal_Terminal
__drivers_terminal_Terminal.__super__ = __drivers_terminal_TerminalBackend
setmetatable(__drivers_terminal_Terminal.prototype,{__index=__drivers_terminal_TerminalBackend.prototype})

__globals_FilePath.new = function(sPath) 
  local self = _hx_new(__globals_FilePath.prototype)
  __globals_FilePath.super(self,sPath)
  return self
end
__globals_FilePath.super = function(self,sPath) 
  self.path = _hx_tab_array({}, 0);
  self.path = String.prototype.split(sPath, "/");
  local newp = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = self.path;
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local s = _g1[_g];
    _g = _g + 1;
    if (s == "..") then 
      newp:pop();
    else
      if (not ((s == ".") or (s == ""))) then 
        local pos = newp.length;
        if (pos > newp.length) then 
          pos = newp.length;
        end;
        if (pos < 0) then 
          pos = newp.length + pos;
          if (pos < 0) then 
            pos = 0;
          end;
        end;
        local cur_len = newp.length;
        while (cur_len > pos) do _hx_do_first_2 = false;
          
          newp[cur_len] = newp[cur_len - 1];
          cur_len = cur_len - 1;
        end;
        newp[pos] = s;
      end;
    end;
  end;
  self.path = newp;
end
__globals_FilePath.__name__ = "globals.FilePath"
__globals_FilePath.prototype = _hx_e();
__globals_FilePath.prototype.add = function(self,s) 
  local newPath = self.path;
  local pos = newPath.length;
  if (pos > newPath.length) then 
    pos = newPath.length;
  end;
  if (pos < 0) then 
    pos = newPath.length + pos;
    if (pos < 0) then 
      pos = 0;
    end;
  end;
  local cur_len = newPath.length;
  while (cur_len > pos) do _hx_do_first_1 = false;
    
    newPath[cur_len] = newPath[cur_len - 1];
    cur_len = cur_len - 1;
  end;
  newPath[pos] = s;
  do return __globals_FilePath.new(newPath:join("/")) end
end

__globals_FilePath.prototype.__class__ =  __globals_FilePath

__globals_Vector2i.new = function(x,y) 
  local self = _hx_new(__globals_Vector2i.prototype)
  __globals_Vector2i.super(self,x,y)
  return self
end
__globals_Vector2i.super = function(self,x,y) 
  self.x = x;
  self.y = y;
end
__globals_Vector2i.__name__ = "globals.Vector2i"
__globals_Vector2i.fromCPos = function(a) 
  do return __globals_Vector2i.new(a.x, a.y) end;
end
__globals_Vector2i.prototype = _hx_e();

__globals_Vector2i.prototype.__class__ =  __globals_Vector2i

__globals_Vector2f.new = function(x,y) 
  local self = _hx_new(__globals_Vector2f.prototype)
  __globals_Vector2f.super(self,x,y)
  return self
end
__globals_Vector2f.super = function(self,x,y) 
  self.x = x;
  self.y = y;
end
__globals_Vector2f.__name__ = "globals.Vector2f"
__globals_Vector2f.prototype = _hx_e();

__globals_Vector2f.prototype.__class__ =  __globals_Vector2f

__globals_Globals.new = {}
__globals_Globals.__name__ = "globals.Globals"

__globals_Color.new = function(palNumber,bitASC) 
  local self = _hx_new(__globals_Color.prototype)
  __globals_Color.super(self,palNumber,bitASC)
  return self
end
__globals_Color.super = function(self,palNumber,bitASC) 
  self.palNumber = palNumber;
  self.bitASC = bitASC;
end
__globals_Color.__name__ = "globals.Color"
__globals_Color.prototype = _hx_e();

__globals_Color.prototype.__class__ =  __globals_Color

__globals_RGBColor.new = function(r,g,b) 
  local self = _hx_new(__globals_RGBColor.prototype)
  __globals_RGBColor.super(self,r,g,b)
  return self
end
__globals_RGBColor.super = function(self,r,g,b) 
  self.red = r;
  self.green = g;
  self.blue = b;
end
__globals_RGBColor.__name__ = "globals.RGBColor"
__globals_RGBColor.prototype = _hx_e();

__globals_RGBColor.prototype.__class__ =  __globals_RGBColor

__globals_Colors.new = {}
__globals_Colors.__name__ = "globals.Colors"

__globals_Input.new = {}
__globals_Input.__name__ = "globals.Input"
__globals_Input.prototype = _hx_e();

__globals_Input.prototype.__class__ =  __globals_Input

__haxe_IMap.new = {}
__haxe_IMap.__name__ = "haxe.IMap"
__haxe_IMap.prototype = _hx_e();

__haxe_IMap.prototype.__class__ =  __haxe_IMap

__haxe_Exception.new = function(message,previous,native) 
  local self = _hx_new(__haxe_Exception.prototype)
  __haxe_Exception.super(self,message,previous,native)
  return self
end
__haxe_Exception.super = function(self,message,previous,native) 
  self.__skipStack = 0;
  self.__exceptionMessage = message;
  self.__previousException = previous;
  if (native ~= nil) then 
    self.__nativeException = native;
    self.__nativeStack = __haxe_NativeStackTrace.exceptionStack();
  else
    self.__nativeException = self;
    self.__nativeStack = __haxe_NativeStackTrace.callStack();
    self.__skipStack = 1;
  end;
end
__haxe_Exception.__name__ = "haxe.Exception"
__haxe_Exception.caught = function(value) 
  if (__lua_Boot.__instanceof(value, __haxe_Exception)) then 
    do return value end;
  else
    do return __haxe_ValueException.new(value, nil, value) end;
  end;
end
__haxe_Exception.thrown = function(value) 
  if (__lua_Boot.__instanceof(value, __haxe_Exception)) then 
    do return value:get_native() end;
  else
    local e = __haxe_ValueException.new(value);
    e.__skipStack = e.__skipStack + 1;
    do return e end;
  end;
end
__haxe_Exception.prototype = _hx_e();
__haxe_Exception.prototype.unwrap = function(self) 
  do return self.__nativeException end
end
__haxe_Exception.prototype.toString = function(self) 
  do return self:get_message() end
end
__haxe_Exception.prototype.get_message = function(self) 
  do return self.__exceptionMessage end
end
__haxe_Exception.prototype.get_native = function(self) 
  do return self.__nativeException end
end

__haxe_Exception.prototype.__class__ =  __haxe_Exception

__haxe_Log.new = {}
__haxe_Log.__name__ = "haxe.Log"
__haxe_Log.formatOutput = function(v,infos) 
  local str = Std.string(v);
  if (infos == nil) then 
    do return str end;
  end;
  local pstr = Std.string(Std.string(infos.fileName) .. Std.string(":")) .. Std.string(infos.lineNumber);
  if (infos.customParams ~= nil) then 
    local _g = 0;
    local _g1 = infos.customParams;
    while (_g < _g1.length) do _hx_do_first_1 = false;
      
      local v = _g1[_g];
      _g = _g + 1;
      str = Std.string(str) .. Std.string((Std.string(", ") .. Std.string(Std.string(v))));
    end;
  end;
  do return Std.string(Std.string(pstr) .. Std.string(": ")) .. Std.string(str) end;
end
__haxe_Log.trace = function(v,infos) 
  local str = __haxe_Log.formatOutput(v, infos);
  _hx_print(str);
end

__haxe_NativeStackTrace.new = {}
__haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace"
__haxe_NativeStackTrace.saveStack = function(exception) 
end
__haxe_NativeStackTrace.callStack = function() 
  local _g = debug.traceback();
  if (_g == nil) then 
    do return _hx_tab_array({}, 0) end;
  else
    local s = _g;
    do return String.prototype.split(s, "\n"):slice(3) end;
  end;
end
__haxe_NativeStackTrace.exceptionStack = function() 
  do return _hx_tab_array({}, 0) end;
end

__haxe__Rest_Rest_Impl_.new = {}
__haxe__Rest_Rest_Impl_.__name__ = "haxe._Rest.Rest_Impl_"
__haxe__Rest_Rest_Impl_.of = function(array) 
  local ret = ({});
  local _g = 0;
  local _g1 = array.length;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local idx = _g - 1;
    ret[idx + 1] = array[idx];
  end;
  do return ret end;
end

__haxe_ValueException.new = function(value,previous,native) 
  local self = _hx_new(__haxe_ValueException.prototype)
  __haxe_ValueException.super(self,value,previous,native)
  return self
end
__haxe_ValueException.super = function(self,value,previous,native) 
  __haxe_Exception.super(self,(function() 
    local _hx_1
    if (value == nil) then 
    _hx_1 = "null"; else 
    _hx_1 = Std.string(value); end
    return _hx_1
  end )(),previous,native);
  self.value = value;
end
__haxe_ValueException.__name__ = "haxe.ValueException"
__haxe_ValueException.prototype = _hx_e();
__haxe_ValueException.prototype.unwrap = function(self) 
  do return self.value end
end

__haxe_ValueException.prototype.__class__ =  __haxe_ValueException
__haxe_ValueException.__super__ = __haxe_Exception
setmetatable(__haxe_ValueException.prototype,{__index=__haxe_Exception.prototype})

__haxe_ds_ObjectMap.new = function() 
  local self = _hx_new(__haxe_ds_ObjectMap.prototype)
  __haxe_ds_ObjectMap.super(self)
  return self
end
__haxe_ds_ObjectMap.super = function(self) 
  self.h = ({});
  self.k = ({});
end
__haxe_ds_ObjectMap.__name__ = "haxe.ds.ObjectMap"
__haxe_ds_ObjectMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_ObjectMap.prototype = _hx_e();
__haxe_ds_ObjectMap.prototype.get = function(self,key) 
  do return self.h[key] end
end
__haxe_ds_ObjectMap.prototype.keys = function(self) 
  local _gthis = self;
  local cur = next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = next(_gthis.h, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end

__haxe_ds_ObjectMap.prototype.__class__ =  __haxe_ds_ObjectMap

__haxe_ds_StringMap.new = function() 
  local self = _hx_new(__haxe_ds_StringMap.prototype)
  __haxe_ds_StringMap.super(self)
  return self
end
__haxe_ds_StringMap.super = function(self) 
  self.h = ({});
end
__haxe_ds_StringMap.__name__ = "haxe.ds.StringMap"
__haxe_ds_StringMap.__interfaces__ = {__haxe_IMap}
__haxe_ds_StringMap.prototype = _hx_e();
__haxe_ds_StringMap.prototype.get = function(self,key) 
  local ret = self.h[key];
  if (ret == __haxe_ds_StringMap.tnull) then 
    do return nil end;
  end;
  do return ret end
end
__haxe_ds_StringMap.prototype.keys = function(self) 
  local _gthis = self;
  local next = _G.next;
  local cur = next(self.h, nil);
  do return _hx_o({__fields__={next=true,hasNext=true},next=function(self) 
    local ret = cur;
    cur = next(_gthis.h, cur);
    do return ret end;
  end,hasNext=function(self) 
    do return cur ~= nil end;
  end}) end
end

__haxe_ds_StringMap.prototype.__class__ =  __haxe_ds_StringMap

__haxe_exceptions_PosException.new = function(message,previous,pos) 
  local self = _hx_new(__haxe_exceptions_PosException.prototype)
  __haxe_exceptions_PosException.super(self,message,previous,pos)
  return self
end
__haxe_exceptions_PosException.super = function(self,message,previous,pos) 
  __haxe_Exception.super(self,message,previous);
  if (pos == nil) then 
    self.posInfos = _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="(unknown)",lineNumber=0,className="(unknown)",methodName="(unknown)"});
  else
    self.posInfos = pos;
  end;
end
__haxe_exceptions_PosException.__name__ = "haxe.exceptions.PosException"
__haxe_exceptions_PosException.prototype = _hx_e();
__haxe_exceptions_PosException.prototype.toString = function(self) 
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("") .. Std.string(__haxe_Exception.prototype.toString(self))) .. Std.string(" in ")) .. Std.string(self.posInfos.className)) .. Std.string(".")) .. Std.string(self.posInfos.methodName)) .. Std.string(" at ")) .. Std.string(self.posInfos.fileName)) .. Std.string(":")) .. Std.string(self.posInfos.lineNumber) end
end

__haxe_exceptions_PosException.prototype.__class__ =  __haxe_exceptions_PosException
__haxe_exceptions_PosException.__super__ = __haxe_Exception
setmetatable(__haxe_exceptions_PosException.prototype,{__index=__haxe_Exception.prototype})

__haxe_exceptions_ArgumentException.new = function(argument,message,previous,pos) 
  local self = _hx_new(__haxe_exceptions_ArgumentException.prototype)
  __haxe_exceptions_ArgumentException.super(self,argument,message,previous,pos)
  return self
end
__haxe_exceptions_ArgumentException.super = function(self,argument,message,previous,pos) 
  __haxe_exceptions_PosException.super(self,(function() 
    local _hx_1
    if (message == nil) then 
    _hx_1 = Std.string(Std.string("Invalid argument \"") .. Std.string(argument)) .. Std.string("\""); else 
    _hx_1 = message; end
    return _hx_1
  end )(),previous,pos);
  self.argument = argument;
end
__haxe_exceptions_ArgumentException.__name__ = "haxe.exceptions.ArgumentException"
__haxe_exceptions_ArgumentException.prototype = _hx_e();

__haxe_exceptions_ArgumentException.prototype.__class__ =  __haxe_exceptions_ArgumentException
__haxe_exceptions_ArgumentException.__super__ = __haxe_exceptions_PosException
setmetatable(__haxe_exceptions_ArgumentException.prototype,{__index=__haxe_exceptions_PosException.prototype})

__haxe_exceptions_NotImplementedException.new = function(message,previous,pos) 
  local self = _hx_new(__haxe_exceptions_NotImplementedException.prototype)
  __haxe_exceptions_NotImplementedException.super(self,message,previous,pos)
  return self
end
__haxe_exceptions_NotImplementedException.super = function(self,message,previous,pos) 
  if (message == nil) then 
    message = "Not implemented";
  end;
  __haxe_exceptions_PosException.super(self,message,previous,pos);
end
__haxe_exceptions_NotImplementedException.__name__ = "haxe.exceptions.NotImplementedException"
__haxe_exceptions_NotImplementedException.prototype = _hx_e();

__haxe_exceptions_NotImplementedException.prototype.__class__ =  __haxe_exceptions_NotImplementedException
__haxe_exceptions_NotImplementedException.__super__ = __haxe_exceptions_PosException
setmetatable(__haxe_exceptions_NotImplementedException.prototype,{__index=__haxe_exceptions_PosException.prototype})

__haxe_iterators_ArrayIterator.new = function(array) 
  local self = _hx_new(__haxe_iterators_ArrayIterator.prototype)
  __haxe_iterators_ArrayIterator.super(self,array)
  return self
end
__haxe_iterators_ArrayIterator.super = function(self,array) 
  self.current = 0;
  self.array = array;
end
__haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator"
__haxe_iterators_ArrayIterator.prototype = _hx_e();
__haxe_iterators_ArrayIterator.prototype.hasNext = function(self) 
  do return self.current < self.array.length end
end
__haxe_iterators_ArrayIterator.prototype.next = function(self) 
  do return self.array[(function() 
  local _hx_obj = self;
  local _hx_fld = 'current';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)()] end
end

__haxe_iterators_ArrayIterator.prototype.__class__ =  __haxe_iterators_ArrayIterator

__haxe_iterators_ArrayKeyValueIterator.new = function(array) 
  local self = _hx_new(__haxe_iterators_ArrayKeyValueIterator.prototype)
  __haxe_iterators_ArrayKeyValueIterator.super(self,array)
  return self
end
__haxe_iterators_ArrayKeyValueIterator.super = function(self,array) 
  self.current = 0;
  self.array = array;
end
__haxe_iterators_ArrayKeyValueIterator.__name__ = "haxe.iterators.ArrayKeyValueIterator"
__haxe_iterators_ArrayKeyValueIterator.prototype = _hx_e();
__haxe_iterators_ArrayKeyValueIterator.prototype.hasNext = function(self) 
  do return self.current < self.array.length end
end
__haxe_iterators_ArrayKeyValueIterator.prototype.next = function(self) 
  do return _hx_o({__fields__={value=true,key=true},value=self.array[self.current],key=(function() 
  local _hx_obj = self;
  local _hx_fld = 'current';
  local _ = _hx_obj[_hx_fld];
  _hx_obj[_hx_fld] = _hx_obj[_hx_fld]  + 1;
   return _;
   end)()}) end
end

__haxe_iterators_ArrayKeyValueIterator.prototype.__class__ =  __haxe_iterators_ArrayKeyValueIterator

__haxe_macro_Error.new = function(message,pos,previous) 
  local self = _hx_new(__haxe_macro_Error.prototype)
  __haxe_macro_Error.super(self,message,pos,previous)
  return self
end
__haxe_macro_Error.super = function(self,message,pos,previous) 
  __haxe_Exception.super(self,message,previous);
  self.pos = pos;
end
__haxe_macro_Error.__name__ = "haxe.macro.Error"
__haxe_macro_Error.prototype = _hx_e();

__haxe_macro_Error.prototype.__class__ =  __haxe_macro_Error
__haxe_macro_Error.__super__ = __haxe_Exception
setmetatable(__haxe_macro_Error.prototype,{__index=__haxe_Exception.prototype})
_hxClasses["kernel.MouseEventType"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Click","ClickUp","Drag","Scroll"},4)}
__kernel_MouseEventType = _hxClasses["kernel.MouseEventType"];
__kernel_MouseEventType.Click = _hx_tab_array({[0]="Click",0,__enum__ = __kernel_MouseEventType},2)

__kernel_MouseEventType.ClickUp = _hx_tab_array({[0]="ClickUp",1,__enum__ = __kernel_MouseEventType},2)

__kernel_MouseEventType.Drag = _hx_tab_array({[0]="Drag",2,__enum__ = __kernel_MouseEventType},2)

__kernel_MouseEventType.Scroll = _hx_tab_array({[0]="Scroll",3,__enum__ = __kernel_MouseEventType},2)

_hxClasses["kernel.MouseButton"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="None","Left","Right","Middle"},4)}
__kernel_MouseButton = _hxClasses["kernel.MouseButton"];
__kernel_MouseButton.None = _hx_tab_array({[0]="None",0,__enum__ = __kernel_MouseButton},2)

__kernel_MouseButton.Left = _hx_tab_array({[0]="Left",1,__enum__ = __kernel_MouseButton},2)

__kernel_MouseButton.Right = _hx_tab_array({[0]="Right",2,__enum__ = __kernel_MouseButton},2)

__kernel_MouseButton.Middle = _hx_tab_array({[0]="Middle",3,__enum__ = __kernel_MouseButton},2)


__kernel_MouseEvent.new = function(type,x,y,button) 
  local self = _hx_new(__kernel_MouseEvent.prototype)
  __kernel_MouseEvent.super(self,type,x,y,button)
  return self
end
__kernel_MouseEvent.super = function(self,type,x,y,button) 
  self.type = __kernel_MouseEventType.Click;
  self.button = 0;
  self.y = 0;
  self.x = 0;
  self.type = type;
  self.x = x;
  self.y = y;
  self.button = button;
end
__kernel_MouseEvent.__name__ = "kernel.MouseEvent"
__kernel_MouseEvent.prototype = _hx_e();

__kernel_MouseEvent.prototype.__class__ =  __kernel_MouseEvent
_hxClasses["kernel.DriverProvides"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Keyboard","Mouse","Terminal","Sound","Disk","Http","Network","Clock","Custom"},9)}
__kernel_DriverProvides = _hxClasses["kernel.DriverProvides"];
__kernel_DriverProvides.Keyboard = _hx_tab_array({[0]="Keyboard",0,__enum__ = __kernel_DriverProvides},2)

__kernel_DriverProvides.Mouse = _hx_tab_array({[0]="Mouse",1,__enum__ = __kernel_DriverProvides},2)

__kernel_DriverProvides.Terminal = _hx_tab_array({[0]="Terminal",2,__enum__ = __kernel_DriverProvides},2)

__kernel_DriverProvides.Sound = _hx_tab_array({[0]="Sound",3,__enum__ = __kernel_DriverProvides},2)

__kernel_DriverProvides.Disk = _hx_tab_array({[0]="Disk",4,__enum__ = __kernel_DriverProvides},2)

__kernel_DriverProvides.Http = _hx_tab_array({[0]="Http",5,__enum__ = __kernel_DriverProvides},2)

__kernel_DriverProvides.Network = _hx_tab_array({[0]="Network",6,__enum__ = __kernel_DriverProvides},2)

__kernel_DriverProvides.Clock = _hx_tab_array({[0]="Clock",7,__enum__ = __kernel_DriverProvides},2)

__kernel_DriverProvides.Custom = function(name) local _x = _hx_tab_array({[0]="Custom",8,name,__enum__=__kernel_DriverProvides}, 3); return _x; end 

__kernel_Driver.new = {}
__kernel_Driver.__name__ = "kernel.Driver"
__kernel_Driver.prototype = _hx_e();

__kernel_Driver.prototype.__class__ =  __kernel_Driver

__kernel_KeyboardDriver.new = function() 
  local self = _hx_new(__kernel_KeyboardDriver.prototype)
  __kernel_KeyboardDriver.super(self)
  return self
end
__kernel_KeyboardDriver.super = function(self) 
  self.provides = __kernel_DriverProvides.Keyboard;
end
__kernel_KeyboardDriver.__name__ = "kernel.KeyboardDriver"
__kernel_KeyboardDriver.prototype = _hx_e();
__kernel_KeyboardDriver.prototype.readLine = function(self,timeout,echo,echoOutput,showCursor) 
  if (showCursor == nil) then 
    showCursor = false;
  end;
  if (echo == nil) then 
    echo = "/";
  end;
  if (timeout == nil) then 
    timeout = -1;
  end;
  Sys.sleep(0.1);
  local ch = "";
  local cursorPos = 0;
  local ocp = __globals_Vector2i.new(1, 1);
  if (echoOutput ~= nil) then 
    ocp = echoOutput:getCursorPos();
  end;
  local redraw = function() 
    if (echoOutput ~= nil) then 
      echoOutput:setCursorPos(ocp.x, ocp.y);
      local ech = Std.string(ch) .. Std.string("");
      if (echo ~= "/") then 
        ech = StringTools.rpad("", echo, #ech);
      end;
      echoOutput:write(Std.string(Std.string(Std.string(String.prototype.substr(ech, 0, cursorPos)) .. Std.string(((function() 
        local _hx_1
        if (showCursor) then 
        _hx_1 = "_"; else 
        _hx_1 = ""; end
        return _hx_1
      end )()))) .. Std.string(String.prototype.substr(ech, cursorPos))) .. Std.string(" "));
    end;
  end;
  redraw();
  while (true) do _hx_do_first_1 = false;
    
    local e = self:readInt();
    __haxe_Log.trace(e, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/kernel/Driver.hx",lineNumber=93,className="kernel.KeyboardDriver",methodName="readLine"}));
    if ((e >= keys.q) and (e <= keys.m)) then 
      local ea = self:readChar();
      ch = Std.string(Std.string(String.prototype.substr(ch, 0, cursorPos)) .. Std.string(ea)) .. Std.string(String.prototype.substr(ch, cursorPos));
      cursorPos = cursorPos + 1;
    else
      if (e == keys.backspace) then 
        ch = Std.string(String.prototype.substr(ch, 0, cursorPos - 1)) .. Std.string(String.prototype.substr(ch, cursorPos));
        cursorPos = cursorPos - 1;
      else
        if (e == keys.enter) then 
          showCursor = false;
          redraw();
          if (echoOutput ~= nil) then 
            echoOutput:write("\n");
          end;
          do return ch end;
        else
          if (e == keys.left) then 
            cursorPos = Std.int(Math.max(cursorPos - 1, 0));
          end;
        end;
      end;
    end;
    if (e == keys.right) then 
      cursorPos = Std.int(Math.min(cursorPos + 1, #ch));
    end;
    redraw();
  end;
end

__kernel_KeyboardDriver.prototype.__class__ =  __kernel_KeyboardDriver
__kernel_KeyboardDriver.__super__ = __kernel_Driver
setmetatable(__kernel_KeyboardDriver.prototype,{__index=__kernel_Driver.prototype})
_hxClasses["kernel.FileType"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Directory","File","Link","Device"},4)}
__kernel_FileType = _hxClasses["kernel.FileType"];
__kernel_FileType.Directory = _hx_tab_array({[0]="Directory",0,__enum__ = __kernel_FileType},2)

__kernel_FileType.File = _hx_tab_array({[0]="File",1,__enum__ = __kernel_FileType},2)

__kernel_FileType.Link = _hx_tab_array({[0]="Link",2,__enum__ = __kernel_FileType},2)

__kernel_FileType.Device = _hx_tab_array({[0]="Device",3,__enum__ = __kernel_FileType},2)


__kernel_FileSystemDriver.new = function() 
  local self = _hx_new(__kernel_FileSystemDriver.prototype)
  __kernel_FileSystemDriver.super(self)
  return self
end
__kernel_FileSystemDriver.super = function(self) 
  self.provides = __kernel_DriverProvides.Disk;
end
__kernel_FileSystemDriver.__name__ = "kernel.FileSystemDriver"
__kernel_FileSystemDriver.prototype = _hx_e();

__kernel_FileSystemDriver.prototype.__class__ =  __kernel_FileSystemDriver
__kernel_FileSystemDriver.__super__ = __kernel_Driver
setmetatable(__kernel_FileSystemDriver.prototype,{__index=__kernel_Driver.prototype})

__kernel_MouseDriver.new = function() 
  local self = _hx_new(__kernel_MouseDriver.prototype)
  __kernel_MouseDriver.super(self)
  return self
end
__kernel_MouseDriver.super = function(self) 
  self.provides = __kernel_DriverProvides.Mouse;
end
__kernel_MouseDriver.__name__ = "kernel.MouseDriver"
__kernel_MouseDriver.prototype = _hx_e();

__kernel_MouseDriver.prototype.__class__ =  __kernel_MouseDriver
__kernel_MouseDriver.__super__ = __kernel_Driver
setmetatable(__kernel_MouseDriver.prototype,{__index=__kernel_Driver.prototype})

__kernel__Driver_TDOutput.new = function(td) 
  local self = _hx_new(__kernel__Driver_TDOutput.prototype)
  __kernel__Driver_TDOutput.super(self,td)
  return self
end
__kernel__Driver_TDOutput.super = function(self,td) 
  self.td = nil;
  __globals_Output.super(self);
  self.td = td;
end
__kernel__Driver_TDOutput.__name__ = "kernel._Driver.TDOutput"
__kernel__Driver_TDOutput.prototype = _hx_e();
__kernel__Driver_TDOutput.prototype.write = function(self,s) 
  self.td:write(s);
end
__kernel__Driver_TDOutput.prototype.clear = function(self) 
  self.td:clear();
end
__kernel__Driver_TDOutput.prototype.setFGColor = function(self,col) 
  self.td:setFGColor(col);
end
__kernel__Driver_TDOutput.prototype.setBGColor = function(self,col) 
  self.td:setBGColor(col);
end
__kernel__Driver_TDOutput.prototype.set_palette = function(self,newc) 
  do return self.td:set_palette(newc) end
end
__kernel__Driver_TDOutput.prototype.getCursorPos = function(self) 
  do return self.td:getCursorPos() end
end
__kernel__Driver_TDOutput.prototype.setCursorPos = function(self,x,y) 
  self.td:setCursorPos(x, y);
end
__kernel__Driver_TDOutput.prototype.setCursorPosRelative = function(self,x,y) 
  self.td:setCursorPosRelative(x, y);
end
__kernel__Driver_TDOutput.prototype.get_size = function(self) 
  do return self.td:get_size() end
end

__kernel__Driver_TDOutput.prototype.__class__ =  __kernel__Driver_TDOutput
__kernel__Driver_TDOutput.__super__ = __globals_Output
setmetatable(__kernel__Driver_TDOutput.prototype,{__index=__globals_Output.prototype})

__kernel_TerminalDriver.new = function() 
  local self = _hx_new(__kernel_TerminalDriver.prototype)
  __kernel_TerminalDriver.super(self)
  return self
end
__kernel_TerminalDriver.super = function(self) 
  self.apalette = _hx_tab_array({[0]=__globals_RGBColor.new(236, 239, 244), __globals_RGBColor.new(0, 0, 0), __globals_RGBColor.new(180, 142, 173), __globals_RGBColor.new(0, 0, 0), __globals_RGBColor.new(235, 203, 139), __globals_RGBColor.new(163, 190, 140), __globals_RGBColor.new(0, 0, 0), __globals_RGBColor.new(173, 179, 187), __globals_RGBColor.new(216, 222, 187), __globals_RGBColor.new(136, 192, 208), __globals_RGBColor.new(0, 0, 0), __globals_RGBColor.new(129, 161, 193), __globals_RGBColor.new(0, 0, 0), __globals_RGBColor.new(163, 190, 140), __globals_RGBColor.new(191, 97, 106), __globals_RGBColor.new(59, 66, 82)}, 16);
  self.provides = __kernel_DriverProvides.Terminal;
end
__kernel_TerminalDriver.__name__ = "kernel.TerminalDriver"
__kernel_TerminalDriver.prototype = _hx_e();
__kernel_TerminalDriver.prototype.print = function(self,s) 
  local _g = 0;
  local _g1 = #s;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
  end;
end
__kernel_TerminalDriver.prototype.get_palette = function(self) 
  do return self.apalette end
end
__kernel_TerminalDriver.prototype.set_size = function(self,s) 
  do return self:get_size() end
end
__kernel_TerminalDriver.prototype.asOutput = function(self) 
  do return __kernel__Driver_TDOutput.new(self) end
end

__kernel_TerminalDriver.prototype.__class__ =  __kernel_TerminalDriver
__kernel_TerminalDriver.__super__ = __kernel_Driver
setmetatable(__kernel_TerminalDriver.prototype,{__index=__kernel_Driver.prototype})

__kernel_SoundDriver.new = function() 
  local self = _hx_new(__kernel_SoundDriver.prototype)
  __kernel_SoundDriver.super(self)
  return self
end
__kernel_SoundDriver.super = function(self) 
  self.provides = __kernel_DriverProvides.Sound;
end
__kernel_SoundDriver.__name__ = "kernel.SoundDriver"
__kernel_SoundDriver.prototype = _hx_e();

__kernel_SoundDriver.prototype.__class__ =  __kernel_SoundDriver
__kernel_SoundDriver.__super__ = __kernel_Driver
setmetatable(__kernel_SoundDriver.prototype,{__index=__kernel_Driver.prototype})
_hxClasses["kernel.RequestType"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="Post","Get"},2)}
__kernel_RequestType = _hxClasses["kernel.RequestType"];
__kernel_RequestType.Post = _hx_tab_array({[0]="Post",0,__enum__ = __kernel_RequestType},2)

__kernel_RequestType.Get = _hx_tab_array({[0]="Get",1,__enum__ = __kernel_RequestType},2)

_hxClasses["kernel.Since"] = { __ename__ = true, __constructs__ = _hx_tab_array({[0]="ComputerStart","UnixEpoch"},2)}
__kernel_Since = _hxClasses["kernel.Since"];
__kernel_Since.ComputerStart = _hx_tab_array({[0]="ComputerStart",0,__enum__ = __kernel_Since},2)

__kernel_Since.UnixEpoch = _hx_tab_array({[0]="UnixEpoch",1,__enum__ = __kernel_Since},2)


__kernel_HttpDriver.new = function() 
  local self = _hx_new(__kernel_HttpDriver.prototype)
  __kernel_HttpDriver.super(self)
  return self
end
__kernel_HttpDriver.super = function(self) 
  self.provides = __kernel_DriverProvides.Http;
end
__kernel_HttpDriver.__name__ = "kernel.HttpDriver"
__kernel_HttpDriver.prototype = _hx_e();

__kernel_HttpDriver.prototype.__class__ =  __kernel_HttpDriver
__kernel_HttpDriver.__super__ = __kernel_Driver
setmetatable(__kernel_HttpDriver.prototype,{__index=__kernel_Driver.prototype})

__kernel_ClockDriver.new = function() 
  local self = _hx_new(__kernel_ClockDriver.prototype)
  __kernel_ClockDriver.super(self)
  return self
end
__kernel_ClockDriver.super = function(self) 
  self.provides = __kernel_DriverProvides.Clock;
end
__kernel_ClockDriver.__name__ = "kernel.ClockDriver"
__kernel_ClockDriver.prototype = _hx_e();

__kernel_ClockDriver.prototype.__class__ =  __kernel_ClockDriver
__kernel_ClockDriver.__super__ = __kernel_Driver
setmetatable(__kernel_ClockDriver.prototype,{__index=__kernel_Driver.prototype})

drv.new = {}
drv.__name__ = "drv"
drv.getDriversByType = function(type) 
  local out = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = drv.get_drivers();
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local driver = _g1[_g];
    _g = _g + 1;
    if (__lua_Boot.__instanceof(driver, type)) then 
      local pos = out.length;
      if (pos > out.length) then 
        pos = out.length;
      end;
      if (pos < 0) then 
        pos = out.length + pos;
        if (pos < 0) then 
          pos = 0;
        end;
      end;
      local cur_len = out.length;
      while (cur_len > pos) do _hx_do_first_2 = false;
        
        out[cur_len] = out[cur_len - 1];
        cur_len = cur_len - 1;
      end;
      out[pos] = driver;
    end;
  end;
  do return out end;
end
drv.getDriverByType = function(type) 
  local gd = drv.getDriversByType(type);
  if (gd.length > 0) then 
    do return gd[0] end;
  end;
  do return nil end;
end
drv.getDriversByProvides = function(p) 
  local out = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = drv.get_drivers();
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local driver = _g1[_g];
    _g = _g + 1;
    if (driver.provides == p) then 
      local pos = out.length;
      if (pos > out.length) then 
        pos = out.length;
      end;
      if (pos < 0) then 
        pos = out.length + pos;
        if (pos < 0) then 
          pos = 0;
        end;
      end;
      local cur_len = out.length;
      while (cur_len > pos) do _hx_do_first_2 = false;
        
        out[cur_len] = out[cur_len - 1];
        cur_len = cur_len - 1;
      end;
      out[pos] = driver;
    end;
  end;
  do return out end;
end
drv.getDriverByProvides = function(p) 
  local gd = drv.getDriversByProvides(p);
  if (gd.length > 0) then 
    do return gd[0] end;
  end;
  do return nil end;
end
drv.getDriverByName = function(name) 
  local _g = 0;
  local _g1 = drv.get_drivers();
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local driver = _g1[_g];
    _g = _g + 1;
    if (driver.deviceName == name) then 
      do return driver end;
    end;
  end;
  do return nil end;
end
drv.add = function(d) 
  local tmp = Std.string(Std.string("Device connected: ") .. Std.string(d.deviceName)) .. Std.string(" of type ");
  local c = Type.getClass(d);
  __kernel_Logger.log(Std.string(tmp) .. Std.string(c.__name__), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/kernel/Drivers.hx",lineNumber=57,className="kernel.Drivers",methodName="add"}));
  if (xg.api ~= nil) then 
    xg.api:queue(_hx_tab_array({[0]="device_connect", d.deviceName}, 2));
  end;
  local _this = drv.sdrivers;
  local pos = drv.get_drivers().length;
  if (pos > _this.length) then 
    pos = _this.length;
  end;
  if (pos < 0) then 
    pos = _this.length + pos;
    if (pos < 0) then 
      pos = 0;
    end;
  end;
  local cur_len = _this.length;
  while (cur_len > pos) do _hx_do_first_1 = false;
    
    _this[cur_len] = _this[cur_len - 1];
    cur_len = cur_len - 1;
  end;
  _this[pos] = d;
end
drv.rem = function(name) 
  __kernel_Logger.log(Std.string("Device disconnected: ") .. Std.string(name), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/kernel/Drivers.hx",lineNumber=63,className="kernel.Drivers",methodName="rem"}));
  if (xg.api ~= nil) then 
    xg.api:queue(_hx_tab_array({[0]="device_disconnect", name}, 2));
  end;
  local d = nil;
  local _g_current = 0;
  local _g_array = drv.sdrivers;
  while (_g_current < _g_array.length) do _hx_do_first_1 = false;
    
    local _g_value = _g_array[_g_current];
    _g_current = _g_current + 1;
    local _g_key = _g_current - 1;
    local index = _g_key;
    local value = _g_value;
    if (value.deviceName == name) then 
      d = value;
      break;
    end;
  end;
  if (d ~= nil) then 
    drv.sdrivers:remove(d);
    do return true end;
  else
    do return false end;
  end;
end
drv.set_drivers = function(value) 
  do return drv.sdrivers end;
end
drv.get_drivers = function() 
  do return drv.sdrivers end;
end

__kernel_Hook.new = function() 
  local self = _hx_new(__kernel_Hook.prototype)
  __kernel_Hook.super(self)
  return self
end
__kernel_Hook.super = function(self) 
end
__kernel_Hook.__name__ = "kernel.Hook"
__kernel_Hook.prototype = _hx_e();

__kernel_Hook.prototype.__class__ =  __kernel_Hook

__kernel__Kernel_KFSMount.new = function(fp,s) 
  local self = _hx_new(__kernel__Kernel_KFSMount.prototype)
  __kernel__Kernel_KFSMount.super(self,fp,s)
  return self
end
__kernel__Kernel_KFSMount.super = function(self,fp,s) 
  self.filePath = fp;
  self.fsd = s;
end
__kernel__Kernel_KFSMount.__name__ = "kernel._Kernel.KFSMount"
__kernel__Kernel_KFSMount.prototype = _hx_e();

__kernel__Kernel_KFSMount.prototype.__class__ =  __kernel__Kernel_KFSMount

__kernel__Kernel_MountNotFoundException.new = function(message,previous,native) 
  local self = _hx_new(__kernel__Kernel_MountNotFoundException.prototype)
  __kernel__Kernel_MountNotFoundException.super(self,message,previous,native)
  return self
end
__kernel__Kernel_MountNotFoundException.super = function(self,message,previous,native) 
  __haxe_Exception.super(self,message,previous,native);
end
__kernel__Kernel_MountNotFoundException.__name__ = "kernel._Kernel.MountNotFoundException"
__kernel__Kernel_MountNotFoundException.prototype = _hx_e();

__kernel__Kernel_MountNotFoundException.prototype.__class__ =  __kernel__Kernel_MountNotFoundException
__kernel__Kernel_MountNotFoundException.__super__ = __haxe_Exception
setmetatable(__kernel__Kernel_MountNotFoundException.prototype,{__index=__haxe_Exception.prototype})

__kernel__Kernel_KFSDriver.new = function(upfs) 
  local self = _hx_new(__kernel__Kernel_KFSDriver.prototype)
  __kernel__Kernel_KFSDriver.super(self,upfs)
  return self
end
__kernel__Kernel_KFSDriver.super = function(self,upfs) 
  self.mounts = _hx_tab_array({}, 0);
  __kernel_FileSystemDriver.super(self);
  self.mounts:push(__kernel__Kernel_KFSMount.new(__globals_FilePath.new(""), upfs));
end
__kernel__Kernel_KFSDriver.__name__ = "kernel._Kernel.KFSDriver"
__kernel__Kernel_KFSDriver.prototype = _hx_e();
__kernel__Kernel_KFSDriver.prototype.getFS = function(self,path) 
  self.mounts:sort(function(a,b) 
    do return a.filePath.path.length - b.filePath.path.length end;
  end);
  self.mounts:reverse();
  local _g = 0;
  local _g1 = self.mounts;
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local mount = _g1[_g];
    _g = _g + 1;
    if (path.path:slice(0, mount.filePath.path.length - 1) == mount.filePath.path) then 
      do return mount.fsd end;
    end;
  end;
  local _g = 0;
  local _g1 = self.mounts;
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local mount = _g1[_g];
    _g = _g + 1;
    if (mount.filePath.path.length == 0) then 
      do return mount.fsd end;
    end;
  end;
  _G.error(__kernel__Kernel_MountNotFoundException.new("No mount at that path. This shouldn't happen if a filesystem is mounted at '/'."),0);
end
__kernel__Kernel_KFSDriver.prototype.getFSS = function(self,path) 
  do return self:getFS(__globals_FilePath.new(path)) end
end
__kernel__Kernel_KFSDriver.prototype.init = function(self) 
end
__kernel__Kernel_KFSDriver.prototype.deinit = function(self) 
end
__kernel__Kernel_KFSDriver.prototype.bg = function(self,ev) 
end
__kernel__Kernel_KFSDriver.prototype.read = function(self,path) 
  local fp = __globals_FilePath.new(path);
  do return self:getFS(fp):read(path) end
end
__kernel__Kernel_KFSDriver.prototype.readBytes = function(self,path,bytes,fromPos) 
  if (fromPos == nil) then 
    fromPos = 0;
  end;
  do return self:getFS(__globals_FilePath.new(path)):readBytes(path, bytes, fromPos) end
end
__kernel__Kernel_KFSDriver.prototype.write = function(self,path,text) 
  local fp = __globals_FilePath.new(path);
  self:getFS(fp):write(path, text);
end
__kernel__Kernel_KFSDriver.prototype.writeByte = function(self,path,byte) 
  self:getFSS(path):writeByte(path, byte);
end
__kernel__Kernel_KFSDriver.prototype.append = function(self,path,text) 
  local fp = __globals_FilePath.new(path);
  self:getFS(fp):append(path, text);
end
__kernel__Kernel_KFSDriver.prototype.exists = function(self,path) 
  local fp = __globals_FilePath.new(path);
  do return self:getFS(fp):exists(path) end
end
__kernel__Kernel_KFSDriver.prototype.isReadOnly = function(self,path,user) 
  if (user == nil) then 
    user = "";
  end;
  local fp = __globals_FilePath.new(path);
  do return self:getFS(fp):isReadOnly(path, user) end
end
__kernel__Kernel_KFSDriver.prototype.list = function(self,dir) 
  local fp = __globals_FilePath.new(dir);
  local out = self:getFS(fp):list(dir);
  local _g = 0;
  local _g1 = self.mounts;
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local mount = _g1[_g];
    _g = _g + 1;
    if (mount.filePath.path:slice(0, mount.filePath.path.length - 2) == fp.path) then 
      out:push(mount.filePath.path[mount.filePath.path.length - 1]);
    end;
  end;
  do return out end
end
__kernel__Kernel_KFSDriver.prototype.type = function(self,path) 
  local fp = __globals_FilePath.new(path);
  do return self:getFS(fp):type(path) end
end
__kernel__Kernel_KFSDriver.prototype.dataread = function(self) 
  do return "" end
end
__kernel__Kernel_KFSDriver.prototype.datawrite = function(self,s) 
end

__kernel__Kernel_KFSDriver.prototype.__class__ =  __kernel__Kernel_KFSDriver
__kernel__Kernel_KFSDriver.__super__ = __kernel_FileSystemDriver
setmetatable(__kernel__Kernel_KFSDriver.prototype,{__index=__kernel_FileSystemDriver.prototype})

XGos.new = {}
XGos.__name__ = "XGos"
XGos.run = function(env,path,...) 
  local args = {...}
  local XPath = path;
  local MadeEnvironment = ({});
  
            for i,v in pairs(_G) do
                MadeEnvironment[i] = v
            end
            MadeEnvironment["package"] = {loaded=setmetatable({}, {__index = function(s, f) return true end})};
            
        ;
  local obj = __haxe_ds_ObjectMap.new();
  __lua_PairTools.pairsFold(MadeEnvironment, function(k,v,m) 
    obj.h[k] = v;
    obj.k[k] = true;
    do return obj end;
  end, obj);
  local m = obj;
  local v = nil;
  local value = v;
  if (value == nil) then 
    m.h.fs = __haxe_ds_StringMap.tnull;
  else
    m.h.fs = value;
  end;
  local v = xg;
  local value = v;
  if (value == nil) then 
    m.h.xg = __haxe_ds_StringMap.tnull;
  else
    m.h.xg = value;
  end;
  local v = drv;
  local value = v;
  if (value == nil) then 
    m.h.drv = __haxe_ds_StringMap.tnull;
  else
    m.h.drv = value;
  end;
  local v = __kernel_Kernel;
  local value = v;
  if (value == nil) then 
    m.h.k = __haxe_ds_StringMap.tnull;
  else
    m.h.k = value;
  end;
  local v = __kernel_Logger;
  local value = v;
  if (value == nil) then 
    m.h.log = __haxe_ds_StringMap.tnull;
  else
    m.h.log = value;
  end;
  local v = XGos;
  local value = v;
  if (value == nil) then 
    m.h.os = __haxe_ds_StringMap.tnull;
  else
    m.h.os = value;
  end;
  local v = _G.setmetatable;
  local value = v;
  if (value == nil) then 
    m.h.setmetatable = __haxe_ds_StringMap.tnull;
  else
    m.h.setmetatable = value;
  end;
  local ajtr = nil;
  
		if environ then ajtr = environ else ajtr = {} end
		;
  local xeenv = env;
  local obj = __haxe_ds_ObjectMap.new();
  __lua_PairTools.pairsFold(ajtr, function(k,v,m) 
    obj.h[k] = v;
    obj.k[k] = true;
    do return obj end;
  end, obj);
  local map = obj;
  local _g_map = map;
  local _g_keys = map:keys();
  while (_g_keys:hasNext()) do _hx_do_first_1 = false;
    
    local key = _g_keys:next();
    local _g_value = _g_map:get(key);
    local _g_key = key;
    local k = _g_key;
    local v = _g_value;
    if (v == nil) then 
      xeenv.h[k] = __haxe_ds_StringMap.tnull;
    else
      xeenv.h[k] = v;
    end;
  end;
  local ret = ({});
  local k = xeenv:keys();
  while (k:hasNext()) do _hx_do_first_1 = false;
    
    local k = k:next();
    local ret1 = xeenv.h[k];
    ret[k] = (function() 
      local _hx_1
      if (ret1 == __haxe_ds_StringMap.tnull) then 
      _hx_1 = nil; else 
      _hx_1 = ret1; end
      return _hx_1
    end )();
  end;
  local v = ret;
  local value = v;
  if (value == nil) then 
    m.h.environ = __haxe_ds_StringMap.tnull;
  else
    m.h.environ = value;
  end;
  local v = function(p1) 
    local toprint = _hx_tab_array({}, 0);
    local vtoprint = _hx_tab_array({}, 0);
    local lout = 0;
    local it = p1;
    toprint = toprint:concat(String.prototype.split(Std.string(it), " "));
    local vb = "";
    local _g = 0;
    while (_g < toprint.length) do _hx_do_first_1 = false;
      
      local s = toprint[_g];
      _g = _g + 1;
      local _g = 0;
      local _g1 = #s;
      while (_g < _g1) do _hx_do_first_2 = false;
        
        _g = _g + 1;
        local i = _g - 1;
        local char = _G.string.sub(s, i + 1, i + 1);
        if (char == "\n") then 
          local pos = vtoprint.length;
          if (pos > vtoprint.length) then 
            pos = vtoprint.length;
          end;
          if (pos < 0) then 
            pos = vtoprint.length + pos;
            if (pos < 0) then 
              pos = 0;
            end;
          end;
          local cur_len = vtoprint.length;
          while (cur_len > pos) do _hx_do_first_3 = false;
            
            vtoprint[cur_len] = vtoprint[cur_len - 1];
            cur_len = cur_len - 1;
          end;
          vtoprint[pos] = vb;
          vb = "";
        else
          vb = Std.string(vb) .. Std.string(char);
        end;
      end;
      vb = Std.string(vb) .. Std.string(" ");
    end;
    vb = String.prototype.substr(vb, 0, #vb - 2);
    local _g = 0;
    while (_g < vtoprint.length) do _hx_do_first_1 = false;
      
      local s = vtoprint[_g];
      _g = _g + 1;
      local _g = 0;
      local _g1 = String.prototype.split(s, " ");
      while (_g < _g1.length) do _hx_do_first_2 = false;
        
        local sv = _g1[_g];
        _g = _g + 1;
        if (#s > (xg.out:get_size().x - xg.out:getCursorPos().x)) then 
          xg.out:print("\n");
          lout = lout + 1;
        end;
        xg.out:print(s);
      end;
      xg.out:print("\n");
      lout = lout + 1;
    end;
    do return lout end;
  end;
  local value = v;
  if (value == nil) then 
    m.h.print = __haxe_ds_StringMap.tnull;
  else
    m.h.print = value;
  end;
  local EnvTable = ({});
  local map = m;
  local _g_map = map;
  local _g_keys = map:keys();
  while (_g_keys:hasNext()) do _hx_do_first_1 = false;
    
    local key = _g_keys:next();
    local _g = _hx_o({__fields__={value=true,key=true},value=_g_map:get(key),key=key});
    local key = _g.key;
    local value = _g.value;
    
            EnvTable[key] = value
            ;
  end;
  local Readed = xg.fs:read(path);
  local Loaded = nil;
  local error = "";
  
            EnvTable["_G"] = EnvTable
            Loaded, error = load(Readed, XPath, nil, EnvTable)
        ;
  if (Loaded == nil) then 
    xg.out:write(error);
    xg.out:write("\n");
  else
    local _hx_status, _hx_result = pcall(function() 
    
        Loaded(_hx_table.unpack(args));
      return _hx_pcall_default
    end)
    if not _hx_status and _hx_result == "_hx_pcall_break" then
    elseif not _hx_status then 
      local _g = _hx_result;
      local _g1 = __haxe_Exception.caught(_g):unwrap();
      if (__lua_Boot.__instanceof(_g1, String)) then 
        local e = _g1;
        xg.out:write(e);
        xg.out:write("\n");
      else
        _G.error(_g,0);
      end;
    elseif _hx_result ~= _hx_pcall_default then
      return _hx_result
    end;
  end;
end

__kernel_Kernel.new = {}
__kernel_Kernel.__name__ = "kernel.Kernel"
__kernel_Kernel.panic = function(reason,posinfo) 
  local kp = "";
  kp = Std.string(kp) .. Std.string("--- BEGIN XENOS KERNEL PANIC ---\n");
  kp = Std.string(kp) .. Std.string((Std.string(Std.string("Reason: ") .. Std.string(reason)) .. Std.string("\n")));
  if (posinfo ~= nil) then 
    kp = Std.string(kp) .. Std.string((Std.string(Std.string(Std.string(Std.string("Position: ") .. Std.string(posinfo.fileName)) .. Std.string(":")) .. Std.string(posinfo.lineNumber)) .. Std.string("\n")));
  else
    kp = Std.string(kp) .. Std.string("No position information, probably from lua file.\n");
  end;
  if (drv.getDriverByProvides(__kernel_DriverProvides.Http) == nil) then 
    kp = Std.string(kp) .. Std.string("No HTTP - Data not uploaded.\n");
  else
    kp = Std.string(kp) .. Std.string("This version doesn't have telemetry.");
  end;
  if (xg.api ~= nil) then 
    kp = Std.string(kp) .. Std.string("---     TASK INFORMATION     ---\n");
    kp = Std.string(kp) .. Std.string((Std.string(Std.string("Running task count: ") .. Std.string(xg.api:getTasks().length)) .. Std.string("\n")));
    kp = Std.string(kp) .. Std.string((Std.string(Std.string("Current task name : ") .. Std.string(xg.api:get_current().name)) .. Std.string("\n")));
  end;
  kp = Std.string(kp) .. Std.string("---  END XENOS KERNEL PANIC  ---");
  local _hx_status, _hx_result = pcall(function() 
  
      if (xg.out ~= nil) then 
        xg.out:print(kp);
      else
        _G.io.write(Std.string(kp));
        _G.io.flush();
      end;
    return _hx_pcall_default
  end)
  if not _hx_status and _hx_result == "_hx_pcall_break" then
  elseif not _hx_status then 
    local _g = _hx_result;
    _G.io.write(Std.string(kp));
    _G.io.flush();
  elseif _hx_result ~= _hx_pcall_default then
    return _hx_result
  end;
  if (__kernel_Kernel.threadRunner ~= nil) then 
    __kernel_Kernel.threadRunner.tasks = _hx_tab_array({}, 0);
  end;
  while (true) do _hx_do_first_1 = false;
    
    _G.coroutine.yield();
  end;
end
__kernel_Kernel.main = function() 
  if (__kernel_Kernel.threadRunner ~= nil) then 
    __kernel_Kernel.panic("Kernel ran in invalid state.", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/kernel/Kernel.hx",lineNumber=259,className="kernel.Kernel",methodName="main"}));
  end;
  
		if k then
			k.panic("Kernel ran in invalid state")
		end
		;
  local hooks = _hx_tab_array({[0]=__kernel_hooks_CCTermHook.new(), __kernel_hooks_CCFSDriverHook.new(), __kernel_hooks_CCMonitorDriverHook.new()}, 3);
  local _g = 0;
  while (_g < hooks.length) do _hx_do_first_1 = false;
    
    local hook = hooks[_g];
    _g = _g + 1;
    local c = Type.getClass(hook);
    __kernel_Logger.log(Std.string("Starting hook: ") .. Std.string(c.__name__), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/kernel/Kernel.hx",lineNumber=272,className="kernel.Kernel",methodName="main"}));
    hook:init();
    local c = Type.getClass(hook);
    __kernel_Logger.log(Std.string("Finished hook: ") .. Std.string(c.__name__), _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/kernel/Kernel.hx",lineNumber=274,className="kernel.Kernel",methodName="main"}));
  end;
  local t = __lua_Boot.__cast(drv.getDriverByProvides(__kernel_DriverProvides.Terminal) , __kernel_TerminalDriver);
  local mouse = __lua_Boot.__cast(drv.getDriverByProvides(__kernel_DriverProvides.Mouse) , __kernel_MouseDriver);
  local kb = __lua_Boot.__cast(drv.getDriverByProvides(__kernel_DriverProvides.Keyboard) , __kernel_KeyboardDriver);
  local fs = __lua_Boot.__cast(drv.getDriverByName("hdd") , __kernel_FileSystemDriver);
  if (t == nil) then 
    __kernel_Kernel.panic("No terminal found", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/kernel/Kernel.hx",lineNumber=281,className="kernel.Kernel",methodName="main"}));
  end;
  if (kb == nil) then 
    __kernel_Kernel.panic("No keyboard found", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/kernel/Kernel.hx",lineNumber=283,className="kernel.Kernel",methodName="main"}));
  end;
  if (fs == nil) then 
    __kernel_Kernel.panic("No filesystem found", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/kernel/Kernel.hx",lineNumber=285,className="kernel.Kernel",methodName="main"}));
  end;
  __kernel_Kernel.threadRunner = __kernel_KThreadRunner.new(hooks);
  t:clear();
  t:setCursorPos(1, 1);
  local kfs = __kernel__Kernel_KFSDriver.new(fs);
  local kapi = __kernel_KThreadAPI.new(__kernel_Kernel.threadRunner);
  xg.fs = kfs;
  xg.api = kapi;
  xg.inp = kb;
  xg.out = t:asOutput();
  __kernel_Logger.log("Stage 2...", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/kernel/Kernel.hx",lineNumber=295,className="kernel.Kernel",methodName="main"}));
  local tmp = __haxe_ds_StringMap.new();
  local length = nil;
  local tab = __lua_PairTools.copy(argpstuff.args);
  local length = length;
  local tmp1;
  if (length == nil) then 
    length = _hx_table.maxn(tab);
    if (length > 0) then 
      local head = tab[1];
      _G.table.remove(tab, 1);
      tab[0] = head;
      tmp1 = _hx_tab_array(tab, length);
    else
      tmp1 = _hx_tab_array({}, 0);
    end;
  else
    tmp1 = _hx_tab_array(tab, length);
  end;
  XGos.run(tmp, "/system/s2.lua", _hx_table.unpack(__haxe__Rest_Rest_Impl_.of(tmp1)));
  __kernel_Logger.log("Starting task scheduler.", _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/kernel/Kernel.hx",lineNumber=297,className="kernel.Kernel",methodName="main"}));
  __kernel_Kernel.threadRunner:run();
end

__kernel_Logger.new = {}
__kernel_Logger.__name__ = "kernel.Logger"
__kernel_Logger.log = function(text,pos) 
  local d = drv.getDriverByProvides(__kernel_DriverProvides.Clock);
  local lString = "";
  if (d == nil) then 
    lString = Std.string(Std.string(Std.string(Std.string(Std.string("[") .. Std.string(pos.fileName)) .. Std.string(":")) .. Std.string(pos.lineNumber)) .. Std.string("] ")) .. Std.string(text);
  else
    lString = Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("[") .. Std.string(d:getEpoch(__kernel_Since.ComputerStart))) .. Std.string("] [")) .. Std.string(pos.fileName)) .. Std.string(":")) .. Std.string(pos.lineNumber)) .. Std.string("] ")) .. Std.string(text);
  end;
  local tmp = __kernel_Logger;
  tmp.logBuf = Std.string(tmp.logBuf) .. Std.string((Std.string(lString) .. Std.string("\n")));
  _G.print(Std.string(lString));
end

__kernel_KThread.new = function(name,callback,cId,pEnv,user) 
  local self = _hx_new(__kernel_KThread.prototype)
  __kernel_KThread.super(self,name,callback,cId,pEnv,user)
  return self
end
__kernel_KThread.super = function(self,name,callback,cId,pEnv,user) 
  self.pDI = nil;
  self.pInfo = __kernel_KThreadInfo.new("", 0, __haxe_ds_StringMap.new(), "KTrunner");
  self.pInfo = __kernel_KThreadInfo.new(name, cId, pEnv, user);
  self.pCoroutine = _G.coroutine.create(callback);
  
        self.pDI = debug.getinfo(callback)
        ;
end
__kernel_KThread.__name__ = "kernel.KThread"
__kernel_KThread.prototype = _hx_e();

__kernel_KThread.prototype.__class__ =  __kernel_KThread

__kernel_KThreadInfo.new = function(name,creatorID,env,user) 
  local self = _hx_new(__kernel_KThreadInfo.prototype)
  __kernel_KThreadInfo.super(self,name,creatorID,env,user)
  return self
end
__kernel_KThreadInfo.super = function(self,name,creatorID,env,user) 
  self.env = __haxe_ds_StringMap.new();
  self.user = "";
  self.ID = 0;
  self.creatorID = 0;
  self.name = "(empty)";
  self.name = name;
  self.creatorID = creatorID;
  self.env = env;
end
__kernel_KThreadInfo.__name__ = "kernel.KThreadInfo"
__kernel_KThreadInfo.prototype = _hx_e();
__kernel_KThreadInfo.prototype.copy = function(self) 
  local kti = __kernel_KThreadInfo.new(Std.string(self.name) .. Std.string(""), self.creatorID, self.env, Std.string(self.user) .. Std.string(""));
  kti.ID = self.ID;
  do return kti end
end

__kernel_KThreadInfo.prototype.__class__ =  __kernel_KThreadInfo

__kernel_KThreadRunner.new = function(hooks) 
  local self = _hx_new(__kernel_KThreadRunner.prototype)
  __kernel_KThreadRunner.super(self,hooks)
  return self
end
__kernel_KThreadRunner.super = function(self,hooks) 
  self.ongoingQueueEvents = _hx_tab_array({}, 0);
  self.current = __kernel_KThread.new("krnl.lua", function() 
  end, 0, __haxe_ds_StringMap.new(), "KrnlRunner");
  self.hooks = _hx_tab_array({}, 0);
  self.tasks = _hx_tab_array({}, 0);
  self.hooks = hooks;
end
__kernel_KThreadRunner.__name__ = "kernel.KThreadRunner"
__kernel_KThreadRunner.prototype = _hx_e();
__kernel_KThreadRunner.prototype.run = function(self) 
  local _gthis = self;
  debug.sethook(function() 
    local i = 0;
    local b = debug.getinfo(1);
    while (b ~= nil) do _hx_do_first_1 = false;
      
      i = i + 1;
      b = debug.getinfo(i);
      if (b ~= nil) then 
        local _g = _hx_tab_array({}, 0);
        local _g1 = 0;
        local _g2 = _gthis.tasks;
        while (_g1 < _g2.length) do _hx_do_first_2 = false;
          
          local i = _g2[_g1];
          _g1 = _g1 + 1;
          if (i.pDI.name == b.name) then 
            _g:push(i);
          end;
        end;
        if (_g.length == 1) then 
          local _g = _hx_tab_array({}, 0);
          local _g1 = 0;
          local _g2 = _gthis.tasks;
          while (_g1 < _g2.length) do _hx_do_first_2 = false;
            
            local i = _g2[_g1];
            _g1 = _g1 + 1;
            if (i.pDI.name == b.name) then 
              _g:push(i);
            end;
          end;
          local x = _g[0];
        end;
      end;
    end;
  end, "l");
  local _g = 0;
  local _g1 = self.tasks;
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local thread = _g1[_g];
    _g = _g + 1;
    self.current = thread;
    _G.coroutine.resume(self.current.pCoroutine, "startup");
  end;
  local _g = 0;
  local _g1 = drv.get_drivers();
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local driver = _g1[_g];
    _g = _g + 1;
    driver:bg(_hx_tab_array({[0]="startup"}, 1));
  end;
  local _g = 0;
  local _g1 = self.hooks;
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local hook = _g1[_g];
    _g = _g + 1;
    hook:bg(_hx_tab_array({[0]="startup"}, 1));
  end;
  while (true) do _hx_do_first_1 = false;
    
    local amogus = self.ongoingQueueEvents:pop();
    if (amogus ~= nil) then 
      local _g = 0;
      local _g1 = self.tasks;
      while (_g < _g1.length) do _hx_do_first_2 = false;
        
        local thread = _g1[_g];
        _g = _g + 1;
        self.current = thread;
        local tmp = self.current.pCoroutine;
        local ret = ({});
        local _g = 0;
        local _g1 = amogus.length;
        while (_g < _g1) do _hx_do_first_3 = false;
          
          _g = _g + 1;
          local idx = _g - 1;
          ret[idx + 1] = amogus[idx];
        end;
        _G.coroutine.resume(tmp, _hx_table.unpack(ret));
      end;
      local _g = 0;
      local _g1 = drv.get_drivers();
      while (_g < _g1.length) do _hx_do_first_2 = false;
        
        local driver = _g1[_g];
        _g = _g + 1;
        driver:bg(amogus);
      end;
      local _g = 0;
      local _g1 = self.hooks;
      while (_g < _g1.length) do _hx_do_first_2 = false;
        
        local hook = _g1[_g];
        _g = _g + 1;
        hook:bg(amogus);
      end;
    end;
    local length = nil;
    local tab = __lua_PairTools.copy(_hx_table.pack(_G.coroutine.yield()));
    local length = length;
    if (length == nil) then 
      length = _hx_table.maxn(tab);
      if (length > 0) then 
        local head = tab[1];
        _G.table.remove(tab, 1);
        tab[0] = head;
        amogus = _hx_tab_array(tab, length);
      else
        amogus = _hx_tab_array({}, 0);
      end;
    else
      amogus = _hx_tab_array(tab, length);
    end;
    local _g = 0;
    local _g1 = self.tasks;
    while (_g < _g1.length) do _hx_do_first_2 = false;
      
      local thread = _g1[_g];
      _g = _g + 1;
      self.current = thread;
      local tmp = self.current.pCoroutine;
      local ret = ({});
      local _g = 0;
      local _g1 = amogus.length;
      while (_g < _g1) do _hx_do_first_3 = false;
        
        _g = _g + 1;
        local idx = _g - 1;
        ret[idx + 1] = amogus[idx];
      end;
      _G.coroutine.resume(tmp, _hx_table.unpack(ret));
    end;
    local _g = 0;
    local _g1 = drv.get_drivers();
    while (_g < _g1.length) do _hx_do_first_2 = false;
      
      local driver = _g1[_g];
      _g = _g + 1;
      driver:bg(amogus);
    end;
    local _g = 0;
    local _g1 = self.hooks;
    while (_g < _g1.length) do _hx_do_first_2 = false;
      
      local hook = _g1[_g];
      _g = _g + 1;
      hook:bg(amogus);
    end;
  end;
end
__kernel_KThreadRunner.prototype.addThread = function(self,th) 
  local cp = th;
  local _g = 0;
  local _g1 = self.tasks;
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local thread = _g1[_g];
    _g = _g + 1;
    if ((cp.pDI.name == thread.pDI.name) or (cp.pInfo.name == thread.pInfo.name)) then 
      _G.error(__haxe_exceptions_ArgumentException.new("th", "Task name or pDI name shouldn't be the same. Maybe check your task naming and make sure to provide an inline function to createtask.", nil, _hx_o({__fields__={fileName=true,lineNumber=true,className=true,methodName=true},fileName="src/kernel/Thread.hx",lineNumber=113,className="kernel.KThreadRunner",methodName="addThread"})),0);
    end;
  end;
  cp.pInfo.ID = self.tasks.length;
  local _this = self.tasks;
  local pos = self.tasks.length;
  if (pos > _this.length) then 
    pos = _this.length;
  end;
  if (pos < 0) then 
    pos = _this.length + pos;
    if (pos < 0) then 
      pos = 0;
    end;
  end;
  local cur_len = _this.length;
  while (cur_len > pos) do _hx_do_first_1 = false;
    
    _this[cur_len] = _this[cur_len - 1];
    cur_len = cur_len - 1;
  end;
  _this[pos] = cp;
end

__kernel_KThreadRunner.prototype.__class__ =  __kernel_KThreadRunner

__kernel_KThreadAPI.new = function(te) 
  local self = _hx_new(__kernel_KThreadAPI.prototype)
  __kernel_KThreadAPI.super(self,te)
  return self
end
__kernel_KThreadAPI.super = function(self,te) 
  self.te = te;
end
__kernel_KThreadAPI.__name__ = "kernel.KThreadAPI"
__kernel_KThreadAPI.prototype = _hx_e();
__kernel_KThreadAPI.prototype.get_current = function(self) 
  do return self.te.current.pInfo:copy() end
end
__kernel_KThreadAPI.prototype.set_current = function(self,v) 
  do return self.te.current.pInfo:copy() end
end
__kernel_KThreadAPI.prototype.create = function(self,name,callback) 
  self.te:addThread(__kernel_KThread.new(name, callback, self:get_current().ID, self:get_current().env, self:get_current().user));
end
__kernel_KThreadAPI.prototype.queue = function(self,event) 
  local _this = self.te.ongoingQueueEvents;
  local pos = self.te.ongoingQueueEvents.length;
  if (pos > _this.length) then 
    pos = _this.length;
  end;
  if (pos < 0) then 
    pos = _this.length + pos;
    if (pos < 0) then 
      pos = 0;
    end;
  end;
  local cur_len = _this.length;
  while (cur_len > pos) do _hx_do_first_1 = false;
    
    _this[cur_len] = _this[cur_len - 1];
    cur_len = cur_len - 1;
  end;
  _this[pos] = event;
end
__kernel_KThreadAPI.prototype.getTasks = function(self) 
  local f = _hx_tab_array({}, 0);
  local _g = 0;
  local _g1 = self.te.tasks;
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local thread = _g1[_g];
    _g = _g + 1;
    local pos = f.length;
    local x = thread.pInfo:copy();
    if (pos > f.length) then 
      pos = f.length;
    end;
    if (pos < 0) then 
      pos = f.length + pos;
      if (pos < 0) then 
        pos = 0;
      end;
    end;
    local cur_len = f.length;
    while (cur_len > pos) do _hx_do_first_2 = false;
      
      f[cur_len] = f[cur_len - 1];
      cur_len = cur_len - 1;
    end;
    f[pos] = x;
  end;
  do return f end
end

__kernel_KThreadAPI.prototype.__class__ =  __kernel_KThreadAPI

xg.new = {}
xg.__name__ = "xg"

__kernel_hooks_CCFileSystemDriver.new = function(path) 
  local self = _hx_new(__kernel_hooks_CCFileSystemDriver.prototype)
  __kernel_hooks_CCFileSystemDriver.super(self,path)
  return self
end
__kernel_hooks_CCFileSystemDriver.super = function(self,path) 
  if (path == nil) then 
    path = "/";
  end;
  self.rootpath = "/";
  __kernel_FileSystemDriver.super(self);
  self.rootpath = path;
  if (fs.isDriveRoot(self.rootpath)) then 
    self.deviceName = fs.getDrive(self.rootpath);
  else
    self.deviceName = StringTools.replace(self.rootpath, "/", ".");
  end;
end
__kernel_hooks_CCFileSystemDriver.__name__ = "kernel.hooks.CCFileSystemDriver"
__kernel_hooks_CCFileSystemDriver.prototype = _hx_e();
__kernel_hooks_CCFileSystemDriver.prototype.init = function(self) 
end
__kernel_hooks_CCFileSystemDriver.prototype.deinit = function(self) 
end
__kernel_hooks_CCFileSystemDriver.prototype.bg = function(self,ev) 
end
__kernel_hooks_CCFileSystemDriver.prototype.read = function(self,path) 
  local _hx_1_n_out, _hx_1_n_error = fs.open(path, "r");
  if (_hx_1_n_out == nil) then 
    _G.error(__haxe_Exception.new(_hx_1_n_error),0);
  end;
  local rv = _hx_1_n_out:readAll();
  _hx_1_n_out:close();
  do return rv end
end
__kernel_hooks_CCFileSystemDriver.prototype.readBytes = function(self,path,bytes,fromPos) 
  if (fromPos == nil) then 
    fromPos = 0;
  end;
  local _hx_1_n_out, _hx_1_n_error = fs.open(path, "rb");
  if (_hx_1_n_out == nil) then 
    _G.error(__haxe_Exception.new(_hx_1_n_error),0);
  end;
  _hx_1_n_out:seek(fromPos);
  local rv = _hx_1_n_out:read(bytes);
  _hx_1_n_out:close();
  do return rv end
end
__kernel_hooks_CCFileSystemDriver.prototype.write = function(self,path,text) 
  local _hx_1_n_out, _hx_1_n_error = fs.open(path, "w");
  if (_hx_1_n_out == nil) then 
    _G.error(__haxe_Exception.new(_hx_1_n_error),0);
  end;
  _hx_1_n_out:write(text);
  _hx_1_n_out:close();
end
__kernel_hooks_CCFileSystemDriver.prototype.writeByte = function(self,path,byte) 
  local _hx_1_n_out, _hx_1_n_error = fs.open(path, "wb");
  if (_hx_1_n_out == nil) then 
    _G.error(__haxe_Exception.new(_hx_1_n_error),0);
  end;
  _hx_1_n_out:write(byte);
  _hx_1_n_out:close();
end
__kernel_hooks_CCFileSystemDriver.prototype.append = function(self,path,text) 
  local old = self:read(path);
  self:write(path, Std.string(old) .. Std.string(text));
end
__kernel_hooks_CCFileSystemDriver.prototype.exists = function(self,path) 
  do return fs.exists(path) end
end
__kernel_hooks_CCFileSystemDriver.prototype.isReadOnly = function(self,path,user) 
  do return fs.isReadOnly(path) end
end
__kernel_hooks_CCFileSystemDriver.prototype.list = function(self,dir) 
  local n = fs.list(dir);
  local length = nil;
  local tab = __lua_PairTools.copy(n);
  local length = length;
  if (length == nil) then 
    length = _hx_table.maxn(tab);
    if (length > 0) then 
      local head = tab[1];
      _G.table.remove(tab, 1);
      tab[0] = head;
      do return _hx_tab_array(tab, length) end;
    else
      do return _hx_tab_array({}, 0) end;
    end;
  else
    do return _hx_tab_array(tab, length) end;
  end;
end
__kernel_hooks_CCFileSystemDriver.prototype.type = function(self,path) 
  if (fs.isDir(path)) then 
    do return __kernel_FileType.Directory end;
  else
    do return __kernel_FileType.File end;
  end;
end
__kernel_hooks_CCFileSystemDriver.prototype.dataread = function(self) 
  do return "" end
end
__kernel_hooks_CCFileSystemDriver.prototype.datawrite = function(self,s) 
end

__kernel_hooks_CCFileSystemDriver.prototype.__class__ =  __kernel_hooks_CCFileSystemDriver
__kernel_hooks_CCFileSystemDriver.__super__ = __kernel_FileSystemDriver
setmetatable(__kernel_hooks_CCFileSystemDriver.prototype,{__index=__kernel_FileSystemDriver.prototype})

__kernel_hooks_CCFSDriverHook.new = function() 
  local self = _hx_new(__kernel_hooks_CCFSDriverHook.prototype)
  __kernel_hooks_CCFSDriverHook.super(self)
  return self
end
__kernel_hooks_CCFSDriverHook.super = function(self) 
  __kernel_Hook.super(self);
end
__kernel_hooks_CCFSDriverHook.__name__ = "kernel.hooks.CCFSDriverHook"
__kernel_hooks_CCFSDriverHook.prototype = _hx_e();
__kernel_hooks_CCFSDriverHook.prototype.init = function(self) 
  drv.add(__kernel_hooks_CCFileSystemDriver.new("/"));
end
__kernel_hooks_CCFSDriverHook.prototype.deinit = function(self) 
end
__kernel_hooks_CCFSDriverHook.prototype.bg = function(self,ev) 
end

__kernel_hooks_CCFSDriverHook.prototype.__class__ =  __kernel_hooks_CCFSDriverHook
__kernel_hooks_CCFSDriverHook.__super__ = __kernel_Hook
setmetatable(__kernel_hooks_CCFSDriverHook.prototype,{__index=__kernel_Hook.prototype})

__kernel_hooks_MonitorTerminalBackend.new = function(monName) 
  local self = _hx_new(__kernel_hooks_MonitorTerminalBackend.prototype)
  __kernel_hooks_MonitorTerminalBackend.super(self,monName)
  return self
end
__kernel_hooks_MonitorTerminalBackend.super = function(self,monName) 
  __globals_Output.super(self);
  self.peripheral = peripheral.wrap(monName);
  self:set_palette(self:get_palette());
end
__kernel_hooks_MonitorTerminalBackend.__name__ = "kernel.hooks.MonitorTerminalBackend"
__kernel_hooks_MonitorTerminalBackend.prototype = _hx_e();
__kernel_hooks_MonitorTerminalBackend.prototype.write = function(self,s) 
  local _g = 0;
  local _g1 = #s;
  while (_g < _g1) do _hx_do_first_1 = false;
    
    _g = _g + 1;
    local i = _g - 1;
    if (_G.string.sub(s, i + 1, i + 1) == "\n") then 
      local x, y = self.peripheral.getCursorPos() self.peripheral.setCursorPos(1, y);;
      self:setCursorPosRelative(0, 1);
    else
      self.peripheral.write(_G.string.sub(s, i + 1, i + 1));;
    end;
  end;
end
__kernel_hooks_MonitorTerminalBackend.prototype.clear = function(self) 
  self.peripheral.clear();
end
__kernel_hooks_MonitorTerminalBackend.prototype.setFGColor = function(self,col) 
  self.peripheral.setTextColor(col.bitASC);
end
__kernel_hooks_MonitorTerminalBackend.prototype.setBGColor = function(self,col) 
  self.peripheral.setBackgroundColor(col.bitASC);
end
__kernel_hooks_MonitorTerminalBackend.prototype.setCursorPos = function(self,x,y) 
  self.peripheral.setCursorPos(x, y);
end
__kernel_hooks_MonitorTerminalBackend.prototype.getCursorPos = function(self) 
  local shmegmaels = self.peripheral.getCursorPos();
  do return __globals_Vector2i.fromCPos(shmegmaels) end
end
__kernel_hooks_MonitorTerminalBackend.prototype.setCursorPosRelative = function(self,x,y) 
  local o = self:getCursorPos();
  local o1 = o;
  o1.x = o1.x + x;
  local o = o;
  o.y = o.y + y;
  
            self.peripheral.setCursorPos(o.x, o.y);
            if (o.y > self.peripheral.getSize().y) then 
                self.peripheral.scroll(((o.y - self.peripheral.getSize().y) - 2) * -1);
                self.peripheral.setCursorPos(o.x, self.peripheral.getSize().y);
            end;
        ;
end
__kernel_hooks_MonitorTerminalBackend.prototype.get_size = function(self) 
  local shmegmaels = self.peripheral.getSize();
  do return __globals_Vector2i.fromCPos(shmegmaels) end
end
__kernel_hooks_MonitorTerminalBackend.prototype.set_palette = function(self,newc) 
  local i = 0;
  local _g = 0;
  while (_g < newc.length) do _hx_do_first_1 = false;
    
    local color = newc[_g];
    _g = _g + 1;
    self.apalette[i - 1] = color;
    
                self.peripheral.setPaletteColor(Std.int(Math.max(_G.math.pow(2, i), 1)), color.red / 255.0, color.green / 255.0, color.blue / 255.0);
            ;
    i = i + 1;
  end;
  do return self.apalette end
end

__kernel_hooks_MonitorTerminalBackend.prototype.__class__ =  __kernel_hooks_MonitorTerminalBackend
__kernel_hooks_MonitorTerminalBackend.__super__ = __globals_Output
setmetatable(__kernel_hooks_MonitorTerminalBackend.prototype,{__index=__globals_Output.prototype})

__kernel_hooks_MonitorOutputDriver.new = function(monName) 
  local self = _hx_new(__kernel_hooks_MonitorOutputDriver.prototype)
  __kernel_hooks_MonitorOutputDriver.super(self,monName)
  return self
end
__kernel_hooks_MonitorOutputDriver.super = function(self,monName) 
  __kernel_TerminalDriver.super(self);
  self.output = __kernel_hooks_MonitorTerminalBackend.new(monName);
  self.deviceName = monName;
end
__kernel_hooks_MonitorOutputDriver.__name__ = "kernel.hooks.MonitorOutputDriver"
__kernel_hooks_MonitorOutputDriver.prototype = _hx_e();
__kernel_hooks_MonitorOutputDriver.prototype.write = function(self,s) 
  self.output:write(s);
end
__kernel_hooks_MonitorOutputDriver.prototype.clear = function(self) 
  self.output:clear();
end
__kernel_hooks_MonitorOutputDriver.prototype.setFGColor = function(self,col) 
  self.output:setFGColor(col);
end
__kernel_hooks_MonitorOutputDriver.prototype.setBGColor = function(self,col) 
  self.output:setBGColor(col);
end
__kernel_hooks_MonitorOutputDriver.prototype.set_palette = function(self,newc) 
  do return self.output:set_palette(newc) end
end
__kernel_hooks_MonitorOutputDriver.prototype.getCursorPos = function(self) 
  do return self.output:getCursorPos() end
end
__kernel_hooks_MonitorOutputDriver.prototype.setCursorPos = function(self,x,y) 
  self.output:setCursorPos(x, y);
end
__kernel_hooks_MonitorOutputDriver.prototype.setCursorPosRelative = function(self,x,y) 
  self.output:setCursorPosRelative(x, y);
end
__kernel_hooks_MonitorOutputDriver.prototype.get_size = function(self) 
  do return self.output:get_size() end
end
__kernel_hooks_MonitorOutputDriver.prototype.init = function(self) 
end
__kernel_hooks_MonitorOutputDriver.prototype.deinit = function(self) 
end
__kernel_hooks_MonitorOutputDriver.prototype.bg = function(self,ev) 
end
__kernel_hooks_MonitorOutputDriver.prototype.dataread = function(self) 
  do return "" end
end
__kernel_hooks_MonitorOutputDriver.prototype.datawrite = function(self,s) 
  self:write(s);
end

__kernel_hooks_MonitorOutputDriver.prototype.__class__ =  __kernel_hooks_MonitorOutputDriver
__kernel_hooks_MonitorOutputDriver.__super__ = __kernel_TerminalDriver
setmetatable(__kernel_hooks_MonitorOutputDriver.prototype,{__index=__kernel_TerminalDriver.prototype})

__kernel_hooks_CCMonitorDriverHook.new = function() 
  local self = _hx_new(__kernel_hooks_CCMonitorDriverHook.prototype)
  __kernel_hooks_CCMonitorDriverHook.super(self)
  return self
end
__kernel_hooks_CCMonitorDriverHook.super = function(self) 
  self.mons = _hx_tab_array({}, 0);
  __kernel_Hook.super(self);
end
__kernel_hooks_CCMonitorDriverHook.__name__ = "kernel.hooks.CCMonitorDriverHook"
__kernel_hooks_CCMonitorDriverHook.prototype = _hx_e();
__kernel_hooks_CCMonitorDriverHook.prototype.init = function(self) 
  local _g = 0;
  local length = nil;
  local tab = __lua_PairTools.copy(peripheral.getNames());
  local length = length;
  local _g1;
  if (length == nil) then 
    length = _hx_table.maxn(tab);
    if (length > 0) then 
      local head = tab[1];
      _G.table.remove(tab, 1);
      tab[0] = head;
      _g1 = _hx_tab_array(tab, length);
    else
      _g1 = _hx_tab_array({}, 0);
    end;
  else
    _g1 = _hx_tab_array(tab, length);
  end;
  while (_g < _g1.length) do _hx_do_first_1 = false;
    
    local s = _g1[_g];
    _g = _g + 1;
    if (peripheral.getType(s) == "monitor") then 
      self:addMonitior(__lua_Boot.__cast(s , String));
    end;
  end;
end
__kernel_hooks_CCMonitorDriverHook.prototype.deinit = function(self) 
end
__kernel_hooks_CCMonitorDriverHook.prototype.bg = function(self,ev) 
  if (ev[0] == "peripheral") then 
    if (peripheral.getType(ev[1]) == "monitor") then 
      self:addMonitior(__lua_Boot.__cast(ev[1] , String));
    end;
  else
    if (ev[0] == "peripheral_detach") then 
      if (self.mons:contains(ev[1])) then 
        self:remMonitior(__lua_Boot.__cast(ev[1] , String));
      end;
    end;
  end;
end
__kernel_hooks_CCMonitorDriverHook.prototype.addMonitior = function(self,s) 
  local _this = self.mons;
  local pos = self.mons.length;
  if (pos > _this.length) then 
    pos = _this.length;
  end;
  if (pos < 0) then 
    pos = _this.length + pos;
    if (pos < 0) then 
      pos = 0;
    end;
  end;
  local cur_len = _this.length;
  while (cur_len > pos) do _hx_do_first_1 = false;
    
    _this[cur_len] = _this[cur_len - 1];
    cur_len = cur_len - 1;
  end;
  _this[pos] = s;
  drv.add(__kernel_hooks_MonitorOutputDriver.new(s));
end
__kernel_hooks_CCMonitorDriverHook.prototype.remMonitior = function(self,s) 
  self.mons:remove(s);
  drv.rem(s);
end

__kernel_hooks_CCMonitorDriverHook.prototype.__class__ =  __kernel_hooks_CCMonitorDriverHook
__kernel_hooks_CCMonitorDriverHook.__super__ = __kernel_Hook
setmetatable(__kernel_hooks_CCMonitorDriverHook.prototype,{__index=__kernel_Hook.prototype})

__kernel_hooks_OutputDriver.new = function(output,name) 
  local self = _hx_new(__kernel_hooks_OutputDriver.prototype)
  __kernel_hooks_OutputDriver.super(self,output,name)
  return self
end
__kernel_hooks_OutputDriver.super = function(self,output,name) 
  self.output = __drivers_terminal_Terminal.new();
  __kernel_TerminalDriver.super(self);
  self.output = output;
  self.deviceName = name;
end
__kernel_hooks_OutputDriver.__name__ = "kernel.hooks.OutputDriver"
__kernel_hooks_OutputDriver.prototype = _hx_e();
__kernel_hooks_OutputDriver.prototype.write = function(self,s) 
  self.output:write(s);
end
__kernel_hooks_OutputDriver.prototype.clear = function(self) 
  self.output:clear();
end
__kernel_hooks_OutputDriver.prototype.setFGColor = function(self,col) 
  self.output:setFGColor(col);
end
__kernel_hooks_OutputDriver.prototype.setBGColor = function(self,col) 
  self.output:setBGColor(col);
end
__kernel_hooks_OutputDriver.prototype.set_palette = function(self,newc) 
  do return self.output:set_palette(newc) end
end
__kernel_hooks_OutputDriver.prototype.getCursorPos = function(self) 
  do return self.output:getCursorPos() end
end
__kernel_hooks_OutputDriver.prototype.setCursorPos = function(self,x,y) 
  self.output:setCursorPos(x, y);
end
__kernel_hooks_OutputDriver.prototype.setCursorPosRelative = function(self,x,y) 
  self.output:setCursorPosRelative(x, y);
end
__kernel_hooks_OutputDriver.prototype.get_size = function(self) 
  do return self.output:get_size() end
end
__kernel_hooks_OutputDriver.prototype.init = function(self) 
end
__kernel_hooks_OutputDriver.prototype.deinit = function(self) 
end
__kernel_hooks_OutputDriver.prototype.bg = function(self,ev) 
end
__kernel_hooks_OutputDriver.prototype.dataread = function(self) 
  do return "" end
end
__kernel_hooks_OutputDriver.prototype.datawrite = function(self,s) 
  self:write(s);
end

__kernel_hooks_OutputDriver.prototype.__class__ =  __kernel_hooks_OutputDriver
__kernel_hooks_OutputDriver.__super__ = __kernel_TerminalDriver
setmetatable(__kernel_hooks_OutputDriver.prototype,{__index=__kernel_TerminalDriver.prototype})

__kernel_hooks_CCMouseDriver.new = function() 
  local self = _hx_new(__kernel_hooks_CCMouseDriver.prototype)
  __kernel_hooks_CCMouseDriver.super(self)
  return self
end
__kernel_hooks_CCMouseDriver.super = function(self) 
  __kernel_MouseDriver.super(self);
  self.deviceName = "consolemouse";
end
__kernel_hooks_CCMouseDriver.__name__ = "kernel.hooks.CCMouseDriver"
__kernel_hooks_CCMouseDriver.prototype = _hx_e();
__kernel_hooks_CCMouseDriver.prototype.init = function(self) 
end
__kernel_hooks_CCMouseDriver.prototype.deinit = function(self) 
end
__kernel_hooks_CCMouseDriver.prototype.bg = function(self,ev) 
end
__kernel_hooks_CCMouseDriver.prototype.getEvent = function(self,filter) 
  while (true) do _hx_do_first_1 = false;
    
    local _hx_1_e_eventName, _hx_1_e_mouseButton, _hx_1_e_x, _hx_1_e_y = _G.coroutine.yield();
    if (String.prototype.substring(_hx_1_e_eventName, 0, 4) == "mouse") then 
      local met = __kernel_MouseEventType.Click;
      local _g = String.prototype.substring(_hx_1_e_eventName, 6);
      if (_g) == "click" then 
        met = __kernel_MouseEventType.Click;
        break;
      elseif (_g) == "drag" then 
        met = __kernel_MouseEventType.Drag;
        break;
      elseif (_g) == "scroll" then 
        met = __kernel_MouseEventType.Scroll;
        break;
      elseif (_g) == "up" then 
        met = __kernel_MouseEventType.ClickUp;
        break; end;
      do return __kernel_MouseEvent.new(met, _hx_1_e_x, _hx_1_e_y, _hx_1_e_mouseButton) end;
    end;
  end;
  do return __kernel_MouseEvent.new(__kernel_MouseEventType.Click, 1, 1, 1) end
end
__kernel_hooks_CCMouseDriver.prototype.dataread = function(self) 
  local e = self:getEvent(nil);
  do return Std.string(Std.string(Std.string(Std.string(Std.string(Std.string(Std.string("") .. Std.string(e.x)) .. Std.string(",")) .. Std.string(e.y)) .. Std.string(",")) .. Std.string(e.button)) .. Std.string(",")) .. Std.string(Std.string(e.type)) end
end
__kernel_hooks_CCMouseDriver.prototype.datawrite = function(self,s) 
end

__kernel_hooks_CCMouseDriver.prototype.__class__ =  __kernel_hooks_CCMouseDriver
__kernel_hooks_CCMouseDriver.__super__ = __kernel_MouseDriver
setmetatable(__kernel_hooks_CCMouseDriver.prototype,{__index=__kernel_MouseDriver.prototype})

__kernel_hooks_CCKeyboardDriver.new = function() 
  local self = _hx_new(__kernel_hooks_CCKeyboardDriver.prototype)
  __kernel_hooks_CCKeyboardDriver.super(self)
  return self
end
__kernel_hooks_CCKeyboardDriver.super = function(self) 
  __kernel_KeyboardDriver.super(self);
  self.deviceName = "consolekeyboard";
end
__kernel_hooks_CCKeyboardDriver.__name__ = "kernel.hooks.CCKeyboardDriver"
__kernel_hooks_CCKeyboardDriver.prototype = _hx_e();
__kernel_hooks_CCKeyboardDriver.prototype.init = function(self) 
end
__kernel_hooks_CCKeyboardDriver.prototype.deinit = function(self) 
end
__kernel_hooks_CCKeyboardDriver.prototype.bg = function(self,ev) 
end
__kernel_hooks_CCKeyboardDriver.prototype.readInt = function(self,timeout) 
  if (timeout == nil) then 
    timeout = -1;
  end;
  local tId = -1;
  if (timeout > 0) then 
    tId = os.startTimer(timeout);
  end;
  while (true) do _hx_do_first_1 = false;
    
    local _hx_1_e_name, _hx_1_e_key = _G.coroutine.yield();
    local _g = _hx_1_e_name;
    if (_g) == "key" then 
      do return _hx_1_e_key end;
    elseif (_g) == "timer" then 
      if (_hx_1_e_key == tId) then 
        do return -1 end;
      end;
      break; end;
  end;
  do return -1 end
end
__kernel_hooks_CCKeyboardDriver.prototype.readChar = function(self,timeout) 
  if (timeout == nil) then 
    timeout = -1;
  end;
  local tId = -1;
  if (timeout > 0) then 
    tId = os.startTimer(timeout);
  end;
  while (true) do _hx_do_first_1 = false;
    
    local _hx_1_e_name, _hx_1_e_key = _G.coroutine.yield();
    local _g = _hx_1_e_name;
    if (_g) == "char" then 
      do return __lua_Boot.__cast(_hx_1_e_key , String) end;
    elseif (_g) == "timer" then 
      if (_hx_1_e_key == tId) then 
        do return "" end;
      end;
      break; end;
  end;
  do return "" end
end
__kernel_hooks_CCKeyboardDriver.prototype.readChars = function(self,num,timeout,echo,echoOutput,showCursor) 
  if (showCursor == nil) then 
    showCursor = false;
  end;
  if (echo == nil) then 
    echo = "/";
  end;
  if (timeout == nil) then 
    timeout = -1;
  end;
  Sys.sleep(0.1);
  local ch = "";
  local tId = -1;
  local ocp = __globals_Vector2i.new(1, 1);
  if (echoOutput ~= nil) then 
    echoOutput:write(Std.string(ch) .. Std.string(((function() 
      local _hx_1
      if (showCursor) then 
      _hx_1 = "_"; else 
      _hx_1 = ""; end
      return _hx_1
    end )())));
  end;
  if (echoOutput ~= nil) then 
    ocp = echoOutput:getCursorPos();
  end;
  if (timeout > 0) then 
    tId = os.startTimer(timeout);
  end;
  while (#ch < num) do _hx_do_first_1 = false;
    
    local _hx_2_e_name, _hx_2_e_key = _G.coroutine.yield();
    local _g = _hx_2_e_name;
    if (_g) == "char" then 
      ch = Std.string(ch) .. Std.string(__lua_Boot.__cast(_hx_2_e_key , String));
      if (echoOutput ~= nil) then 
        if (echo == "/") then 
          echoOutput:setCursorPos(ocp.x, ocp.y);
          echoOutput:write(Std.string(ch) .. Std.string(((function() 
            local _hx_3
            if (showCursor) then 
            _hx_3 = "_"; else 
            _hx_3 = ""; end
            return _hx_3
          end )())));
        end;
      end;
      break;
    elseif (_g) == "key" then 
      if (_hx_2_e_key == 259) then 
        ch = String.prototype.substr(ch, 0, #ch - 1);
        if (echoOutput ~= nil) then 
          echoOutput:setCursorPos(ocp.x, ocp.y);
        end;
        if (echoOutput ~= nil) then 
          echoOutput:write(Std.string(Std.string(ch) .. Std.string(((function() 
            local _hx_4
            if (showCursor) then 
            _hx_4 = "_"; else 
            _hx_4 = ""; end
            return _hx_4
          end )()))) .. Std.string(" "));
        end;
      end;
    elseif (_g) == "timer" then 
      if (_hx_2_e_key == tId) then 
        do return "" end;
      end;
      break; end;
  end;
  do return ch end
end
__kernel_hooks_CCKeyboardDriver.prototype.dataread = function(self) 
  do return self:readChar() end
end
__kernel_hooks_CCKeyboardDriver.prototype.datawrite = function(self,s) 
end

__kernel_hooks_CCKeyboardDriver.prototype.__class__ =  __kernel_hooks_CCKeyboardDriver
__kernel_hooks_CCKeyboardDriver.__super__ = __kernel_KeyboardDriver
setmetatable(__kernel_hooks_CCKeyboardDriver.prototype,{__index=__kernel_KeyboardDriver.prototype})

__kernel_hooks_CCTermHook.new = function() 
  local self = _hx_new(__kernel_hooks_CCTermHook.prototype)
  __kernel_hooks_CCTermHook.super(self)
  return self
end
__kernel_hooks_CCTermHook.super = function(self) 
  __kernel_Hook.super(self);
end
__kernel_hooks_CCTermHook.__name__ = "kernel.hooks.CCTermHook"
__kernel_hooks_CCTermHook.prototype = _hx_e();
__kernel_hooks_CCTermHook.prototype.init = function(self) 
  drv.add(__kernel_hooks_OutputDriver.new(__drivers_terminal_Terminal.new(), "console"));
  drv.add(__kernel_hooks_CCMouseDriver.new());
  drv.add(__kernel_hooks_CCKeyboardDriver.new());
end
__kernel_hooks_CCTermHook.prototype.deinit = function(self) 
end
__kernel_hooks_CCTermHook.prototype.bg = function(self,ev) 
end

__kernel_hooks_CCTermHook.prototype.__class__ =  __kernel_hooks_CCTermHook
__kernel_hooks_CCTermHook.__super__ = __kernel_Hook
setmetatable(__kernel_hooks_CCTermHook.prototype,{__index=__kernel_Hook.prototype})

__lua_Boot.new = {}
__lua_Boot.__name__ = "lua.Boot"
__lua_Boot.__instanceof = function(o,cl) 
  if (cl == nil) then 
    do return false end;
  end;
  local cl1 = cl;
  if (cl1) == Array then 
    do return __lua_Boot.isArray(o) end;
  elseif (cl1) == Bool then 
    do return _G.type(o) == "boolean" end;
  elseif (cl1) == Dynamic then 
    do return o ~= nil end;
  elseif (cl1) == Float then 
    do return _G.type(o) == "number" end;
  elseif (cl1) == Int then 
    if (_G.type(o) == "number") then 
      do return _hx_bit_clamp(o) == o end;
    else
      do return false end;
    end;
  elseif (cl1) == String then 
    do return _G.type(o) == "string" end;
  elseif (cl1) == _G.table then 
    do return _G.type(o) == "table" end;
  elseif (cl1) == __lua_Thread then 
    do return _G.type(o) == "thread" end;
  elseif (cl1) == __lua_UserData then 
    do return _G.type(o) == "userdata" end;else
  if (((o ~= nil) and (_G.type(o) == "table")) and (_G.type(cl) == "table")) then 
    local tmp;
    if (__lua_Boot.__instanceof(o, Array)) then 
      tmp = Array;
    else
      if (__lua_Boot.__instanceof(o, String)) then 
        tmp = String;
      else
        local cl = o.__class__;
        tmp = (function() 
          local _hx_1
          if (cl ~= nil) then 
          _hx_1 = cl; else 
          _hx_1 = nil; end
          return _hx_1
        end )();
      end;
    end;
    if (__lua_Boot.extendsOrImplements(tmp, cl)) then 
      do return true end;
    end;
    if ((function() 
      local _hx_2
      if (cl == Class) then 
      _hx_2 = o.__name__ ~= nil; else 
      _hx_2 = false; end
      return _hx_2
    end )()) then 
      do return true end;
    end;
    if ((function() 
      local _hx_3
      if (cl == Enum) then 
      _hx_3 = o.__ename__ ~= nil; else 
      _hx_3 = false; end
      return _hx_3
    end )()) then 
      do return true end;
    end;
    do return o.__enum__ == cl end;
  else
    do return false end;
  end; end;
end
__lua_Boot.isArray = function(o) 
  if (_G.type(o) == "table") then 
    if ((o.__enum__ == nil) and (_G.getmetatable(o) ~= nil)) then 
      do return _G.getmetatable(o).__index == Array.prototype end;
    else
      do return false end;
    end;
  else
    do return false end;
  end;
end
__lua_Boot.__cast = function(o,t) 
  if ((o == nil) or __lua_Boot.__instanceof(o, t)) then 
    do return o end;
  else
    _G.error(__haxe_Exception.thrown(Std.string(Std.string(Std.string("Cannot cast ") .. Std.string(Std.string(o))) .. Std.string(" to ")) .. Std.string(Std.string(t))),0);
  end;
end
__lua_Boot.extendsOrImplements = function(cl1,cl2) 
  if ((cl1 == nil) or (cl2 == nil)) then 
    do return false end;
  else
    if (cl1 == cl2) then 
      do return true end;
    else
      if (cl1.__interfaces__ ~= nil) then 
        local intf = cl1.__interfaces__;
        local _g = 1;
        local _g1 = _hx_table.maxn(intf) + 1;
        while (_g < _g1) do _hx_do_first_1 = false;
          
          _g = _g + 1;
          local i = _g - 1;
          if (__lua_Boot.extendsOrImplements(intf[i], cl2)) then 
            do return true end;
          end;
        end;
      end;
    end;
  end;
  do return __lua_Boot.extendsOrImplements(cl1.__super__, cl2) end;
end

__lua_Thread.new = {}
__lua_Thread.__name__ = "lua.Thread"

__lua_UserData.new = {}
__lua_UserData.__name__ = "lua.UserData"

__lua_PairTools.new = {}
__lua_PairTools.__name__ = "lua.PairTools"
__lua_PairTools.pairsFold = function(table,func,seed) 
  for k,v in _G.pairs(table) do seed = func(k,v,seed) end;
  do return seed end;
end
__lua_PairTools.copy = function(table1) 
  local ret = ({});
  for k,v in _G.pairs(table1) do ret[k] = v end;
  do return ret end;
end
if _hx_bit_raw then
    _hx_bit_clamp = function(v)
    if v <= 2147483647 and v >= -2147483648 then
        if v > 0 then return _G.math.floor(v)
        else return _G.math.ceil(v)
        end
    end
    if v > 2251798999999999 then v = v*2 end;
    if (v ~= v or math.abs(v) == _G.math.huge) then return nil end
    return _hx_bit_raw.band(v, 2147483647 ) - math.abs(_hx_bit_raw.band(v, 2147483648))
    end
else
    _hx_bit_clamp = function(v)
        if v < -2147483648 then
            return -2147483648
        elseif v > 2147483647 then
            return 2147483647
        elseif v > 0 then
            return _G.math.floor(v)
        else
            return _G.math.ceil(v)
        end
    end
end;



_hx_array_mt.__index = Array.prototype

if nil then
  _hx_luv = {
    sleep = function(n)
        n = n / 1000
        if _G.sleep ~= nil then
            sleep(n)
        else
            print("Sleeping for " .. tonumber(n))
            os.execute("sleep " .. tonumber(n))
        end

    end,
    run = function(mode) return false end,
    loop_alive = function() return false end,
    fs_unlink = function(path)
        x= fs.delete(path)
        if not x then return true end
    end,
    fs_mkdir = function(path)
        x=fs.makeDir(path)
        if not x then return true end

    end,
    fs_rmdir = function(path)
        x= fs.delete(path)
        if not x then return true end
    end,
    fs_readdir = function(path)
        return fs.list(path)
    end,
    fs_scandir = function(path)
        
        return {0, path}
    end,
    fs_scandir_next = function(dsci)
        dsci[1] = dsci[1] + 1
        
        return fs.list(dsci[2])[dsci[1]]
    end,
    fs_stat = function(path)
        if not fs.exists(path) then return nil end
        return fs.attributes(path)
    end,
    fs_rename = function(p, np)
        return fs.move(p, np)
    end,
    fs_sendfile = function(outfile, infile)
        return fs.copy(infile, outfile)
    end,
    fs_chmod = function(a,b) end,
    fs_chown = function(a,b,c) end,
    fs_utime = function(a,b,c) end,
    fs_lstat = function(path) error("Tried link operation") end,-- This may be provided by your current os, but CraftOS or computercraft bios-level executed code do not have this operation
    fs_link = function(p, a) error("Tried link operation") end,-- This may be provided by your current os, but CraftOS or computercraft bios-level executed code do not have this operation
    fs_symlink = function(p, a, m) error("Tried link operation") end,-- This may be provided by your current os, but CraftOS or computercraft bios-level executed code do not have this operation
    fs_readlink = function(p) error("Tried link operation") end, -- This may be provided by your current os, but CraftOS or computercraft bios-level executed code do not have this operation 
    fs_cwd = function()
        if shell then return shell.dir() else return "/" end
    end,
    fs_chdir = function(path)
        if shell then return shell.setDir(path) end
    end,
    fs_exepath = function(path)
        if shell then
            return shell.getRunningProgram()
        else
            return debug.getinfo(1, "S").source
        end
    end,
    fs_open = function(path, mode, _)
        local f = fs.open(path, mode)
        return {
            read = function(len, offset)
                if offset then
                    f.seek(offset)
                end
                local actuallyread = f.read(len)
                return #actuallyread, actuallyread
            end,
            write = function(data, offset)
                if offset then
                    f.seek(offset)
                else
                    f.seek(1)
                end
                f.write(data)
            end,
            close = function()
                f.close()
            end,
            stat = function ()
                return fs.attributes(path)
            end,
            sync = function () end, -- There doesn't seem to be an imlpementation for this function in computercraft
            datasync = function () end, -- Same as above
            utime = function () end, -- Might be provided by os, but not in craftos or cc bioslevel.
            chmod = function () end, -- Might be provided by os, but not in craftos or cc bioslevel.
            chown = function () end, -- Might be provided by os, but not in craftos or cc bioslevel.
            truncate = function () end, -- Developer does not know what this means
        }

    end
};
else
  _hx_luv = {
    run=function(mode) return false end,
    loop_alive=function() return false end
  }
end
local _hx_static_init = function()
  
  String.__name__ = "String";
  Array.__name__ = "Array";__globals_Globals.version = "0.01x";
  
  __globals_Colors.white = __globals_Color.new(0, 1);
  
  __globals_Colors.orange = __globals_Color.new(1, 2);
  
  __globals_Colors.magenta = __globals_Color.new(2, 4);
  
  __globals_Colors.lightBlue = __globals_Color.new(3, 8);
  
  __globals_Colors.yellow = __globals_Color.new(4, 16);
  
  __globals_Colors.lime = __globals_Color.new(5, 32);
  
  __globals_Colors.pink = __globals_Color.new(6, 64);
  
  __globals_Colors.gray = __globals_Color.new(7, 128);
  
  __globals_Colors.lightGray = __globals_Color.new(8, 256);
  
  __globals_Colors.cyan = __globals_Color.new(9, 512);
  
  __globals_Colors.purple = __globals_Color.new(10, 1024);
  
  __globals_Colors.blue = __globals_Color.new(11, 2048);
  
  __globals_Colors.brown = __globals_Color.new(12, 4096);
  
  __globals_Colors.green = __globals_Color.new(13, 8192);
  
  __globals_Colors.red = __globals_Color.new(14, 16384);
  
  __globals_Colors.black = __globals_Color.new(15, 32768);
  
  __haxe_ds_StringMap.tnull = ({});
  
  drv.sdrivers = _hx_tab_array({}, 0);
  
  __kernel_Logger.logBuf = "";
  
  
end

_hx_print = print or (function() end)

_hx_box_mr = function(x,nt)
    res = _hx_o({__fields__={}})
    for i,v in ipairs(nt) do
      res[v] = x[i]
    end
    return res
end

_hx_table = {}
_hx_table.pack = _G.table.pack or function(...)
    return {...}
end
_hx_table.unpack = _G.table.unpack or _G.unpack
_hx_table.maxn = _G.table.maxn or function(t)
  local maxn=0;
  for i in pairs(t) do
    maxn=type(i)=='number'and i>maxn and i or maxn
  end
  return maxn
end;

function _hx_handle_error(obj)
  local message = tostring(obj)
  if _G.debug and _G.debug.traceback then
    -- level 2 to skip _hx_handle_error
    message = _G.debug.traceback(message, 2)
  end
  return setmetatable({}, { __tostring = function() return message end })
end

_hx_static_init();
local success, err = _G.xpcall(function() 
  __kernel_Kernel.main();
  _hx_luv.run();
end, _hx_handle_error)
if not success then _G.error(err) end
