/* tslint:disable */// Generated by Haxe TypeScript Declaration Generator :)

export class Transition {
	constructor(direction: string, anim?: string, curve?: string, duration?: number);
	direction: string;
	anim: string;
	curve: string;
	duration: number;
	run(callback: (e: number) => void, min: number, max: number): void;
	copy(): Transition;
	runForScreens(callback: (prevx: number, prevy: number, newx: number, newy: number, firstOnTop: boolean, progress: number) => void, screenwidth: number, screenheight: number): void;
	getValue(ratioa: number): number;
}

export class Command {
	constructor(type: string, value?: string, transition?: Transition);
	type: string;
	value: string;
	transition: Transition;
	serialize(): any;
	execute(runner: Widget, screenwidth: number, screenheight: number): void;
	static deserialize(d: { [key: string]: any }): Command;
}

export interface haxe_IMap<K, V> {
}

export class Widget {
	constructor();
	/**
	 * The X value for the widget
	 */
	x: number;
	/**
	 * The Y value for the widget
	 */
	y: number;
	/**
	 * The X align value for the widget.
	 * wx = x + xa * screenwidth - xa * widgetwidth
	 * So, that means that
	 * To align left: use 0
	 * To align center: use 0.5
	 * To align right: use 1
	 */
	xa: number;
	/**
	 * The Y align value for the widget.
	 * wy = y + ya * screenheight - ya * widgetheight
	 * So, that means that
	 * To align up: use 0
	 * To align middle: use 0.5
	 * To align down: use 1
	 */
	ya: number;
	/**
	 * Wether to expand vertically.
	 */
	vexpand: number;
	/**
	 * Wether to expand horizontally.
	 */
	hexpand: number;
	/**
	 * The widget's width (in characters)
	 */
	width: number;
	/**
	 * The widget's height (in characters)
	 */
	height: number;
	/**
	 * The widget's children
	 */
	children: Widget[];
	/**
	 * The widget's visible status.
	 */
	visible: boolean;
	parent: Widget;
	style: Style;
	wman: ScreenManager;
	id: string;
	requestsRerender: boolean;
	requestRerender(): void;
	getWman(): ScreenManager;
	fixedWidth(screenwidth: number, screenheight: number, ignoreParent?: boolean): number;
	fixedHeight(screenwidth: number, screenheight: number, ignoreParent?: boolean): number;
	getPRenderCommands(screenwidth: number, screenheight: number, respectPosition?: boolean): PositionedRenderCommand[];
	fixedX(screenwidth: number, screenheight: number, ignoreParent?: boolean): number;
	fixedY(screenwidth: number, screenheight: number, ignoreParent?: boolean): number;
	fixedXC(xc: number, screenwidth: number, screenheight: number, ignoreParent?: boolean, includeThis?: boolean): number;
	fixedYC(yc: number, screenwidth: number, screenheight: number, ignoreParent?: boolean, includeThis?: boolean): number;
	addChild(child: Widget): void;
	remChild(child: Widget): void;
	getChildByID(id: string): Widget;
	recFilterChildren(filter: (c: Widget) => boolean): Widget[];
	recFilterChildrenUF(filter: (c: Widget) => boolean): Widget[];
	getTypename(): string;
	/**
	 * Utility function to get the size of an object, but if object is not visible the function returns 0
	 * @return Vector2i
	 */
	getSize(): Vector2f;
	/**
	 * This function should return positionedrendercommands.
	 * They are supposed to be relative to 0,0 because getprendercommands automatically adds the offset
	 * This function should not be used
	 * @return Array<PositionedRenderCommand>
	 */
	renderImpl(screenwidth: number, screenheight: number, width: number, height: number): PositionedRenderCommand[];
	/**
	 * Note: All positions are relative to widget origin
	 * @param pos
	 * @param mb
	 */
	onClick(pos: Vector2f, mb: any, wself: boolean): void;
	/**
	 * Note: All positions are relative to widget origin
	 * @param startpos
	 * @param pos
	 * @param mb
	 */
	onDrag(startpos: Vector2f, pos: Vector2f, mb: any, wself: boolean): void;
	/**
	 * Note: All positions are relative to widget origin
	 * @param startpos
	 * @param pos
	 * @param mb
	 */
	onClickUp(startpos: Vector2f, pos: Vector2f, mb: any, wself: boolean): void;
	/**
	 * Note: All positions are relative to widget origin
	 * @param pos
	 * @param dir
	 */
	onScroll(pos: Vector2f, dir: number, wself: boolean): void;
	/**
	 * On system event
	 * @param c
	 */
	onCustom(c: any[]): void;
	/**
	 * After rendering. The screen is already rendered so place your cursor mods here!
	 */
	onRender(): void;
	getEditorFields(): haxe_IMap<string,string>;
	serialize(): haxe_IMap<string,any>;
	toJSON(): string;
	static deserialize(data: { [key: string]: any }): Widget;
	static fromJSON(json: string): Widget;
}

export class SimpleContainer extends Widget {
	constructor(widgets: Widget[]);
	getMostWidgetHeight(): number;
	renderImpl(screenwidth: number, screenheight: number, width: number, height: number): PositionedRenderCommand[];
	/**
	 * Note: All positions are relative to widget origin
	 * @param pos
	 * @param mb
	 */
	onClick(pos: Vector2f, mb: any, wself: boolean): void;
	/**
	 * Note: All positions are relative to widget origin
	 * @param startpos
	 * @param pos
	 * @param mb
	 */
	onDrag(startpos: Vector2f, pos: Vector2f, mb: any, wself: boolean): void;
	/**
	 * Note: All positions are relative to widget origin
	 * @param startpos
	 * @param pos
	 * @param mb
	 */
	onClickUp(startpos: Vector2f, pos: Vector2f, mb: any, wself: boolean): void;
	/**
	 * Note: All positions are relative to widget origin
	 * @param pos
	 * @param dir
	 */
	onScroll(pos: Vector2f, dir: number, wself: boolean): void;
	/**
	 * On system event
	 * @param c
	 */
	onCustom(c: any[]): void;
	onRender(): void;
	getTypename(): string;
}

export class Button extends SimpleContainer {
	constructor(widgets: Widget[], command: Command);
	command: Command;
	getTypename(): string;
	onClick(pos: Vector2f, mb: any, wself: boolean): void;
}

export class Color {
	constructor(blitText: string, palNumber: number, bitASC: number);
	palNumber: number;
	bitASC: number;
	blit: string;
}

export class RGBColor {
	constructor(r: number, g: number, b: number);
	red: number;
	green: number;
	blue: number;
}

export class Colors {
	protected constructor();
	static white: Color;
	static orange: Color;
	static magenta: Color;
	static lightBlue: Color;
	static yellow: Color;
	static lime: Color;
	static pink: Color;
	static gray: Color;
	static lightGray: Color;
	static cyan: Color;
	static purple: Color;
	static blue: Color;
	static brown: Color;
	static green: Color;
	static red: Color;
	static black: Color;
	static fromBlit(b: string): Color;
}

export class Label extends Widget {
	constructor(x: number, y: number, text: string);
	text: string;
	renderImpl(screenwidth: number, screenheight: number, width: number, height: number): PositionedRenderCommand[];
	getTypename(): string;
}

export class TextArea extends Widget {
	constructor(x: number, y: number, placeholder: string);
	placeholder: string;
	value: string;
	isFocused: boolean;
	focused: boolean;
	cursorPos: Vector2f;
	scroll: Vector2f;
	ctrlPressed: boolean;
	onSubmit: Command;
	onTab: Command;
	onClick(pos: Vector2f, mb: any, wself: boolean): void;
	onCustom(c: any[]): void;
	onRender(): void;
	renderImpl(screenwidth: number, screenheight: number, width: number, height: number): PositionedRenderCommand[];
	getTypename(): string;
	additionalEditorFields(): haxe_IMap<string,string>;
}

/**
 * A container with scrolling functionality. Fundementally the same as simplecontainer.
 */
export class ScrollContainer extends SimpleContainer {
	constructor(widgets: Widget[]);
	getTypename(): string;
	onScroll(pos: Vector2f, dir: number, wself: boolean): void;
}

export class Values {
	protected constructor();
	static typenames: haxe_IMap<string,() => Widget>;
}

export class RenderCommand {
	constructor(char: string, belongsToID: string, fgColor?: Color, bgColor?: Color);
	char: string;
	belongsToID: string;
	fgColor: Color;
	bgColor: Color;
}

export class PositionedRenderCommand extends RenderCommand {
	constructor(x: number, y: number, char: string, belongsToID: string, fgColor?: Color, bgColor?: Color);
	x: number;
	y: number;
}

export class Buffer {
	/**
	 * Creates the buffer
	 * @param width buffer width
	 * @param height buffer height
	 */
	constructor(width: number, height: number);
	/**
	 * Buffer width
	 */
	width: number;
	/**
	 * Buffer height
	 */
	height: number;
	/**
	 * The 2-dimentional array containing buffer data
	 */
	matrix: RenderCommand[][];
	/**
	 * Reinitializes the buffer, clearing the screen
	 */
	reinitBuffer(bgcolor: Color): void;
	/**
	 * Adds a positioned render command.
	 * @param rc The PRC to draw on the buffer
	 */
	addPRC(rc: PositionedRenderCommand): void;
	draw(term: typedefs_Terminal): void;
	/**
	 * Blits buffer onto this buffer
	 * @param buffer The buffer to blit from
	 * @param ox Offset X
	 * @param oy Offset Y
	 */
	blitBuffer(buffer: Buffer, ox: number, oy: number): void;
}

export class Renderer {
	constructor(terminal: typedefs_Terminal);
	/**
	 * The buffer.
	 */
	buffer1: Buffer;
	/**
	 * The current buffer, uses boolean for memory efficiency on some platforms
	 * False = 1st buffer
	 * True = 2nd buffer
	 */
	currentBuffer: boolean;
	term: typedefs_Terminal;
	renderToBuffer(scr: Widget, ox: number, oy: number, buffer: Buffer): void;
	render(scr: Widget): void;
	resize(x: number, y: number): void;
}

/**
 * `PosInfos` is a magic type which can be used to generate position information
 * into the output for debugging use.
 * If a function has a final optional argument of this type, i.e.
 * `(..., ?pos:haxe.PosInfos)`, each call to that function which does not assign
 * a value to that argument has its position added as call argument.
 * This can be used to track positions of calls in e.g. a unit testing
 * framework.
 */
export type haxe_PosInfos = {
	className: string;
	customParams: any[];
	fileName: string;
	lineNumber: number;
	methodName: string;
}

export class Runner {
	constructor(term: typedefs_Terminal, root: Widget, peripheralName?: string);
	root: ScreenManager;
	run(): void;
	render(): void;
	event(ev: any[]): void;
	static log(t: string, posInfos?: haxe_PosInfos): void;
}

export class UILoader {
	constructor(ui: string);
}

export class ScreenManager {
	constructor(terminal: typedefs_Terminal);
	screens: Widget[];
	currentScreen: number;
	term: typedefs_Terminal;
	addScreen(scr: Widget): void;
	rmScreen(scr: Widget): void;
	current(): Widget;
	toJSON(): string;
	static fromJSON(term: typedefs_Terminal, json: string): ScreenManager;
}

export class Vector2f {
	constructor(x: number, y: number);
	x: number;
	y: number;
	addInts(x: number, y: number): Vector2f;
	static add(vec1: Vector2f, vec: Vector2f): Vector2f;
}

export class Style {
	constructor();
	bgColor: Color;
	fgColor: Color;
}

export class typedefs_Terminal {
	constructor();
	write(s: string): void;
	clear(): void;
	setCursorPos(x: number, y: number): void;
	getSize(): Vector2f;
	setPaletteColor(paln: number, r: number, g: number, b: number): void;
	blit(text: string, fgColors: string, bgColors: string): void;
	setCursorBlink(b: boolean): void;
	size: Vector2f;
}

export class typedefs_Simpleterminal extends typedefs_Terminal {
	constructor(pf: (s: string) => void);
	get_palette(): RGBColor[];
	write(s: string): void;
	clear(): void;
	setTextColor(col: Color): void;
	setBackgroundColor(col: Color): void;
	setCursorPos(x: number, y: number): void;
	set_palette(newc: RGBColor[]): RGBColor[];
	setPaletteColor(paln: number, r: number, g: number, b: number): void;
	getSize(): Vector2f;
	blit(a: string, b: string, c: string): void;
	setCursorBlink(b: boolean): void;
	static apalettea: RGBColor[];
}